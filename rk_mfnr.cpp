//
/////////////////////////////////////////////////////////////////////////
// File: rk_mfnr.c
// Desc: Implementation of MFNR
// 
// Date: Revised by yousf 20160721
// 
//////////////////////////////////////////////////////////////////////////
////-------- Header files
//
#include "rk_mfnr.h"                 // MFNR: Multi-Frame Noise Reduction


//////////////////////////////////////////////////////////////////////////
////---- Region4IndexTable: Revised by yousf 20160505
RK_U8 Region4IndexTable[4*NUM_R4IT_CHOICE] = {
    0,  3, 12, 15,  0,  2, 12, 15,  0,  3,  8, 15,  0,  3, 11, 12,  0,  3, 12, 14,  0,  3, 13, 15,  0,  7, 12, 15,  1,  3, 12, 15,  3,  4, 12, 15,  0,  2, 11, 12, 
    0,  3,  8, 14,  0,  3, 11, 13,  0,  7, 12, 14,  1,  3,  8, 15,  1,  7, 12, 15,  2,  4, 12, 15,  3,  4, 13, 15,  0,  1, 12, 15,  0,  2,  8, 15,  0,  2, 12, 14, 
    0,  2, 13, 15,  0,  3,  4, 15,  0,  3,  7, 12,  0,  3,  8, 11,  0,  3,  9, 15,  0,  3, 10, 12,  0,  3, 12, 13,  0,  3, 13, 14,  0,  3, 14, 15,  0,  6, 12, 15, 
    0,  7,  8, 15,  0,  7, 11, 12,  0,  7, 13, 15,  0, 11, 12, 15,  1,  2, 12, 15,  1,  3, 11, 12,  1,  3, 12, 14,  1,  3, 13, 15,  2,  3, 12, 15,  3,  4,  8, 15, 
    3,  4, 11, 12,  3,  4, 12, 14,  3,  5, 12, 15,  3,  8, 12, 15,  4,  7, 12, 15,  0,  1, 11, 12,  0,  2,  7, 12,  0,  2, 11, 13,  0,  3,  4, 14,  0,  3,  7, 13, 
    0,  3,  8, 13,  0,  3, 11, 14,  0,  7,  8, 14,  0,  7, 12, 13,  0, 11, 12, 14,  1,  3,  4, 15,  1,  3,  8, 14,  1,  4, 12, 15,  1,  7,  8, 15,  1,  7, 12, 14, 
    1, 11, 12, 15,  2,  3,  8, 15,  2,  4, 11, 12,  2,  4, 13, 15,  2,  7, 12, 15,  2,  8, 12, 15,  3,  4, 11, 13,  3,  4, 14, 15,  3,  8, 13, 15,  0,  1,  7, 12, 
    0,  2,  7, 13,  0,  2,  8, 11,  0,  2,  8, 14,  0,  2, 10, 12,  0,  3,  4, 13,  0,  3,  7, 14,  0,  3,  8, 10,  0,  3,  9, 11,  0,  3,  9, 14,  0,  3, 10, 13, 
    0,  6, 11, 12,  0,  6, 12, 14,  0,  7,  8, 13,  0,  7, 10, 12,  0,  7, 11, 13,  0,  7, 13, 14,  0, 11, 12, 13,  1,  2,  8, 15,  1,  2, 11, 12,  1,  3,  4, 14, 
    1,  3,  8, 11,  1,  3,  9, 15,  1,  3, 11, 13,  1,  4, 11, 12,  1,  6, 12, 15,  1,  7,  8, 14,  1,  7, 11, 12,  1,  7, 13, 15,  1,  8, 12, 15,  1, 11, 12, 14, 
    2,  3,  4, 15,  2,  4,  8, 15,  2,  4, 11, 13,  2,  4, 12, 14,  2,  5, 12, 15,  2,  7,  8, 15,  2,  8, 13, 15,  2, 11, 12, 15,  3,  4,  8, 14,  3,  4,  9, 15, 
    3,  4, 11, 14,  3,  4, 13, 14,  3,  5,  8, 15,  3,  5, 13, 15,  3,  8, 14, 15,  4,  6, 12, 15,  4,  7, 12, 14,  4,  7, 13, 15,  5,  7, 12, 15,  0,  1,  3, 12, 
    0,  1,  3, 13,  0,  1,  3, 14,  0,  1,  3, 15,  0,  1,  7, 13,  0,  1,  8, 15,  0,  1, 11, 13,  0,  1, 12, 14,  0,  1, 13, 15,  0,  2,  3, 12,  0,  2,  3, 13, 
    0,  2,  3, 14,  0,  2,  3, 15,  0,  2,  4, 15,  0,  2,  7, 14,  0,  2,  9, 15,  0,  2, 11, 14,  0,  2, 12, 13,  0,  2, 13, 14,  0,  2, 14, 15,  0,  3,  4, 11, 
    0,  3,  4, 12,  0,  3,  5, 12,  0,  3,  5, 13,  0,  3,  5, 14,  0,  3,  5, 15,  0,  3,  6, 12,  0,  3,  6, 13,  0,  3,  6, 14,  0,  3,  6, 15,  0,  3,  7,  8, 
    0,  3,  7, 15,  0,  3,  8, 12,  0,  3,  9, 12,  0,  3,  9, 13,  0,  3, 10, 14,  0,  3, 10, 15,  0,  3, 11, 15,  0,  4,  7, 12,  0,  4,  7, 13,  0,  4,  7, 14, 
    0,  4,  7, 15,  0,  4, 11, 12,  0,  4, 12, 15,  0,  5,  7, 12,  0,  5, 11, 12,  0,  5, 12, 15,  0,  6,  7, 12,  0,  6,  8, 15,  0,  6, 13, 15,  0,  7,  8, 11, 
    0,  7,  8, 12,  0,  7,  9, 12,  0,  7,  9, 15,  0,  7, 14, 15,  0,  8, 11, 12,  0,  8, 11, 13,  0,  8, 11, 14,  0,  8, 11, 15,  0,  8, 12, 15,  0,  9, 11, 12, 
    0,  9, 12, 15,  0, 10, 11, 12,  0, 10, 12, 15,  0, 11, 13, 15,  0, 12, 13, 15,  0, 12, 14, 15,  1,  2, 12, 14,  1,  2, 13, 15,  1,  3,  4, 13,  1,  3,  7, 12, 
    1,  3,  8, 13,  1,  3, 10, 12,  1,  3, 12, 13,  1,  3, 13, 14,  1,  3, 14, 15,  1,  4,  7, 12,  1,  4,  7, 13,  1,  4,  7, 14,  1,  4,  7, 15,  1,  4, 11, 13, 
    1,  4, 13, 15,  1,  5, 12, 15,  1,  7,  8, 13,  1,  7, 12, 13,  1,  8, 11, 12,  1,  8, 11, 13,  1,  8, 11, 14,  1,  8, 11, 15,  1,  8, 13, 15,  1,  9, 12, 15, 
    1, 10, 12, 15,  1, 11, 12, 13,  1, 12, 13, 15,  1, 12, 14, 15,  2,  3,  4, 14,  2,  3,  8, 14,  2,  3, 11, 12,  2,  3, 12, 14,  2,  3, 13, 15,  2,  4,  7, 12, 
    2,  4,  7, 13,  2,  4,  7, 14,  2,  4,  7, 15,  2,  4, 11, 14,  2,  4, 14, 15,  2,  6, 12, 15,  2,  7,  8, 14,  2,  7, 12, 14,  2,  8, 11, 12,  2,  8, 11, 13, 
    2,  8, 11, 14,  2,  8, 11, 15,  2,  8, 14, 15,  2,  9, 12, 15,  2, 10, 12, 15,  2, 11, 12, 14,  2, 12, 13, 15,  2, 12, 14, 15,  3,  4,  5, 15,  3,  4,  6, 15, 
    3,  4,  7, 12,  3,  4,  7, 13,  3,  4,  7, 14,  3,  4,  7, 15,  3,  4,  8, 11,  3,  4, 10, 12,  3,  4, 10, 15,  3,  4, 11, 15,  3,  4, 12, 13,  3,  5, 11, 12, 
    3,  5, 12, 14,  3,  6,  8, 15,  3,  6, 12, 15,  3,  7,  8, 15,  3,  7, 12, 15,  3,  8,  9, 15,  3,  8, 10, 15,  3,  8, 11, 12,  3,  8, 11, 13,  3,  8, 11, 14, 
    3,  8, 11, 15,  3,  8, 12, 14,  3,  9, 12, 15,  3, 10, 12, 15,  3, 11, 12, 15,  3, 12, 13, 15,  3, 12, 14, 15,  4,  7,  8, 15,  4,  7, 11, 12,  4, 11, 12, 15, 
    7,  8, 12, 15,  0,  1,  7, 14,  0,  1,  8, 11,  0,  1, 10, 12,  0,  2,  4, 14,  0,  2,  6, 12,  0,  2,  7,  8,  0,  2,  7, 15,  0,  2,  8, 10,  0,  2,  8, 13, 
    0,  2,  9, 11,  0,  2, 10, 13,  0,  3,  4, 10,  0,  3,  7,  9,  0,  3,  8,  9,  0,  3,  9, 10,  0,  3, 10, 11,  0,  4, 11, 13,  0,  5,  7, 13,  0,  6,  7, 13, 
    0,  6,  8, 14,  0,  6, 10, 12,  0,  6, 11, 13,  0,  6, 12, 13,  0,  7,  8, 10,  0,  7,  9, 13,  0,  7,  9, 14,  0,  7, 10, 13,  0,  7, 11, 14,  0,  8, 13, 15, 
    0, 10, 12, 14,  0, 11, 13, 14,  1,  2,  4, 15,  1,  2,  7, 12,  1,  2,  8, 11,  1,  2,  8, 14,  1,  2, 11, 13,  1,  3,  4, 11,  1,  3,  4, 12,  1,  3,  5, 15, 
    1,  3,  7, 13,  1,  3,  8, 10,  1,  3,  9, 11,  1,  3,  9, 14,  1,  3, 11, 14,  1,  4,  8, 15,  1,  4, 11, 14,  1,  4, 12, 14,  1,  5, 11, 12,  1,  6,  8, 15, 
    1,  6, 11, 12,  1,  6, 12, 14,  1,  7,  8, 11,  1,  7,  8, 12,  1,  7,  9, 15,  1,  7, 10, 12,  1,  7, 11, 13,  1,  7, 13, 14,  1,  8, 14, 15,  1,  9, 11, 12, 
    1, 10, 11, 12,  1, 11, 13, 15,  2,  3,  4, 13,  2,  3,  8, 11,  2,  3,  9, 15,  2,  4,  8, 11,  2,  4,  8, 14,  2,  4,  9, 15,  2,  4, 10, 12,  2,  4, 11, 15, 
    2,  4, 13, 14,  2,  5,  8, 15,  2,  5, 11, 12,  2,  5, 13, 15,  2,  6,  8, 15,  2,  7,  8, 13,  2,  7, 11, 12,  2,  7, 13, 15,  2,  8,  9, 15,  2,  8, 10, 15, 
    2,  8, 12, 14,  2, 11, 12, 13,  3,  4,  5, 14,  3,  4,  6, 14,  3,  4,  8, 13,  3,  4,  9, 11,  3,  4,  9, 14,  3,  4, 10, 13,  3,  4, 10, 14,  3,  5,  8, 14, 
    3,  5,  9, 15,  3,  5, 11, 13,  3,  5, 14, 15,  3,  7,  8, 14,  3,  8, 13, 14,  3,  9, 13, 15,  3, 11, 12, 14,  4,  5, 12, 15,  4,  6, 11, 12,  4,  6, 12, 14, 
    4,  6, 13, 15,  4,  7,  8, 14,  4,  7, 11, 13,  4,  7, 12, 13,  4,  7, 13, 14,  4,  7, 14, 15,  4, 11, 12, 14,  5,  6, 12, 15,  5,  7,  8, 15,  5,  7, 12, 14, 
    5,  7, 13, 15,  5, 11, 12, 15,  6,  7, 12, 15,  6,  8, 12, 15,  7,  8, 13, 15,  0,  1,  6, 12,  0,  1,  7,  8,  0,  1,  7, 15,  0,  1,  8, 14,  0,  1, 11, 14, 
    0,  2,  4, 11,  0,  2,  4, 13,  0,  2,  6, 13,  0,  2,  7,  9,  0,  2,  9, 12,  0,  2,  9, 14,  0,  2, 11, 15,  0,  3,  4,  9,  0,  3,  5, 11,  0,  3,  6,  8, 
    0,  3,  7, 10,  0,  4, 11, 14,  0,  4, 13, 15,  0,  5,  7, 14,  0,  5, 11, 13,  0,  5, 12, 14,  0,  6,  7, 14,  0,  6,  8, 11,  0,  6,  8, 13,  0,  6, 13, 14, 
    0,  7,  8,  9,  0,  7,  9, 11,  0,  7, 10, 14,  0,  8, 14, 15,  0,  9, 11, 13,  0, 10, 11, 13,  0, 10, 12, 13,  1,  2,  4, 14,  1,  2,  7, 13,  1,  2,  9, 15, 
    1,  2, 10, 12,  1,  3,  4, 10,  1,  3,  5, 14,  1,  3,  7,  8,  1,  3,  7, 14,  1,  3,  8, 12,  1,  3, 10, 13,  1,  3, 10, 15,  1,  4,  8, 11,  1,  4, 10, 12, 
    1,  4, 11, 15,  1,  4, 14, 15,  1,  5,  7, 12,  1,  5,  8, 15,  1,  6,  7, 12,  1,  6,  8, 14,  1,  6, 13, 15,  1,  7,  8, 10,  1,  7,  9, 12,  1,  7,  9, 14, 
    1,  7, 14, 15,  1,  8,  9, 15,  1,  8, 10, 15,  1,  8, 12, 14,  1, 10, 12, 14,  1, 11, 13, 14,  2,  3,  4, 11,  2,  3,  4, 12,  2,  3,  5, 15,  2,  3,  8, 13, 
    2,  3, 11, 13,  2,  4,  5, 15,  2,  4,  6, 15,  2,  4,  9, 11,  2,  4, 10, 13,  2,  4, 10, 15,  2,  4, 12, 13,  2,  5, 11, 13,  2,  5, 12, 14,  2,  6, 11, 12, 
    2,  7,  8, 11,  2,  7,  8, 12,  2,  7,  9, 15,  2,  7, 12, 13,  2,  8, 13, 14,  2,  9, 11, 12,  2,  9, 13, 15,  2, 10, 11, 12,  2, 11, 13, 15,  3,  4,  5, 13, 
    3,  4,  6, 13,  3,  4,  8, 10,  3,  4,  9, 13,  3,  4, 10, 11,  3,  5,  8, 11,  3,  5, 11, 14,  3,  5, 13, 14,  3,  6,  8, 14,  3,  6, 13, 15,  3,  7,  8, 13, 
    3,  7, 12, 14,  3,  8,  9, 14,  3,  8, 10, 14,  3,  9, 14, 15,  3, 11, 12, 13,  4,  5, 11, 12,  4,  6,  8, 15,  4,  6, 11, 13,  4,  7,  8, 13,  4,  7,  9, 15, 
    4,  7, 10, 12,  4,  7, 11, 14,  4, 10, 12, 15,  4, 11, 12, 13,  4, 11, 13, 15,  5,  7,  8, 14,  5,  7, 11, 12,  5,  8, 12, 15,  5, 11, 12, 14,  6,  7,  8, 15, 
    6,  8, 13, 15,  6, 11, 12, 15,  7,  8, 12, 14,  7,  8, 14, 15,  7,  9, 12, 15,  0,  1,  2, 12,  0,  1,  2, 13,  0,  1,  2, 14,  0,  1,  2, 15,  0,  1,  3,  8, 
    0,  1,  3,  9,  0,  1,  3, 10,  0,  1,  3, 11,  0,  1,  4, 15,  0,  1,  6, 13,  0,  1,  7,  9,  0,  1,  8, 10,  0,  1,  9, 11,  0,  1,  9, 15,  0,  1, 10, 13, 
    0,  1, 12, 13,  0,  1, 13, 14,  0,  1, 14, 15,  0,  2,  3,  8,  0,  2,  3,  9,  0,  2,  3, 10,  0,  2,  3, 11,  0,  2,  4, 10,  0,  2,  4, 12,  0,  2,  5, 12, 
    0,  2,  5, 13,  0,  2,  5, 14,  0,  2,  5, 15,  0,  2,  6,  8,  0,  2,  6, 14,  0,  2,  6, 15,  0,  2,  7, 10,  0,  2,  8,  9,  0,  2,  8, 12,  0,  2,  9, 10, 
    0,  2,  9, 13,  0,  2, 10, 11,  0,  2, 10, 14,  0,  2, 10, 15,  0,  3,  4,  7,  0,  3,  4,  8,  0,  3,  5,  8,  0,  3,  5,  9,  0,  3,  5, 10,  0,  3,  6,  9, 
    0,  3,  6, 10,  0,  3,  6, 11,  0,  3,  7, 11,  0,  4,  6, 12,  0,  4,  6, 13,  0,  4,  6, 14,  0,  4,  6, 15,  0,  4,  7,  8,  0,  4,  7,  9,  0,  4,  7, 10, 
    0,  4,  7, 11,  0,  4,  8, 11,  0,  4,  8, 15,  0,  4, 10, 12,  0,  4, 11, 15,  0,  4, 12, 14,  0,  5,  6, 12,  0,  5,  7,  8,  0,  5,  7, 15,  0,  5,  8, 11, 
    0,  5,  8, 15,  0,  5, 10, 12,  0,  5, 13, 15,  0,  6,  7,  8,  0,  6,  7, 15,  0,  6,  8, 10,  0,  6,  8, 12,  0,  6,  9, 12,  0,  6,  9, 15,  0,  6, 10, 13, 
    0,  6, 11, 14,  0,  6, 14, 15,  0,  7,  9, 10,  0,  7, 10, 15,  0,  7, 11, 15,  0,  8,  9, 11,  0,  8,  9, 15,  0,  8, 10, 11,  0,  8, 10, 12,  0,  8, 10, 13, 
    0,  8, 10, 14,  0,  8, 10, 15,  0,  8, 12, 14,  0,  9, 10, 12,  0,  9, 11, 14,  0,  9, 11, 15,  0,  9, 12, 14,  0,  9, 13, 15,  0, 10, 13, 15,  0, 11, 14, 15, 
    0, 12, 13, 14,  0, 13, 14, 15,  1,  2,  3, 12,  1,  2,  3, 13,  1,  2,  3, 14,  1,  2,  3, 15,  1,  2,  4, 11,  1,  2,  4, 13,  1,  2,  7,  8,  1,  2,  7, 14, 
    1,  2,  8, 10,  1,  2,  8, 13,  1,  2,  9, 11,  1,  2, 11, 14,  1,  2, 12, 13,  1,  2, 13, 14,  1,  2, 14, 15,  1,  3,  4,  9,  1,  3,  5, 11,  1,  3,  5, 12, 
    1,  3,  5, 13,  1,  3,  6, 12,  1,  3,  6, 13,  1,  3,  6, 14,  1,  3,  6, 15,  1,  3,  7,  9,  1,  3,  7, 15,  1,  3,  8,  9,  1,  3,  9, 10,  1,  3,  9, 12, 
    1,  3,  9, 13,  1,  3, 10, 11,  1,  3, 10, 14,  1,  3, 11, 15,  1,  4,  6, 12,  1,  4,  6, 13,  1,  4,  6, 14,  1,  4,  6, 15,  1,  4,  7,  8,  1,  4,  7,  9, 
    1,  4,  7, 10,  1,  4,  7, 11,  1,  4,  8, 14,  1,  4,  9, 11,  1,  4,  9, 15,  1,  4, 10, 13,  1,  4, 13, 14,  1,  5,  7, 13,  1,  5,  7, 14,  1,  5,  7, 15, 
    1,  5,  8, 11,  1,  5, 11, 13,  1,  5, 12, 14,  1,  5, 13, 15,  1,  6,  7, 13,  1,  6,  8, 11,  1,  6,  8, 13,  1,  6, 10, 12,  1,  6, 11, 13,  1,  6, 12, 13, 
    1,  7,  8,  9,  1,  7,  9, 11,  1,  7,  9, 13,  1,  7, 10, 13,  1,  7, 11, 14,  1,  8,  9, 11,  1,  8, 10, 11,  1,  8, 10, 12,  1,  8, 10, 13,  1,  8, 10, 14, 
    1,  8, 13, 14,  1,  9, 11, 13,  1,  9, 11, 14,  1,  9, 11, 15,  1,  9, 12, 14,  1,  9, 13, 15,  1, 10, 11, 13,  1, 10, 12, 13,  1, 10, 13, 15,  1, 12, 13, 14, 
    1, 13, 14, 15,  2,  3,  4, 10,  2,  3,  5, 14,  2,  3,  7, 12,  2,  3,  8, 10,  2,  3,  9, 11,  2,  3,  9, 14,  2,  3, 10, 12,  2,  3, 12, 13,  2,  3, 13, 14, 
    2,  3, 14, 15,  2,  4,  5, 14,  2,  4,  6, 12,  2,  4,  6, 13,  2,  4,  6, 14,  2,  4,  7,  8,  2,  4,  7,  9,  2,  4,  7, 10,  2,  4,  7, 11,  2,  4,  8, 10, 
    2,  4,  8, 13,  2,  4,  9, 14,  2,  4, 10, 11,  2,  4, 10, 14,  2,  5,  7, 12,  2,  5,  7, 13,  2,  5,  7, 14,  2,  5,  7, 15,  2,  5,  8, 11,  2,  5,  8, 14, 
    2,  5,  9, 15,  2,  5, 11, 14,  2,  5, 14, 15,  2,  6,  8, 11,  2,  6,  8, 14,  2,  6, 12, 14,  2,  6, 13, 15,  2,  7,  8, 10,  2,  7,  9, 14,  2,  7, 10, 12, 
    2,  7, 11, 13,  2,  7, 13, 14,  2,  8,  9, 11,  2,  8,  9, 14,  2,  8, 10, 11,  2,  8, 10, 12,  2,  8, 10, 13,  2,  8, 10, 14,  2,  9, 11, 13,  2,  9, 11, 14, 
    2,  9, 11, 15,  2,  9, 12, 14,  2,  9, 14, 15,  2, 10, 12, 14,  2, 10, 13, 15,  2, 11, 13, 14,  2, 12, 13, 14,  2, 13, 14, 15,  3,  4,  5, 11,  3,  4,  5, 12, 
    3,  4,  6, 11,  3,  4,  6, 12,  3,  4,  7,  8,  3,  4,  7,  9,  3,  4,  7, 10,  3,  4,  7, 11,  3,  4,  8, 12,  3,  4,  9, 10,  3,  4,  9, 12,  3,  5,  6, 15, 
    3,  5,  7, 12,  3,  5,  7, 13,  3,  5,  7, 14,  3,  5,  7, 15,  3,  5,  8, 13,  3,  5,  9, 11,  3,  5,  9, 14,  3,  5, 10, 12,  3,  5, 10, 15,  3,  5, 11, 15, 
    3,  5, 12, 13,  3,  6,  8, 11,  3,  6,  9, 15,  3,  6, 11, 12,  3,  6, 12, 14,  3,  7,  8, 11,  3,  7,  8, 12,  3,  7,  9, 15,  3,  7, 11, 12,  3,  7, 13, 15, 
    3,  8,  9, 11,  3,  8, 10, 11,  3,  8, 10, 12,  3,  8, 10, 13,  3,  8, 12, 13,  3,  9, 10, 15,  3,  9, 11, 12,  3,  9, 11, 13,  3,  9, 11, 14,  3,  9, 11, 15, 
    3,  9, 12, 14,  3, 10, 11, 12,  3, 10, 12, 14,  3, 10, 13, 15,  3, 11, 13, 15,  3, 12, 13, 14,  3, 13, 14, 15,  4,  5,  7, 12,  4,  5,  7, 13,  4,  5,  7, 14, 
    4,  5,  7, 15,  4,  5, 11, 13,  4,  5, 12, 14,  4,  5, 13, 15,  4,  6,  7, 12,  4,  6,  7, 13,  4,  6,  7, 14,  4,  6,  7, 15,  4,  6,  8, 14,  4,  6, 10, 12, 
    4,  6, 11, 14,  4,  6, 12, 13,  4,  6, 13, 14,  4,  6, 14, 15,  4,  7,  8, 11,  4,  7,  8, 12,  4,  7,  9, 12,  4,  7,  9, 13,  4,  7,  9, 14,  4,  7, 10, 13, 
    4,  7, 10, 14,  4,  7, 10, 15,  4,  7, 11, 15,  4,  8, 11, 12,  4,  8, 11, 13,  4,  8, 11, 14,  4,  8, 11, 15,  4,  8, 12, 15,  4,  9, 11, 12,  4,  9, 12, 15, 
    4, 10, 11, 12,  4, 10, 12, 14,  4, 11, 13, 14,  4, 12, 13, 15,  4, 12, 14, 15,  5,  6,  8, 15,  5,  6, 11, 12,  5,  6, 12, 14,  5,  6, 13, 15,  5,  7,  8, 13, 
    5,  7,  9, 15,  5,  7, 11, 13,  5,  7, 12, 13,  5,  7, 13, 14,  5,  7, 14, 15,  5,  8, 11, 12,  5,  8, 11, 13,  5,  8, 11, 14,  5,  8, 11, 15,  5,  8, 13, 15, 
    5,  9, 12, 15,  5, 10, 12, 15,  5, 11, 12, 13,  5, 11, 13, 15,  5, 12, 13, 15,  5, 12, 14, 15,  6,  7,  8, 14,  6,  7, 12, 14,  6,  7, 13, 15,  6,  8, 11, 12, 
    6,  8, 11, 13,  6,  8, 11, 14,  6,  8, 11, 15,  6,  8, 12, 14,  6,  8, 14, 15,  6,  9, 12, 15,  6, 10, 12, 15,  6, 11, 12, 14,  6, 12, 13, 15,  6, 12, 14, 15, 
    7,  8,  9, 15,  7,  8, 10, 15,  7,  8, 11, 12,  7,  8, 11, 13,  7,  8, 11, 14,  7,  8, 11, 15,  7,  8, 13, 14,  7,  9, 13, 15,  7, 10, 12, 15,  7, 11, 12, 15, 
    7, 12, 13, 15,  7, 12, 14, 15,  8, 11, 12, 15,  0,  1,  4, 11,  0,  1,  4, 14,  0,  1,  6,  8,  0,  1,  6, 14,  0,  1,  7, 10,  0,  1,  8, 13,  0,  1,  9, 12, 
    0,  1, 11, 15,  0,  2,  4,  7,  0,  2,  4,  9,  0,  2,  5, 11,  0,  2,  6,  9,  0,  2,  7, 11,  0,  3,  4,  6,  0,  3,  5,  7,  0,  4,  9, 11,  0,  4, 10, 13, 
    0,  4, 14, 15,  0,  5,  6, 13,  0,  5,  7,  9,  0,  5,  8, 14,  0,  5, 11, 14,  0,  5, 12, 13,  0,  6,  7,  9,  0,  6,  8,  9,  0,  6,  9, 11,  0,  6,  9, 13, 
    0,  6,  9, 14,  0,  7, 10, 11,  0,  8, 13, 14,  0, 10, 11, 14,  0, 10, 13, 14,  1,  2,  4, 10,  1,  2,  4, 12,  1,  2,  5, 15,  1,  2,  6, 12,  1,  2,  7,  9, 
    1,  2,  7, 15,  1,  2,  9, 14,  1,  2, 10, 13,  1,  3,  4,  7,  1,  3,  4,  8,  1,  3,  5, 10,  1,  3,  6,  8,  1,  3,  7, 10,  1,  4,  5, 15,  1,  4,  8, 10, 
    1,  4, 10, 11,  1,  4, 10, 14,  1,  4, 10, 15,  1,  4, 12, 13,  1,  5,  7,  8,  1,  5,  8, 14,  1,  5, 10, 12,  1,  5, 11, 14,  1,  6,  7,  8,  1,  6,  7, 14, 
    1,  6,  8, 10,  1,  6,  8, 12,  1,  6,  9, 15,  1,  6, 13, 14,  1,  7,  9, 10,  1,  7, 10, 14,  1,  7, 10, 15,  1,  8,  9, 14,  1,  9, 10, 12,  1,  9, 14, 15, 
    1, 11, 14, 15,  2,  3,  4,  9,  2,  3,  5, 11,  2,  3,  5, 13,  2,  3,  7,  8,  2,  3,  7, 13,  2,  3,  8, 12,  2,  3, 10, 15,  2,  3, 11, 14,  2,  4,  5, 11, 
    2,  4,  5, 13,  2,  4,  6, 11,  2,  4,  9, 10,  2,  4,  9, 12,  2,  4,  9, 13,  2,  5,  9, 11,  2,  5, 10, 12,  2,  5, 11, 15,  2,  5, 13, 14,  2,  6,  7, 12, 
    2,  6,  8, 13,  2,  6,  9, 15,  2,  6, 11, 13,  2,  7,  8,  9,  2,  7,  9, 11,  2,  7,  9, 12,  2,  7,  9, 13,  2,  7, 14, 15,  2,  8, 12, 13,  2,  9, 10, 15, 
    2, 10, 11, 13,  2, 10, 12, 13,  3,  4,  5, 10,  3,  4,  6, 10,  3,  4,  8,  9,  3,  5,  6, 14,  3,  5,  8, 10,  3,  5, 10, 11,  3,  5, 10, 13,  3,  5, 10, 14, 
    3,  6,  8, 13,  3,  6, 11, 13,  3,  6, 14, 15,  3,  7,  8, 10,  3,  7,  9, 14,  3,  7, 12, 13,  3,  8,  9, 13,  3,  9, 13, 14,  3, 11, 13, 14,  4,  5,  8, 15, 
    4,  5, 10, 12,  4,  5, 11, 14,  4,  6,  8, 11,  4,  6,  8, 13,  4,  6,  9, 15,  4,  6, 10, 13,  4,  6, 11, 15,  4,  7,  8, 10,  4,  7,  9, 11,  4,  8, 13, 15, 
    4,  9, 11, 13,  4, 10, 11, 13,  4, 10, 12, 13,  4, 10, 13, 15,  4, 11, 14, 15,  5,  6,  8, 14,  5,  6, 11, 13,  5,  7,  8, 11,  5,  7,  8, 12,  5,  7,  9, 14, 
    5,  7, 10, 12,  5,  7, 11, 14,  5,  8, 12, 14,  5,  8, 14, 15,  5,  9, 11, 12,  5, 10, 11, 12,  5, 10, 12, 14,  5, 11, 13, 14,  6,  7,  8, 13,  6,  7,  9, 15, 
    6,  7, 11, 12,  6,  8,  9, 15,  6,  8, 10, 15,  6,  8, 13, 14,  6,  9, 13, 15,  6, 11, 12, 13,  6, 11, 13, 15,  7,  8,  9, 14,  7,  8, 10, 14,  7,  8, 12, 13, 
    7,  9, 12, 14,  7,  9, 14, 15,  7, 11, 12, 14,  8, 10, 12, 15,  8, 11, 12, 14,  8, 11, 13, 15,  9, 11, 12, 15,  0,  1,  2,  8,  0,  1,  2,  9,  0,  1,  2, 10, 
    0,  1,  2, 11,  0,  1,  4,  7,  0,  1,  4, 10,  0,  1,  4, 13,  0,  1,  5, 12,  0,  1,  6,  9,  0,  1,  6, 15,  0,  1,  7, 11,  0,  1,  8,  9,  0,  1,  9, 10, 
    0,  1,  9, 14,  0,  1, 10, 11,  0,  1, 10, 14,  0,  2,  4,  6,  0,  2,  4,  8,  0,  2,  5,  7,  0,  2,  5,  8,  0,  2,  5,  9,  0,  2,  5, 10,  0,  2,  6, 10, 
    0,  2,  6, 11,  0,  3,  4,  5,  0,  3,  5,  6,  0,  3,  6,  7,  0,  4,  6,  8,  0,  4,  6,  9,  0,  4,  6, 10,  0,  4,  6, 11,  0,  4,  8, 10,  0,  4,  8, 14, 
    0,  4,  9, 15,  0,  4, 10, 11,  0,  4, 10, 14,  0,  4, 13, 14,  0,  5,  6,  8,  0,  5,  6, 14,  0,  5,  7, 10,  0,  5,  7, 11,  0,  5,  8, 10,  0,  5,  8, 13, 
    0,  5,  9, 11,  0,  5,  9, 12,  0,  5, 10, 13,  0,  5, 13, 14,  0,  6,  7, 10,  0,  6,  9, 10,  0,  6, 10, 14,  0,  6, 11, 15,  0,  8,  9, 10,  0,  8,  9, 14, 
    0,  9, 10, 11,  0,  9, 10, 13,  0,  9, 12, 13,  0,  9, 14, 15,  1,  2,  3,  8,  1,  2,  3,  9,  1,  2,  3, 10,  1,  2,  3, 11,  1,  2,  4,  7,  1,  2,  4,  9, 
    1,  2,  5, 11,  1,  2,  5, 14,  1,  2,  6,  8,  1,  2,  6, 13,  1,  2,  7, 10,  1,  2,  8,  9,  1,  2,  8, 12,  1,  2,  9, 10,  1,  2,  9, 12,  1,  2, 10, 11, 
    1,  2, 10, 15,  1,  2, 11, 15,  1,  3,  4,  6,  1,  3,  5,  7,  1,  3,  5,  8,  1,  3,  5,  9,  1,  3,  6,  9,  1,  3,  6, 10,  1,  3,  6, 11,  1,  3,  7, 11, 
    1,  4,  5, 11,  1,  4,  5, 14,  1,  4,  6,  8,  1,  4,  6,  9,  1,  4,  6, 10,  1,  4,  6, 11,  1,  4,  8, 13,  1,  4,  9, 10,  1,  4,  9, 12,  1,  4,  9, 14, 
    1,  5,  6, 12,  1,  5,  7,  9,  1,  5,  7, 10,  1,  5,  7, 11,  1,  5,  8, 10,  1,  5,  9, 11,  1,  5,  9, 15,  1,  5, 11, 15,  1,  5, 14, 15,  1,  6,  7,  9, 
    1,  6,  7, 15,  1,  6,  8,  9,  1,  6,  9, 11,  1,  6,  9, 12,  1,  6,  9, 14,  1,  6, 10, 13,  1,  6, 11, 14,  1,  6, 14, 15,  1,  7, 10, 11,  1,  7, 11, 15, 
    1,  8,  9, 10,  1,  8, 12, 13,  1,  9, 10, 11,  1,  9, 10, 15,  1, 10, 11, 14,  1, 10, 13, 14,  2,  3,  4,  7,  2,  3,  4,  8,  2,  3,  5, 10,  2,  3,  5, 12, 
    2,  3,  6, 15,  2,  3,  7,  9,  2,  3,  7, 14,  2,  3,  8,  9,  2,  3,  9, 10,  2,  3,  9, 13,  2,  3, 10, 11,  2,  3, 10, 13,  2,  4,  5, 10,  2,  4,  5, 12, 
    2,  4,  6,  8,  2,  4,  6,  9,  2,  4,  6, 10,  2,  4,  8,  9,  2,  4,  8, 12,  2,  5,  6, 15,  2,  5,  7,  8,  2,  5,  7,  9,  2,  5,  7, 10,  2,  5,  7, 11, 
    2,  5,  8, 10,  2,  5,  8, 13,  2,  5,  9, 14,  2,  5, 10, 11,  2,  5, 10, 13,  2,  5, 10, 15,  2,  5, 12, 13,  2,  6,  7,  8,  2,  6,  7, 13,  2,  6,  8, 10, 
    2,  6,  8, 12,  2,  6,  9, 11,  2,  6, 10, 12,  2,  6, 12, 13,  2,  7,  9, 10,  2,  7, 10, 13,  2,  7, 10, 15,  2,  7, 11, 14,  2,  8,  9, 10,  2,  8,  9, 13, 
    2,  9, 10, 11,  2,  9, 10, 12,  2,  9, 13, 14,  2, 11, 14, 15,  3,  4,  5,  9,  3,  4,  6,  8,  3,  4,  6,  9,  3,  5,  6, 11,  3,  5,  6, 13,  3,  5,  7,  8, 
    3,  5,  7,  9,  3,  5,  7, 10,  3,  5,  7, 11,  3,  5,  8, 12,  3,  5,  9, 10,  3,  5,  9, 13,  3,  6,  8, 10,  3,  6,  9, 11,  3,  6,  9, 14,  3,  6, 10, 15, 
    3,  6, 11, 14,  3,  6, 13, 14,  3,  7,  8,  9,  3,  7,  9, 11,  3,  7,  9, 13,  3,  7, 10, 12,  3,  7, 11, 13,  3,  7, 13, 14,  3,  8,  9, 10,  3,  9, 10, 11, 
    3,  9, 10, 14,  3, 10, 11, 13,  3, 10, 12, 13,  3, 10, 14, 15,  4,  5,  6, 12,  4,  5,  6, 13,  4,  5,  6, 14,  4,  5,  6, 15,  4,  5,  8, 11,  4,  5,  8, 14, 
    4,  5, 10, 13,  4,  5, 11, 15,  4,  5, 12, 13,  4,  5, 13, 14,  4,  5, 14, 15,  4,  6,  8, 10,  4,  6,  8, 12,  4,  6,  9, 11,  4,  6,  9, 12,  4,  6,  9, 13, 
    4,  6,  9, 14,  4,  6, 10, 14,  4,  6, 10, 15,  4,  7,  8,  9,  4,  7,  9, 10,  4,  7, 10, 11,  4,  8, 10, 12,  4,  8, 10, 13,  4,  8, 10, 14,  4,  8, 10, 15, 
    4,  8, 12, 14,  4,  8, 14, 15,  4,  9, 10, 12,  4,  9, 11, 14,  4,  9, 11, 15,  4,  9, 12, 14,  4,  9, 13, 15,  4, 10, 11, 14,  4, 10, 13, 14,  4, 12, 13, 14, 
    4, 13, 14, 15,  5,  6,  7, 12,  5,  6,  7, 13,  5,  6,  7, 14,  5,  6,  7, 15,  5,  6,  8, 11,  5,  6,  8, 13,  5,  6,  9, 15,  5,  6, 10, 12,  5,  6, 11, 14, 
    5,  6, 12, 13,  5,  6, 13, 14,  5,  6, 14, 15,  5,  7,  8, 10,  5,  7,  9, 11,  5,  7,  9, 12,  5,  7,  9, 13,  5,  7, 10, 13,  5,  7, 10, 14,  5,  7, 10, 15, 
    5,  7, 11, 15,  5,  8,  9, 15,  5,  8, 10, 12,  5,  8, 10, 13,  5,  8, 10, 14,  5,  8, 10, 15,  5,  8, 13, 14,  5,  9, 11, 13,  5,  9, 11, 14,  5,  9, 11, 15, 
    5,  9, 12, 14,  5,  9, 13, 15,  5, 10, 11, 13,  5, 10, 12, 13,  5, 10, 13, 15,  5, 11, 14, 15,  5, 12, 13, 14,  5, 13, 14, 15,  6,  7,  8, 11,  6,  7,  8, 12, 
    6,  7,  9, 14,  6,  7, 11, 13,  6,  7, 12, 13,  6,  7, 13, 14,  6,  7, 14, 15,  6,  8,  9, 14,  6,  8, 10, 12,  6,  8, 10, 13,  6,  8, 10, 14,  6,  8, 12, 13, 
    6,  9, 11, 12,  6,  9, 11, 13,  6,  9, 11, 14,  6,  9, 11, 15,  6,  9, 12, 14,  6,  9, 14, 15,  6, 10, 11, 12,  6, 10, 12, 14,  6, 10, 13, 15,  6, 11, 13, 14, 
    6, 12, 13, 14,  6, 13, 14, 15,  7,  8,  9, 13,  7,  8, 10, 12,  7,  8, 10, 13,  7,  9, 10, 15,  7,  9, 11, 12,  7,  9, 11, 13,  7,  9, 11, 14,  7,  9, 11, 15, 
    7,  9, 13, 14,  7, 10, 12, 14,  7, 10, 13, 15,  7, 11, 12, 13,  7, 11, 13, 15,  7, 12, 13, 14,  7, 13, 14, 15,  8,  9, 12, 15,  8, 10, 12, 14,  8, 10, 13, 15, 
    8, 11, 12, 13,  8, 11, 13, 14,  8, 11, 14, 15,  9, 10, 12, 15,  9, 11, 12, 14,  9, 11, 13, 15, 10, 11, 12, 15,  0,  1,  3,  4,  0,  1,  3,  5,  0,  1,  3,  6, 
    0,  1,  3,  7,  0,  1,  4,  6,  0,  1,  4,  9,  0,  1,  4, 12,  0,  1,  5,  7,  0,  1,  5,  8,  0,  1,  5, 11,  0,  1,  5, 13,  0,  1,  5, 14,  0,  1,  5, 15, 
    0,  1,  6, 10,  0,  1,  8, 12,  0,  1,  9, 13,  0,  1, 10, 15,  0,  2,  3,  4,  0,  2,  3,  5,  0,  2,  3,  6,  0,  2,  3,  7,  0,  2,  4,  5,  0,  2,  5,  6, 
    0,  2,  6,  7,  0,  4,  5,  7,  0,  4,  5, 11,  0,  4,  5, 12,  0,  4,  5, 13,  0,  4,  5, 14,  0,  4,  5, 15,  0,  4,  6,  7,  0,  4,  9, 10,  0,  4,  9, 12, 
    0,  4, 10, 15,  0,  4, 12, 13,  0,  5,  6,  9,  0,  5,  6, 15,  0,  5,  8,  9,  0,  5,  8, 12,  0,  5,  9, 15,  0,  5, 11, 15,  0,  5, 14, 15,  0,  6,  7, 11, 
    0,  6, 10, 11,  0,  6, 10, 15,  0,  8,  9, 12,  0,  8,  9, 13,  0,  8, 12, 13,  0,  9, 10, 14,  0,  9, 10, 15,  0,  9, 13, 14,  0, 10, 11, 15,  0, 10, 14, 15, 
    1,  2,  4,  6,  1,  2,  4,  8,  1,  2,  5,  7,  1,  2,  5, 10,  1,  2,  5, 12,  1,  2,  5, 13,  1,  2,  6,  9,  1,  2,  6, 14,  1,  2,  6, 15,  1,  2,  7, 11, 
    1,  2,  9, 13,  1,  2, 10, 14,  1,  3,  4,  5,  1,  3,  5,  6,  1,  3,  6,  7,  1,  4,  5,  7,  1,  4,  5, 10,  1,  4,  5, 12,  1,  4,  5, 13,  1,  4,  6,  7, 
    1,  4,  8,  9,  1,  4,  9, 13,  1,  5,  6,  8,  1,  5,  6, 13,  1,  5,  6, 14,  1,  5,  6, 15,  1,  5,  8, 13,  1,  5, 10, 11,  1,  5, 10, 13,  1,  5, 12, 13, 
    1,  5, 13, 14,  1,  6,  7, 10,  1,  6,  9, 10,  1,  6,  9, 13,  1,  8,  9, 12,  1,  8,  9, 13,  1,  9, 10, 13,  1,  9, 10, 14,  1,  9, 12, 13,  1,  9, 13, 14, 
    1, 10, 11, 15,  1, 10, 14, 15,  2,  3,  4,  6,  2,  3,  5,  7,  2,  3,  5,  9,  2,  3,  6,  8,  2,  3,  6, 11,  2,  3,  6, 12,  2,  3,  6, 13,  2,  3,  6, 14, 
    2,  3,  7, 10,  2,  3,  7, 15,  2,  3,  9, 12,  2,  3, 10, 14,  2,  3, 11, 15,  2,  4,  5,  7,  2,  4,  5,  9,  2,  4,  6,  7,  2,  5,  6, 11,  2,  5,  6, 12, 
    2,  5,  6, 13,  2,  5,  6, 14,  2,  5,  9, 10,  2,  5, 10, 14,  2,  6,  7,  9,  2,  6,  7, 14,  2,  6,  7, 15,  2,  6,  8,  9,  2,  6,  9, 14,  2,  6, 11, 14, 
    2,  6, 13, 14,  2,  6, 14, 15,  2,  7, 10, 11,  2,  7, 10, 14,  2,  8,  9, 12,  2,  9, 10, 13,  2,  9, 10, 14,  2,  9, 12, 13,  2, 10, 11, 14,  2, 10, 11, 15, 
    2, 10, 13, 14,  2, 10, 14, 15,  3,  4,  5,  7,  3,  4,  5,  8,  3,  4,  6,  7,  3,  5,  6, 10,  3,  5,  6, 12,  3,  5,  8,  9,  3,  5,  9, 12,  3,  6,  7,  8, 
    3,  6,  7, 12,  3,  6,  7, 13,  3,  6,  7, 14,  3,  6,  7, 15,  3,  6,  8, 12,  3,  6, 10, 11,  3,  6, 10, 12,  3,  6, 11, 15,  3,  6, 12, 13,  3,  7,  9, 10, 
    3,  7,  9, 12,  3,  7, 10, 15,  3,  7, 14, 15,  3,  8,  9, 12,  3,  9, 10, 12,  3,  9, 10, 13,  3,  9, 12, 13,  3, 10, 11, 14,  3, 10, 11, 15,  3, 10, 13, 14, 
    3, 11, 14, 15,  4,  5,  7,  8,  4,  5,  7,  9,  4,  5,  7, 10,  4,  5,  7, 11,  4,  5,  8, 10,  4,  5,  8, 13,  4,  5,  9, 11,  4,  5,  9, 12,  4,  5,  9, 15, 
    4,  5, 10, 14,  4,  6,  7,  8,  4,  6,  7,  9,  4,  6,  7, 10,  4,  6,  7, 11,  4,  6,  8,  9,  4,  6,  9, 10,  4,  6, 10, 11,  4,  8,  9, 11,  4,  8,  9, 15, 
    4,  8, 10, 11,  4,  8, 13, 14,  4,  9, 10, 13,  4,  9, 12, 13,  4, 10, 11, 15,  4, 10, 14, 15,  5,  6,  8, 10,  5,  6,  8, 12,  5,  6,  9, 11,  5,  6,  9, 14, 
    5,  6, 10, 13,  5,  6, 11, 15,  5,  7,  8,  9,  5,  7,  9, 10,  5,  7, 10, 11,  5,  8,  9, 11,  5,  8,  9, 14,  5,  8, 10, 11,  5,  8, 12, 13,  5,  9, 10, 12, 
    5,  9, 14, 15,  5, 10, 11, 14,  5, 10, 13, 14,  6,  7,  8, 10,  6,  7,  9, 11,  6,  7,  9, 13,  6,  7, 10, 12,  6,  7, 10, 15,  6,  7, 11, 14,  6,  8,  9, 11, 
    6,  8,  9, 13,  6,  8, 10, 11,  6,  9, 10, 15,  6,  9, 13, 14,  6, 10, 11, 13,  6, 10, 12, 13,  6, 11, 14, 15,  7,  8,  9, 11,  7,  8,  9, 12,  7,  8, 10, 11, 
    7,  9, 10, 14,  7,  9, 12, 13,  7, 10, 11, 12,  7, 10, 14, 15,  7, 11, 13, 14,  8,  9, 11, 12,  8,  9, 11, 13,  8,  9, 11, 14,  8,  9, 11, 15,  8,  9, 12, 14, 
    8,  9, 13, 15,  8, 10, 11, 12,  8, 10, 11, 13,  8, 10, 11, 14,  8, 10, 11, 15,  8, 10, 12, 13,  8, 10, 13, 14,  8, 10, 14, 15,  8, 12, 13, 15,  8, 12, 14, 15, 
    9, 10, 12, 14,  9, 10, 13, 15,  9, 11, 12, 13,  9, 11, 13, 14,  9, 11, 14, 15,  9, 12, 13, 15,  9, 12, 14, 15, 10, 11, 12, 14, 10, 11, 13, 15, 10, 12, 13, 15, 
    10, 12, 14, 15, 11, 12, 13, 15, 11, 12, 14, 15,  0,  1,  2,  4,  0,  1,  2,  5,  0,  1,  2,  6,  0,  1,  2,  7,  0,  1,  4,  5,  0,  1,  4,  8,  0,  1,  5,  6, 
    0,  1,  5,  9,  0,  1,  5, 10,  0,  1,  6,  7,  0,  1,  6, 11,  0,  4,  5,  6,  0,  4,  5,  8,  0,  4,  5,  9,  0,  4,  5, 10,  0,  4,  8,  9,  0,  4,  8, 13, 
    0,  4,  9, 13,  0,  4,  9, 14,  0,  5,  6,  7,  0,  5,  6, 10,  0,  5,  6, 11,  0,  5,  9, 10,  0,  5,  9, 13,  0,  5,  9, 14,  0,  5, 10, 11,  0,  5, 10, 14, 
    1,  2,  3,  4,  1,  2,  3,  5,  1,  2,  3,  6,  1,  2,  3,  7,  1,  2,  4,  5,  1,  2,  5,  6,  1,  2,  5,  8,  1,  2,  5,  9,  1,  2,  6,  7,  1,  2,  6, 10, 
    1,  2,  6, 11,  1,  4,  5,  6,  1,  4,  5,  8,  1,  4,  5,  9,  1,  4,  8, 12,  1,  5,  6,  7,  1,  5,  6,  9,  1,  5,  6, 10,  1,  5,  6, 11,  1,  5,  8,  9, 
    1,  5,  8, 12,  1,  5,  9, 10,  1,  5,  9, 12,  1,  5,  9, 14,  1,  5, 10, 14,  1,  5, 10, 15,  1,  6,  7, 11,  1,  6, 10, 11,  1,  6, 10, 14,  1,  6, 10, 15, 
    1,  6, 11, 15,  2,  3,  4,  5,  2,  3,  5,  6,  2,  3,  5,  8,  2,  3,  6,  7,  2,  3,  6,  9,  2,  3,  6, 10,  2,  3,  7, 11,  2,  4,  5,  6,  2,  4,  5,  8, 
    2,  5,  6,  7,  2,  5,  6,  8,  2,  5,  6,  9,  2,  5,  6, 10,  2,  5,  8,  9,  2,  5,  8, 12,  2,  5,  9, 12,  2,  5,  9, 13,  2,  6,  7, 10,  2,  6,  7, 11, 
    2,  6,  9, 10,  2,  6,  9, 12,  2,  6,  9, 13,  2,  6, 10, 11,  2,  6, 10, 13,  2,  6, 10, 15,  2,  6, 11, 15,  2,  7, 11, 15,  3,  4,  5,  6,  3,  5,  6,  7, 
    3,  5,  6,  8,  3,  5,  6,  9,  3,  6,  7,  9,  3,  6,  7, 10,  3,  6,  7, 11,  3,  6,  8,  9,  3,  6,  9, 10,  3,  6,  9, 13,  3,  6, 10, 13,  3,  6, 10, 14, 
    3,  7, 10, 11,  3,  7, 10, 13,  3,  7, 10, 14,  3,  7, 11, 14,  4,  5,  6,  8,  4,  5,  6,  9,  4,  5,  6, 10,  4,  5,  6, 11,  4,  5,  8,  9,  4,  5,  8, 12, 
    4,  5,  9, 10,  4,  5,  9, 13,  4,  5,  9, 14,  4,  5, 10, 11,  4,  5, 10, 15,  4,  8,  9, 10,  4,  8,  9, 12,  4,  8,  9, 13,  4,  8,  9, 14,  4,  8, 12, 13, 
    4,  9, 10, 11,  4,  9, 10, 14,  4,  9, 10, 15,  4,  9, 13, 14,  4,  9, 14, 15,  5,  6,  7,  8,  5,  6,  7,  9,  5,  6,  7, 10,  5,  6,  7, 11,  5,  6,  8,  9, 
    5,  6,  9, 10,  5,  6,  9, 12,  5,  6,  9, 13,  5,  6, 10, 11,  5,  6, 10, 14,  5,  6, 10, 15,  5,  8,  9, 10,  5,  8,  9, 12,  5,  8,  9, 13,  5,  9, 10, 11, 
    5,  9, 10, 13,  5,  9, 10, 14,  5,  9, 10, 15,  5,  9, 12, 13,  5,  9, 13, 14,  5, 10, 11, 15,  5, 10, 14, 15,  6,  7,  8,  9,  6,  7,  9, 10,  6,  7,  9, 12, 
    6,  7, 10, 11,  6,  7, 10, 13,  6,  7, 10, 14,  6,  7, 11, 15,  6,  8,  9, 10,  6,  8,  9, 12,  6,  9, 10, 11,  6,  9, 10, 12,  6,  9, 10, 13,  6,  9, 10, 14, 
    6,  9, 12, 13,  6, 10, 11, 14,  6, 10, 11, 15,  6, 10, 13, 14,  6, 10, 14, 15,  7,  8,  9, 10,  7,  9, 10, 11,  7,  9, 10, 12,  7,  9, 10, 13,  7, 10, 11, 13, 
    7, 10, 11, 14,  7, 10, 11, 15,  7, 10, 12, 13,  7, 10, 13, 14,  7, 11, 14, 15,  8,  9, 10, 12,  8,  9, 10, 13,  8,  9, 10, 14,  8,  9, 10, 15,  8,  9, 12, 13, 
    8,  9, 13, 14,  8,  9, 14, 15,  8, 12, 13, 14,  8, 13, 14, 15,  9, 10, 11, 12,  9, 10, 11, 13,  9, 10, 11, 14,  9, 10, 11, 15,  9, 10, 12, 13,  9, 10, 13, 14, 
    9, 10, 14, 15,  9, 12, 13, 14,  9, 13, 14, 15, 10, 11, 12, 13, 10, 11, 13, 14, 10, 11, 14, 15, 10, 12, 13, 14, 10, 13, 14, 15, 11, 12, 13, 14, 11, 13, 14, 15
};


//////////////////////////////////////////////////////////////////////////
////---- NoiseStdTable: Revised by yousf 20160508
#if USE_PIXEL_NOISE_STD_TH == 1 // 1-use BayerPixel Noise Std Threshold
RK_U8 NoiseStdTable[NOISE_STD_TALBE_LEN] = {
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
	4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7,
	7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9,
	9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,10,10,10,10,10,10,10,10,10,10,10,
	10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,
	11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,
	13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,
	14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,
	14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,
	16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,
	17,17,17,17,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
	18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,
	19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
	19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,
	20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
	20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
	20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,
	21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,
	21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
	22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,
	22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
	24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
	24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,25,25,25,25,
	25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25
};
#endif


//////////////////////////////////////////////////////////////////////////
////---- MotionDetectTable: Revised by yousf 20160604
#if USE_MOTION_DETECT == 1
RK_U8 MotionDetectTable[MOTION_DETECT_TALBE_LEN] = {
	4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,10,
	10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,
	12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,
	14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,
	15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,
	17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,18,18,18,18,18,18,18,18,18,
	18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,19,19,19,19,19,19,19,19,19,19,19,19,19,
	19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,
	20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,
	21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,22,22,22,22,22,22,22,22,22,22,22,22,22,
	22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,23,23,23,23,23,23,23,23,23,
	23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,24,24,24,
	24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,24,
	24,24,24,24,24,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,
	25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,
	26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,26,27,27,27,27,27,
	27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,
	27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,
	28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,
	29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,
	29,29,29,29,29,29,29,29,29,29,29,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,
	30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,31,
	31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,
	31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,32,32,32,32,32,32,32,32,32,32,32,
	32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,
	32,32,32,32,32,32,32,32,32,32,32,32,32,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,
	33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,33,
	33,33,33,33,33,33,33,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
	34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,34,
	34,34,34,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,
	35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,35,
	35,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36,36
};

// 0606
RK_F32 MotionDetectTable2[MOTION_DETECT_TALBE_LEN] = {
	1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,
	1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,
	1.000000,1.500000,1.707107,1.866025,2.000000,2.118034,2.224745,2.322876,2.414214,2.500000,2.581139,2.658312,2.732051,2.802776,2.870829,2.936492,3.000000,3.061553,3.121320,3.179449,3.236068,3.291288,3.345208,3.397916,3.449490,3.500000,3.549510,3.598076,3.645751,3.692582,3.738613,3.783882,
	3.828427,3.872281,3.915476,3.958040,4.000000,4.041381,4.082207,4.122499,4.162278,4.201562,4.240370,4.278719,4.316625,4.354102,4.391165,4.427827,4.464102,4.500000,4.535534,4.570714,4.605551,4.640055,4.674235,4.708099,4.741657,4.774917,4.807887,4.840573,4.872983,4.905125,4.937004,4.968627,
	5.000000,5.031129,5.062019,5.092676,5.123106,5.153312,5.183300,5.213075,5.242641,5.272002,5.301163,5.330127,5.358899,5.387482,5.415880,5.444097,5.472136,5.500000,5.527693,5.555217,5.582576,5.609772,5.636809,5.663690,5.690416,5.716991,5.743416,5.769696,5.795832,5.821825,5.847680,5.873397,
	5.898979,5.924429,5.949747,5.974937,6.000000,6.024938,6.049752,6.074446,6.099020,6.123475,6.147815,6.172040,6.196152,6.220153,6.244044,6.267827,6.291503,6.315073,6.338539,6.361903,6.385165,6.408327,6.431390,6.454356,6.477226,6.500000,6.522681,6.545268,6.567764,6.590170,6.612486,6.634714,
	6.656854,6.678908,6.700877,6.722762,6.744563,6.766281,6.787918,6.809475,6.830952,6.852350,6.873670,6.894913,6.916080,6.937171,6.958188,6.979130,7.000000,7.020797,7.041523,7.062178,7.082763,7.103278,7.123724,7.144103,7.164414,7.184658,7.204837,7.224950,7.244998,7.264982,7.284903,7.304760,
	7.324555,7.344289,7.363961,7.383573,7.403124,7.422616,7.442049,7.461424,7.480741,7.500000,7.519202,7.538348,7.557439,7.576473,7.595453,7.614378,7.633250,7.652067,7.670832,7.689544,7.708204,7.726812,7.745369,7.763875,7.782330,7.800735,7.819091,7.837397,7.855655,7.873864,7.892024,7.910137,
	7.928203,7.946222,7.964194,7.982120,8.000000,8.017834,8.035624,8.053368,8.071068,8.088723,8.106335,8.123903,8.141428,8.158911,8.176350,8.193747,8.211103,8.228416,8.245688,8.262920,8.280110,8.297260,8.314369,8.331439,8.348469,8.365460,8.382412,8.399324,8.416198,8.433034,8.449832,8.466592,
	8.483315,8.500000,8.516648,8.533260,8.549834,8.566373,8.582875,8.599342,8.615773,8.632169,8.648529,8.664855,8.681146,8.697402,8.713624,8.729812,8.745967,8.762087,8.778175,8.794229,8.810250,8.826238,8.842194,8.858117,8.874008,8.889867,8.905694,8.921490,8.937254,8.952987,8.968689,8.984360,
	9.000000,9.015610,9.031189,9.046738,9.062258,9.077747,9.093207,9.108637,9.124038,9.139410,9.154753,9.170067,9.185353,9.200610,9.215838,9.231039,9.246211,9.261356,9.276473,9.291562,9.306624,9.321658,9.336666,9.351647,9.366600,9.381527,9.396428,9.411302,9.426150,9.440972,9.455767,9.470537,
	9.485281,9.500000,9.514693,9.529361,9.544004,9.558621,9.573214,9.587782,9.602325,9.616844,9.631338,9.645808,9.660254,9.674676,9.689074,9.703448,9.717798,9.732125,9.746428,9.760708,9.774964,9.789198,9.803408,9.817596,9.831761,9.845903,9.860023,9.874120,9.888194,9.902247,9.916277,9.930286,
	9.944272,9.958236,9.972179,9.986100,10.000000,10.013878,10.027735,10.041571,10.055385,10.069179,10.082951,10.096703,10.110434,10.124144,10.137833,10.151503,10.165151,10.178780,10.192388,10.205976,10.219544,10.233093,10.246621,10.260130,10.273618,10.287088,10.300538,10.313968,10.327379,10.340771,10.354143,10.367497,
	10.380832,10.394147,10.407444,10.420722,10.433981,10.447222,10.460444,10.473648,10.486833,10.500000,10.513149,10.526279,10.539392,10.552487,10.565563,10.578622,10.591663,10.604686,10.617692,10.630680,10.643651,10.656604,10.669540,10.682458,10.695360,10.708244,10.721111,10.733961,10.746794,10.759611,10.772410,10.785193,
	10.797959,10.810708,10.823441,10.836158,10.848858,10.861541,10.874209,10.886860,10.899495,10.912114,10.924717,10.937303,10.949874,10.962429,10.974969,10.987492,11.000000,11.012492,11.024969,11.037430,11.049876,11.062306,11.074721,11.087121,11.099505,11.111874,11.124228,11.136567,11.148892,11.161201,11.173495,11.185774,
	11.198039,11.210289,11.222524,11.234745,11.246951,11.259142,11.271319,11.283482,11.295630,11.307764,11.319884,11.331989,11.344080,11.356158,11.368221,11.380270,11.392305,11.404326,11.416333,11.428327,11.440307,11.452272,11.464225,11.476163,11.488088,11.500000,11.511898,11.523783,11.535654,11.547512,11.559356,11.571187,
	11.583005,11.594810,11.606602,11.618380,11.630146,11.641898,11.653638,11.665365,11.677078,11.688779,11.700467,11.712143,11.723805,11.735455,11.747093,11.758717,11.770330,11.781929,11.793517,11.805091,11.816654,11.828204,11.839742,11.851267,11.862780,11.874282,11.885771,11.897247,11.908712,11.920165,11.931606,11.943034,
	11.954451,11.965856,11.977249,11.988630,12.000000,12.011358,12.022704,12.034038,12.045361,12.056672,12.067972,12.079260,12.090537,12.101802,12.113055,12.124298,12.135529,12.146748,12.157957,12.169154,12.180340,12.191515,12.202678,12.213831,12.224972,12.236103,12.247222,12.258330,12.269428,12.280514,12.291590,12.302655,
	12.313708,12.324752,12.335784,12.346806,12.357817,12.368817,12.379807,12.390786,12.401754,12.412712,12.423660,12.434597,12.445523,12.456439,12.467345,12.478240,12.489125,12.500000,12.510864,12.521719,12.532563,12.543396,12.554220,12.565034,12.575837,12.586630,12.597414,12.608187,12.618950,12.629703,12.640447,12.651180,
	12.661904,12.672618,12.683321,12.694016,12.704700,12.715375,12.726039,12.736695,12.747340,12.757976,12.768602,12.779219,12.789826,12.800424,12.811012,12.821590,12.832160,12.842719,12.853270,12.863811,12.874342,12.884864,12.895377,12.905881,12.916375,12.926860,12.937336,12.947803,12.958261,12.968709,12.979149,12.989579,
	13.000000,13.010412,13.020815,13.031209,13.041595,13.051971,13.062338,13.072696,13.083046,13.093387,13.103718,13.114041,13.124356,13.134661,13.144958,13.155246,13.165525,13.175796,13.186058,13.196311,13.206556,13.216792,13.227019,13.237238,13.247449,13.257651,13.267844,13.278029,13.288206,13.298374,13.308534,13.318685,
	13.328828,13.338963,13.349089,13.359207,13.369317,13.379418,13.389512,13.399597,13.409674,13.419742,13.429803,13.439855,13.449900,13.459936,13.469964,13.479984,13.489996,13.500000,13.509996,13.519984,13.529964,13.539936,13.549900,13.559857,13.569805,13.579746,13.589678,13.599603,13.609520,13.619429,13.629331,13.639225,
	13.649111,13.658989,13.668859,13.678722,13.688578,13.698425,13.708265,13.718097,13.727922,13.737739,13.747549,13.757351,13.767145,13.776932,13.786712,13.796484,13.806248,13.816006,13.825755,13.835498,13.845233,13.854960,13.864680,13.874393,13.884099,13.893797,13.903488,13.913172,13.922848,13.932517,13.942179,13.951834,
	13.961481,13.971122,13.980755,13.990381,14.000000,14.009612,14.019217,14.028814,14.038405,14.047988,14.057565,14.067134,14.076697,14.086252,14.095801,14.105342,14.114877,14.124405,14.133926,14.143439,14.152946,14.162447,14.171940,14.181426,14.190906,14.200379,14.209845,14.219304,14.228757,14.238202,14.247641,14.257074,
	14.266499,14.275918,14.285330,14.294736,14.304135,14.313527,14.322913,14.332292,14.341664,14.351030,14.360389,14.369742,14.379088,14.388428,14.397761,14.407088,14.416408,14.425722,14.435029,14.444330,14.453624,14.462912,14.472194,14.481469,14.490738,14.500000,14.509256,14.518506,14.527749,14.536986,14.546217,14.555442,
	14.564660,14.573872,14.583078,14.592277,14.601471,14.610658,14.619838,14.629013,14.638182,14.647344,14.656500,14.665650,14.674794,14.683932,14.693064,14.702190,14.711309,14.720423,14.729530,14.738632,14.747727,14.756816,14.765900,14.774977,14.784049,14.793114,14.802174,14.811227,14.820275,14.829317,14.838353,14.847382,
	14.856406,14.865425,14.874437,14.883443,14.892444,14.901439,14.910428,14.919411,14.928388,14.937360,14.946326,14.955286,14.964240,14.973189,14.982131,14.991069,15.000000,15.008926,15.017846,15.026760,15.035669,15.044572,15.053469,15.062361,15.071247,15.080128,15.089003,15.097872,15.106736,15.115594,15.124447,15.133294,
	15.142136,15.150972,15.159802,15.168627,15.177447,15.186261,15.195070,15.203873,15.212670,15.221463,15.230249,15.239031,15.247807,15.256577,15.265343,15.274102,15.282857,15.291606,15.300350,15.309088,15.317821,15.326549,15.335271,15.343988,15.352700,15.361407,15.370108,15.378804,15.387495,15.396180,15.404860,15.413535,
	15.422205,15.430870,15.439529,15.448183,15.456832,15.465476,15.474115,15.482748,15.491377,15.500000,15.508618,15.517231,15.525839,15.534442,15.543040,15.551632,15.560220,15.568802,15.577380,15.585952,15.594520,15.603082,15.611639,15.620192,15.628739,15.637281,15.645819,15.654351,15.662878,15.671401,15.679918,15.688431,
	15.696938,15.705441,15.713939,15.722432,15.730920,15.739403,15.747881,15.756355,15.764823,15.773287,15.781745,15.790199,15.798649,15.807093,15.815532,15.823967,15.832397,15.840822,15.849242,15.857658,15.866069,15.874475,15.882876,15.891273,15.899664,15.908052,15.916434,15.924812,15.933185,15.941553,15.949916,15.958275,
	15.966630,15.974979,15.983324,15.991664,16.000000,16.008331,16.016657,16.024979,16.033296,16.041609,16.049917,16.058220,16.066519,16.074813,16.083103,16.091388,16.099669,16.107945,16.116216,16.124483,16.132746,16.141004,16.149257,16.157506,16.165751,16.173991,16.182226,16.190458,16.198684,16.206906,16.215124,16.223337,
	16.231546,16.239751,16.247951,16.256146,16.264338,16.272524,16.280707,16.288885,16.297059,16.305228,16.313393,16.321553,16.329710,16.337862,16.346009,16.354153,16.362291,16.370426,16.378556,16.386683,16.394804,16.402922,16.411035,16.419144,16.427249,16.435349,16.443445,16.451537,16.459625,16.467708,16.475788,16.483863
};

// Y = 0:1023;A = 1+0.25*(Y-64).^0.6; A(1:64)=1; figure,hold on, plot(Y,A, 'r')
RK_F32 MotionDetectTable3[MOTION_DETECT_TALBE_LEN] = {
	1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,
	1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,
	1.000000,1.250000,1.378929,1.483296,1.574349,1.656632,1.732539,1.803524,1.870551,1.934298,1.995268,2.053842,2.110322,2.164947,2.217915,2.269389,2.319508,2.368388,2.416131,2.462824,2.508544,2.553358,2.597326,2.640502,2.682933,2.724662,2.765729,2.806169,2.846013,2.885293,2.924034,2.962262,
	3.000000,3.037269,3.074089,3.110478,3.146454,3.182032,3.217227,3.252054,3.286525,3.320654,3.354451,3.387927,3.421094,3.453960,3.486536,3.518829,3.550849,3.582603,3.614099,3.645344,3.676344,3.707108,3.737640,3.767946,3.798033,3.827906,3.857570,3.887029,3.916290,3.945357,3.974233,4.002924,
	4.031433,4.059765,4.087922,4.115910,4.143731,4.171389,4.198887,4.226228,4.253415,4.280452,4.307342,4.334086,4.360688,4.387150,4.413475,4.439666,4.465724,4.491653,4.517453,4.543128,4.568680,4.594110,4.619421,4.644614,4.669692,4.694656,4.719508,4.744250,4.768883,4.793410,4.817831,4.842149,
	4.866364,4.890479,4.914494,4.938412,4.962233,4.985959,5.009591,5.033131,5.056580,5.079938,5.103208,5.126390,5.149486,5.172496,5.195422,5.218264,5.241025,5.263704,5.286304,5.308824,5.331265,5.353630,5.375918,5.398131,5.420270,5.442334,5.464326,5.486246,5.508095,5.529873,5.551582,5.573222,
	5.594793,5.616298,5.637736,5.659108,5.680415,5.701658,5.722836,5.743952,5.765005,5.785996,5.806926,5.827796,5.848605,5.869355,5.890047,5.910680,5.931255,5.951774,5.972236,5.992642,6.012992,6.033288,6.053529,6.073716,6.093850,6.113931,6.133960,6.153936,6.173861,6.193735,6.213559,6.233332,
	6.253056,6.272730,6.292356,6.311933,6.331462,6.350944,6.370378,6.389766,6.409107,6.428402,6.447652,6.466857,6.486016,6.505131,6.524202,6.543229,6.562213,6.581154,6.600051,6.618907,6.637720,6.656492,6.675222,6.693911,6.712559,6.731167,6.749734,6.768262,6.786750,6.805199,6.823608,6.841980,
	6.860312,6.878607,6.896863,6.915082,6.933264,6.951408,6.969516,6.987587,7.005622,7.023621,7.041584,7.059512,7.077404,7.095261,7.113084,7.130872,7.148625,7.166344,7.184030,7.201682,7.219300,7.236885,7.254438,7.271957,7.289444,7.306899,7.324321,7.341711,7.359070,7.376397,7.393693,7.410958,
	7.428192,7.445395,7.462567,7.479709,7.496821,7.513903,7.530955,7.547978,7.564971,7.581935,7.598869,7.615775,7.632652,7.649500,7.666320,7.683112,7.699876,7.716612,7.733320,7.750000,7.766653,7.783279,7.799877,7.816449,7.832994,7.849512,7.866003,7.882469,7.898908,7.915321,7.931708,7.948069,
	7.964405,7.980715,7.996999,8.013259,8.029493,8.045703,8.061887,8.078047,8.094183,8.110294,8.126380,8.142443,8.158481,8.174496,8.190486,8.206453,8.222397,8.238317,8.254214,8.270087,8.285938,8.301765,8.317570,8.333352,8.349111,8.364848,8.380563,8.396255,8.411925,8.427573,8.443199,8.458803,
	8.474386,8.489946,8.505486,8.521004,8.536500,8.551976,8.567430,8.582863,8.598275,8.613667,8.629038,8.644388,8.659718,8.675027,8.690316,8.705584,8.720833,8.736061,8.751270,8.766459,8.781628,8.796777,8.811906,8.827016,8.842107,8.857178,8.872230,8.887263,8.902277,8.917272,8.932248,8.947205,
	8.962143,8.977063,8.991964,9.006847,9.021711,9.036557,9.051385,9.066194,9.080985,9.095759,9.110514,9.125251,9.139971,9.154673,9.169357,9.184024,9.198673,9.213305,9.227919,9.242517,9.257096,9.271659,9.286205,9.300734,9.315245,9.329740,9.344219,9.358680,9.373125,9.387553,9.401964,9.416360,
	9.430738,9.445101,9.459447,9.473777,9.488091,9.502388,9.516670,9.530936,9.545186,9.559420,9.573638,9.587841,9.602028,9.616199,9.630355,9.644495,9.658620,9.672730,9.686824,9.700904,9.714968,9.729016,9.743050,9.757069,9.771073,9.785062,9.799036,9.812995,9.826940,9.840870,9.854785,9.868686,
	9.882572,9.896444,9.910301,9.924144,9.937973,9.951788,9.965588,9.979374,9.993146,10.006904,10.020648,10.034378,10.048094,10.061797,10.075485,10.089160,10.102821,10.116468,10.130102,10.143722,10.157329,10.170922,10.184502,10.198069,10.211622,10.225162,10.238688,10.252202,10.265702,10.279189,10.292664,10.306125,
	10.319573,10.333008,10.346430,10.359840,10.373237,10.386621,10.399992,10.413350,10.426696,10.440030,10.453351,10.466659,10.479955,10.493238,10.506509,10.519768,10.533015,10.546249,10.559471,10.572680,10.585878,10.599064,10.612237,10.625399,10.638548,10.651686,10.664811,10.677925,10.691027,10.704117,10.717195,10.730262,
	10.743317,10.756360,10.769392,10.782412,10.795420,10.808417,10.821403,10.834377,10.847340,10.860291,10.873231,10.886160,10.899077,10.911983,10.924878,10.937762,10.950635,10.963497,10.976347,10.989187,11.002015,11.014833,11.027640,11.040436,11.053220,11.065995,11.078758,11.091510,11.104252,11.116983,11.129704,11.142414,
	11.155113,11.167801,11.180479,11.193147,11.205804,11.218451,11.231087,11.243713,11.256328,11.268933,11.281528,11.294112,11.306687,11.319251,11.331804,11.344348,11.356882,11.369405,11.381918,11.394422,11.406915,11.419398,11.431872,11.444335,11.456789,11.469232,11.481666,11.494090,11.506504,11.518909,11.531303,11.543688,
	11.556063,11.568429,11.580785,11.593131,11.605468,11.617795,11.630113,11.642421,11.654719,11.667009,11.679288,11.691559,11.703820,11.716071,11.728313,11.740546,11.752770,11.764985,11.777190,11.789386,11.801573,11.813750,11.825919,11.838078,11.850228,11.862370,11.874502,11.886625,11.898739,11.910845,11.922941,11.935028,
	11.947107,11.959176,11.971237,11.983289,11.995332,12.007366,12.019392,12.031409,12.043417,12.055416,12.067407,12.079389,12.091362,12.103327,12.115283,12.127231,12.139170,12.151100,12.163022,12.174936,12.186841,12.198738,12.210626,12.222506,12.234377,12.246241,12.258095,12.269942,12.281780,12.293610,12.305432,12.317245,
	12.329050,12.340847,12.352636,12.364417,12.376189,12.387954,12.399710,12.411458,12.423198,12.434930,12.446655,12.458371,12.470079,12.481779,12.493471,12.505156,12.516832,12.528501,12.540161,12.551814,12.563459,12.575096,12.586726,12.598347,12.609961,12.621567,12.633165,12.644756,12.656339,12.667914,12.679482,12.691042,
	12.702594,12.714139,12.725677,12.737206,12.748728,12.760243,12.771750,12.783250,12.794742,12.806226,12.817704,12.829173,12.840636,12.852091,12.863538,12.874979,12.886412,12.897837,12.909255,12.920666,12.932070,12.943467,12.954856,12.966238,12.977612,12.988980,13.000340,13.011694,13.023040,13.034379,13.045710,13.057035,
	13.068353,13.079663,13.090967,13.102263,13.113553,13.124835,13.136110,13.147379,13.158640,13.169895,13.181142,13.192383,13.203617,13.214844,13.226064,13.237277,13.248483,13.259683,13.270875,13.282061,13.293240,13.304413,13.315578,13.326737,13.337889,13.349034,13.360173,13.371305,13.382430,13.393549,13.404661,13.415766,
	13.426865,13.437957,13.449042,13.460121,13.471194,13.482260,13.493319,13.504372,13.515418,13.526458,13.537491,13.548518,13.559538,13.570552,13.581560,13.592561,13.603555,13.614544,13.625525,13.636501,13.647470,13.658433,13.669390,13.680340,13.691284,13.702221,13.713153,13.724078,13.734997,13.745909,13.756816,13.767716,
	13.778610,13.789497,13.800379,13.811254,13.822124,13.832987,13.843844,13.854695,13.865540,13.876378,13.887211,13.898037,13.908858,13.919672,13.930481,13.941283,13.952080,13.962870,13.973654,13.984433,13.995205,14.005972,14.016733,14.027487,14.038236,14.048979,14.059716,14.070447,14.081172,14.091891,14.102605,14.113313,
	14.124014,14.134710,14.145401,14.156085,14.166764,14.177437,14.188104,14.198765,14.209421,14.220071,14.230715,14.241353,14.251986,14.262613,14.273234,14.283850,14.294460,14.305065,14.315664,14.326257,14.336844,14.347426,14.358003,14.368574,14.379139,14.389699,14.400253,14.410801,14.421344,14.431882,14.442414,14.452941,
	14.463462,14.473977,14.484487,14.494992,14.505491,14.515985,14.526473,14.536956,14.547434,14.557906,14.568373,14.578834,14.589290,14.599741,14.610186,14.620626,14.631061,14.641490,14.651914,14.662332,14.672746,14.683154,14.693557,14.703954,14.714346,14.724734,14.735115,14.745492,14.755863,14.766229,14.776590,14.786946,
	14.797297,14.807642,14.817982,14.828317,14.838647,14.848972,14.859292,14.869606,14.879916,14.890220,14.900519,14.910813,14.921102,14.931386,14.941665,14.951939,14.962208,14.972472,14.982731,14.992984,15.003233,15.013477,15.023716,15.033950,15.044178,15.054402,15.064621,15.074835,15.085044,15.095248,15.105447,15.115642,
	15.125831,15.136015,15.146195,15.156370,15.166539,15.176704,15.186864,15.197020,15.207170,15.217316,15.227456,15.237592,15.247723,15.257850,15.267971,15.278088,15.288200,15.298307,15.308410,15.318507,15.328600,15.338688,15.348772,15.358851,15.368925,15.378994,15.389059,15.399119,15.409174,15.419224,15.429270,15.439312,
	15.449348,15.459380,15.469407,15.479430,15.489448,15.499462,15.509470,15.519475,15.529474,15.539469,15.549460,15.559446,15.569427,15.579404,15.589376,15.599344,15.609307,15.619266,15.629220,15.639169,15.649114,15.659055,15.668991,15.678923,15.688850,15.698772,15.708691,15.718604,15.728514,15.738418,15.748319,15.758215,
	15.768106,15.777994,15.787876,15.797755,15.807629,15.817498,15.827363,15.837224,15.847081,15.856933,15.866780,15.876624,15.886463,15.896298,15.906128,15.915954,15.925776,15.935593,15.945406,15.955215,15.965020,15.974820,15.984616,15.994408,16.004195,16.013978,16.023757,16.033532,16.043303,16.053069,16.062831,16.072589,
	16.082342,16.092092,16.101837,16.111578,16.121315,16.131048,16.140776,16.150500,16.160220,16.169937,16.179648,16.189356,16.199060,16.208759,16.218455,16.228146,16.237833,16.247516,16.257195,16.266870,16.276540,16.286207,16.295870,16.305528,16.315183,16.324833,16.334479,16.344122,16.353760,16.363394,16.373024,16.382651

};

// Y = 0:1023;A = 1+0.5*(Y-64).^0.6; A(1:64)=1; figure,hold on, plot(Y,A, 'r')
RK_F32 MotionDetectTable4[MOTION_DETECT_TALBE_LEN] = {
	1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,
	1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,
	1.000000,1.500000,1.757858,1.966591,2.148698,2.313264,2.465078,2.607048,2.741101,2.868596,2.990536,3.107685,3.220643,3.329893,3.435829,3.538778,3.639016,3.736777,3.832263,3.925649,4.017088,4.106716,4.194652,4.281004,4.365865,4.449324,4.531458,4.612337,4.692027,4.770586,4.848068,4.924524,
	5.000000,5.074538,5.148178,5.220956,5.292907,5.364063,5.434454,5.504108,5.573051,5.641307,5.708901,5.775854,5.842188,5.907920,5.973072,6.037658,6.101698,6.165206,6.228198,6.290687,6.352689,6.414215,6.475279,6.535892,6.596066,6.655811,6.715139,6.774059,6.832581,6.890714,6.948466,7.005848,
	7.062866,7.119529,7.175845,7.231820,7.287462,7.342777,7.397773,7.452455,7.506831,7.560905,7.614683,7.668172,7.721376,7.774300,7.826951,7.879332,7.931448,7.983305,8.034906,8.086256,8.137360,8.188220,8.238842,8.289228,8.339384,8.389312,8.439016,8.488500,8.537767,8.586820,8.635662,8.684297,
	8.732728,8.780958,8.828988,8.876824,8.924466,8.971918,9.019183,9.066262,9.113159,9.159876,9.206416,9.252780,9.298971,9.344992,9.390843,9.436529,9.482050,9.527409,9.572607,9.617647,9.662531,9.707260,9.751837,9.796262,9.840539,9.884668,9.928652,9.972492,10.016189,10.059746,10.103163,10.146443,
	10.189587,10.232596,10.275472,10.318216,10.360830,10.403315,10.445672,10.487904,10.530010,10.571992,10.613853,10.655592,10.697211,10.738711,10.780094,10.821360,10.862511,10.903548,10.944472,10.985284,11.025985,11.066576,11.107058,11.147433,11.187700,11.227862,11.267919,11.307872,11.347722,11.387470,11.427117,11.466664,
	11.506111,11.545460,11.584711,11.623866,11.662924,11.701887,11.740756,11.779532,11.818214,11.856805,11.895304,11.933713,11.972032,12.010262,12.048404,12.086458,12.124426,12.162307,12.200103,12.237814,12.275440,12.312983,12.350444,12.387822,12.425118,12.462334,12.499469,12.536524,12.573500,12.610397,12.647217,12.683959,
	12.720624,12.757213,12.793726,12.830164,12.866527,12.902817,12.939032,12.975174,13.011244,13.047242,13.083168,13.119023,13.154808,13.190523,13.226167,13.261743,13.297250,13.332689,13.368060,13.403364,13.438601,13.473771,13.508875,13.543914,13.578888,13.613797,13.648642,13.683423,13.718140,13.752795,13.787386,13.821916,
	13.856383,13.890789,13.925134,13.959419,13.993642,14.027806,14.061911,14.095956,14.129942,14.163869,14.197738,14.231550,14.265304,14.299001,14.332641,14.366224,14.399752,14.433223,14.466639,14.500000,14.533306,14.566557,14.599754,14.632898,14.665987,14.699024,14.732007,14.764937,14.797815,14.830641,14.863415,14.896138,
	14.928809,14.961429,14.993999,15.026518,15.058986,15.091405,15.123775,15.156095,15.188365,15.220587,15.252760,15.284885,15.316962,15.348991,15.380973,15.412907,15.444794,15.476634,15.508427,15.540175,15.571876,15.603531,15.635140,15.666704,15.698223,15.729696,15.761125,15.792510,15.823850,15.855146,15.886398,15.917606,
	15.948771,15.979893,16.010972,16.042007,16.073001,16.103951,16.134860,16.165726,16.196551,16.227334,16.258076,16.288776,16.319435,16.350054,16.380632,16.411169,16.441666,16.472123,16.502540,16.532917,16.563255,16.593553,16.623813,16.654033,16.684214,16.714357,16.744461,16.774527,16.804554,16.834544,16.864496,16.894410,
	16.924287,16.954126,16.983928,17.013694,17.043422,17.073114,17.102769,17.132388,17.161971,17.191517,17.221028,17.250503,17.279942,17.309346,17.338715,17.368048,17.397346,17.426610,17.455839,17.485033,17.514193,17.543319,17.572410,17.601467,17.630491,17.659481,17.688437,17.717360,17.746249,17.775106,17.803929,17.832719,
	17.861477,17.890201,17.918894,17.947554,17.976181,18.004777,18.033340,18.061872,18.090372,18.118840,18.147276,18.175682,18.204055,18.232398,18.260710,18.288991,18.317241,18.345460,18.373649,18.401807,18.429935,18.458033,18.486100,18.514138,18.542146,18.570124,18.598072,18.625990,18.653880,18.681740,18.709570,18.737372,
	18.765144,18.792888,18.820603,18.848289,18.875946,18.903575,18.931176,18.958748,18.986292,19.013808,19.041296,19.068756,19.096189,19.123593,19.150970,19.178320,19.205642,19.232937,19.260204,19.287445,19.314658,19.341845,19.369005,19.396138,19.423244,19.450324,19.477377,19.504404,19.531404,19.558379,19.585327,19.612249,
	19.639146,19.666016,19.692861,19.719680,19.746473,19.773241,19.799984,19.826701,19.853393,19.880060,19.906701,19.933318,19.959910,19.986477,20.013019,20.039536,20.066029,20.092497,20.118941,20.145361,20.171756,20.198127,20.224474,20.250797,20.277096,20.303371,20.329622,20.355850,20.382053,20.408234,20.434390,20.460523,
	20.486633,20.512720,20.538783,20.564823,20.590840,20.616834,20.642805,20.668754,20.694679,20.720582,20.746462,20.772319,20.798154,20.823967,20.849757,20.875525,20.901270,20.926993,20.952695,20.978374,21.004031,21.029666,21.055280,21.080871,21.106441,21.131989,21.157516,21.183021,21.208505,21.233967,21.259408,21.284827,
	21.310226,21.335603,21.360959,21.386294,21.411608,21.436901,21.462174,21.487425,21.512656,21.537866,21.563056,21.588225,21.613373,21.638501,21.663609,21.688696,21.713763,21.738810,21.763837,21.788844,21.813830,21.838797,21.863743,21.888670,21.913577,21.938465,21.963332,21.988180,22.013008,22.037817,22.062606,22.087376,
	22.112127,22.136858,22.161570,22.186262,22.210936,22.235590,22.260225,22.284841,22.309439,22.334017,22.358577,22.383117,22.407639,22.432142,22.456627,22.481093,22.505540,22.529969,22.554380,22.578772,22.603145,22.627500,22.651837,22.676156,22.700457,22.724739,22.749004,22.773250,22.797479,22.821689,22.845882,22.870056,
	22.894213,22.918352,22.942474,22.966578,22.990664,23.014732,23.038783,23.062817,23.086833,23.110832,23.134813,23.158777,23.182724,23.206654,23.230566,23.254461,23.278340,23.302201,23.326045,23.349872,23.373682,23.397476,23.421252,23.445012,23.468755,23.492481,23.516191,23.539884,23.563560,23.587220,23.610863,23.634490,
	23.658100,23.681694,23.705272,23.728833,23.752378,23.775907,23.799420,23.822916,23.846397,23.869861,23.893309,23.916741,23.940158,23.963558,23.986943,24.010311,24.033664,24.057001,24.080322,24.103628,24.126918,24.150192,24.173451,24.196694,24.219922,24.243134,24.266331,24.289512,24.312678,24.335829,24.358964,24.382084,
	24.405189,24.428279,24.451353,24.474412,24.497457,24.520486,24.543500,24.566499,24.589483,24.612453,24.635407,24.658347,24.681272,24.704182,24.727077,24.749957,24.772823,24.795674,24.818511,24.841333,24.864140,24.886933,24.909711,24.932475,24.955225,24.977960,25.000681,25.023387,25.046079,25.068757,25.091421,25.114070,
	25.136705,25.159326,25.181933,25.204526,25.227105,25.249670,25.272221,25.294758,25.317281,25.339790,25.362285,25.384766,25.407234,25.429688,25.452128,25.474554,25.496966,25.519365,25.541751,25.564122,25.586481,25.608825,25.631156,25.653474,25.675778,25.698069,25.720346,25.742610,25.764860,25.787097,25.809321,25.831532,
	25.853730,25.875914,25.898085,25.920243,25.942387,25.964519,25.986638,26.008743,26.030836,26.052915,26.074982,26.097036,26.119076,26.141104,26.163119,26.185121,26.207111,26.229087,26.251051,26.273002,26.294940,26.316866,26.338779,26.360680,26.382567,26.404443,26.426305,26.448155,26.469993,26.491818,26.513631,26.535431,
	26.557219,26.578995,26.600758,26.622509,26.644247,26.665974,26.687688,26.709390,26.731079,26.752757,26.774422,26.796075,26.817716,26.839345,26.860962,26.882567,26.904159,26.925740,26.947309,26.968866,26.990411,27.011944,27.033465,27.054974,27.076472,27.097958,27.119432,27.140894,27.162344,27.183783,27.205210,27.226625,
	27.248029,27.269421,27.290801,27.312170,27.333527,27.354873,27.376207,27.397530,27.418841,27.440141,27.461429,27.482706,27.503972,27.525226,27.546469,27.567700,27.588921,27.610130,27.631327,27.652514,27.673689,27.694853,27.716006,27.737147,27.758278,27.779397,27.800506,27.821603,27.842689,27.863764,27.884828,27.905881,
	27.926923,27.947955,27.968975,27.989984,28.010983,28.031970,28.052947,28.073913,28.094868,28.115812,28.136746,28.157668,28.178580,28.199481,28.220372,28.241252,28.262121,28.282980,28.303828,28.324665,28.345492,28.366308,28.387113,28.407908,28.428693,28.449467,28.470231,28.490984,28.511726,28.532459,28.553181,28.573892,
	28.594593,28.615284,28.635964,28.656635,28.677294,28.697944,28.718583,28.739212,28.759831,28.780440,28.801038,28.821627,28.842205,28.862773,28.883331,28.903878,28.924416,28.944944,28.965461,28.985969,29.006466,29.026954,29.047431,29.067899,29.088357,29.108804,29.129242,29.149670,29.170088,29.190496,29.210895,29.231283,
	29.251662,29.272031,29.292390,29.312739,29.333079,29.353409,29.373729,29.394039,29.414340,29.434631,29.454913,29.475185,29.495447,29.515700,29.535943,29.556176,29.576400,29.596614,29.616819,29.637015,29.657200,29.677377,29.697544,29.717701,29.737849,29.757988,29.778117,29.798237,29.818348,29.838449,29.858541,29.878623,
	29.898696,29.918760,29.938815,29.958860,29.978896,29.998923,30.018941,30.038949,30.058949,30.078939,30.098920,30.118891,30.138854,30.158808,30.178752,30.198687,30.218614,30.238531,30.258439,30.278338,30.298229,30.318110,30.337982,30.357845,30.377699,30.397545,30.417381,30.437209,30.457027,30.476837,30.496638,30.516430,
	30.536213,30.555987,30.575753,30.595509,30.615257,30.634996,30.654727,30.674448,30.694161,30.713865,30.733561,30.753248,30.772926,30.792595,30.812256,30.831908,30.851551,30.871186,30.890813,30.910430,30.930039,30.949640,30.969232,30.988815,31.008390,31.027957,31.047515,31.067064,31.086605,31.106138,31.125662,31.145177,
	31.164685,31.184184,31.203674,31.223156,31.242630,31.262095,31.281552,31.301001,31.320441,31.339873,31.359297,31.378712,31.398119,31.417518,31.436909,31.456291,31.475666,31.495032,31.514390,31.533739,31.553081,31.572414,31.591739,31.611056,31.630365,31.649666,31.668959,31.688243,31.707520,31.726788,31.746049,31.765301
};

// Y = 0:1023;A = 1+0.75*(Y-64).^0.6; A(1:64)=1; figure,hold on, plot(Y,A, 'r')
RK_F32 MotionDetectTable5[MOTION_DETECT_TALBE_LEN] = {
	1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,
	1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,
	1.000000,1.750000,2.136787,2.449887,2.723048,2.969896,3.197617,3.410572,3.611652,3.802895,3.985804,4.161527,4.330965,4.494840,4.653744,4.808167,4.958524,5.105165,5.248394,5.388473,5.525632,5.660074,5.791979,5.921505,6.048798,6.173986,6.297187,6.418506,6.538040,6.655878,6.772102,6.886786,
	7.000000,7.111807,7.222267,7.331434,7.439361,7.546095,7.651681,7.756162,7.859576,7.961961,8.063352,8.163782,8.263281,8.361881,8.459607,8.556488,8.652547,8.747809,8.842297,8.936031,9.029033,9.121323,9.212919,9.303838,9.394099,9.483717,9.572709,9.661088,9.748871,9.836070,9.922700,10.008772,
	10.094299,10.179294,10.263767,10.347730,10.431193,10.514166,10.596660,10.678683,10.760246,10.841357,10.922025,11.002257,11.082063,11.161450,11.240426,11.318998,11.397173,11.474958,11.552359,11.629385,11.706039,11.782330,11.858262,11.933843,12.009076,12.083968,12.158524,12.232750,12.306650,12.380230,12.453494,12.526446,
	12.599092,12.671436,12.743483,12.815235,12.886699,12.957877,13.028774,13.099393,13.169739,13.239815,13.309624,13.379170,13.448457,13.517487,13.586265,13.654793,13.723075,13.791113,13.858911,13.926471,13.993796,14.060890,14.127755,14.194394,14.260809,14.327003,14.392978,14.458738,14.524284,14.589619,14.654745,14.719665,
	14.784380,14.848894,14.913208,14.977324,15.041245,15.104973,15.168509,15.231855,15.295015,15.357989,15.420779,15.483387,15.545816,15.608066,15.670140,15.732040,15.793766,15.855322,15.916708,15.977925,16.038977,16.099864,16.160587,16.221149,16.281550,16.341793,16.401879,16.461808,16.521583,16.581205,16.640676,16.699996,
	16.759167,16.818190,16.877067,16.935798,16.994386,17.052831,17.111134,17.169297,17.227321,17.285207,17.342956,17.400570,17.458048,17.515393,17.572606,17.629688,17.686639,17.743461,17.800154,17.856720,17.913160,17.969475,18.025665,18.081733,18.137677,18.193500,18.249203,18.304786,18.360250,18.415596,18.470825,18.525939,
	18.580936,18.635820,18.690589,18.745246,18.799791,18.854225,18.908548,18.962762,19.016867,19.070863,19.124753,19.178535,19.232212,19.285784,19.339251,19.392615,19.445875,19.499033,19.552090,19.605046,19.657901,19.710656,19.763313,19.815872,19.868332,19.920696,19.972963,20.025134,20.077211,20.129192,20.181080,20.232874,
	20.284575,20.336184,20.387702,20.439128,20.490464,20.541709,20.592866,20.643933,20.694912,20.745804,20.796608,20.847325,20.897956,20.948501,20.998961,21.049336,21.099627,21.149835,21.199959,21.250000,21.299959,21.349836,21.399632,21.449347,21.498981,21.548535,21.598010,21.647406,21.696723,21.745962,21.795123,21.844207,
	21.893214,21.942144,21.990998,22.039776,22.088480,22.137108,22.185662,22.234142,22.282548,22.330881,22.379141,22.427328,22.475443,22.523487,22.571459,22.619360,22.667191,22.714951,22.762641,22.810262,22.857813,22.905296,22.952710,23.000056,23.047334,23.094545,23.141688,23.188765,23.235775,23.282719,23.329597,23.376410,
	23.423157,23.469839,23.516457,23.563011,23.609501,23.655927,23.702290,23.748589,23.794826,23.841001,23.887113,23.933164,23.979153,24.025081,24.070947,24.116753,24.162499,24.208184,24.253810,24.299376,24.344883,24.390330,24.435719,24.481049,24.526321,24.571535,24.616691,24.661790,24.706832,24.751816,24.796744,24.841615,
	24.886430,24.931189,24.975893,25.020541,25.065133,25.109671,25.154154,25.198582,25.242956,25.287276,25.331542,25.375754,25.419913,25.464019,25.508072,25.552072,25.596020,25.639915,25.683758,25.727550,25.771289,25.814978,25.858615,25.902201,25.945736,25.989221,26.032656,26.076040,26.119374,26.162658,26.205893,26.249079,
	26.292215,26.335302,26.378341,26.421330,26.464272,26.507165,26.550010,26.592808,26.635557,26.678260,26.720914,26.763522,26.806083,26.848597,26.891065,26.933486,26.975861,27.018190,27.060473,27.102711,27.144903,27.187049,27.229150,27.271207,27.313218,27.355185,27.397108,27.438986,27.480820,27.522609,27.564355,27.606058,
	27.647716,27.689332,27.730904,27.772433,27.813919,27.855363,27.896764,27.938122,27.979438,28.020712,28.061944,28.103135,28.144283,28.185390,28.226456,28.267480,28.308463,28.349405,28.390307,28.431167,28.471988,28.512767,28.553507,28.594206,28.634866,28.675485,28.716065,28.756606,28.797107,28.837568,28.877991,28.918374,
	28.958719,28.999024,29.039291,29.079520,29.119710,29.159862,29.199976,29.240051,29.280089,29.320089,29.360052,29.399977,29.439865,29.479715,29.519528,29.559304,29.599044,29.638746,29.678412,29.718041,29.757634,29.797191,29.836711,29.876196,29.915644,29.955057,29.994433,30.033774,30.073080,30.112350,30.151585,30.190785,
	30.229950,30.269080,30.308175,30.347235,30.386261,30.425252,30.464208,30.503131,30.542019,30.580873,30.619693,30.658479,30.697231,30.735950,30.774635,30.813287,30.851905,30.890490,30.929042,30.967561,31.006046,31.044499,31.082919,31.121307,31.159661,31.197984,31.236274,31.274531,31.312757,31.350950,31.389111,31.427241,
	31.465338,31.503404,31.541438,31.579441,31.617412,31.655352,31.693260,31.731138,31.768984,31.806799,31.844584,31.882337,31.920060,31.957752,31.995413,32.033044,32.070645,32.108215,32.145755,32.183265,32.220745,32.258195,32.295615,32.333005,32.370366,32.407697,32.444998,32.482270,32.519512,32.556726,32.593909,32.631064,
	32.668190,32.705287,32.742354,32.779393,32.816403,32.853385,32.890338,32.927262,32.964158,33.001026,33.037865,33.074676,33.111459,33.148214,33.184940,33.221639,33.258310,33.294954,33.331569,33.368157,33.404718,33.441251,33.477756,33.514234,33.550685,33.587109,33.623506,33.659875,33.696218,33.732534,33.768822,33.805085,
	33.841320,33.877529,33.913711,33.949866,33.985996,34.022099,34.058175,34.094226,34.130250,34.166248,34.202220,34.238166,34.274086,34.309981,34.345849,34.381692,34.417509,34.453301,34.489067,34.524808,34.560523,34.596213,34.631878,34.667518,34.703132,34.738722,34.774286,34.809825,34.845340,34.880830,34.916295,34.951735,
	34.987150,35.022541,35.057908,35.093250,35.128567,35.163861,35.199130,35.234374,35.269595,35.304791,35.339964,35.375112,35.410237,35.445337,35.480414,35.515467,35.550496,35.585502,35.620484,35.655442,35.690377,35.725288,35.760177,35.795041,35.829883,35.864701,35.899496,35.934268,35.969017,36.003743,36.038446,36.073126,
	36.107783,36.142418,36.177030,36.211619,36.246185,36.280729,36.315250,36.349749,36.384225,36.418679,36.453111,36.487520,36.521907,36.556272,36.590615,36.624936,36.659235,36.693511,36.727766,36.761999,36.796210,36.830400,36.864567,36.898713,36.932837,36.966940,37.001021,37.035081,37.069119,37.103136,37.137131,37.171105,
	37.205058,37.238990,37.272900,37.306789,37.340658,37.374505,37.408331,37.442137,37.475921,37.509685,37.543427,37.577149,37.610851,37.644531,37.678191,37.711831,37.745450,37.779048,37.812626,37.846184,37.879721,37.913238,37.946734,37.980211,38.013667,38.047103,38.080519,38.113915,38.147290,38.180646,38.213982,38.247298,
	38.280594,38.313871,38.347127,38.380364,38.413581,38.446779,38.479957,38.513115,38.546254,38.579373,38.612473,38.645553,38.678614,38.711656,38.744679,38.777682,38.810666,38.843631,38.876576,38.909503,38.942411,38.975299,39.008169,39.041019,39.073851,39.106664,39.139458,39.172233,39.204990,39.237728,39.270447,39.303147,
	39.335829,39.368492,39.401137,39.433763,39.466371,39.498961,39.531532,39.564084,39.596619,39.629135,39.661633,39.694112,39.726574,39.759017,39.791443,39.823850,39.856239,39.888610,39.920963,39.953299,39.985616,40.017916,40.050198,40.082462,40.114708,40.146936,40.179147,40.211340,40.243516,40.275674,40.307815,40.339938,
	40.372043,40.404131,40.436202,40.468255,40.500291,40.532310,40.564311,40.596295,40.628262,40.660212,40.692144,40.724060,40.755958,40.787839,40.819703,40.851551,40.883381,40.915194,40.946991,40.978771,41.010533,41.042279,41.074009,41.105721,41.137417,41.169096,41.200758,41.232404,41.264033,41.295646,41.327242,41.358822,
	41.390385,41.421932,41.453462,41.484976,41.516474,41.547955,41.579420,41.610869,41.642302,41.673718,41.705118,41.736502,41.767870,41.799222,41.830558,41.861878,41.893182,41.924469,41.955741,41.986997,42.018237,42.049462,42.080670,42.111863,42.143039,42.174201,42.205346,42.236476,42.267590,42.298688,42.329771,42.360838,
	42.391890,42.422926,42.453947,42.484952,42.515942,42.546916,42.577875,42.608819,42.639747,42.670660,42.701557,42.732440,42.763307,42.794159,42.824996,42.855817,42.886624,42.917415,42.948192,42.978953,43.009699,43.040431,43.071147,43.101849,43.132535,43.163207,43.193863,43.224505,43.255132,43.285745,43.316342,43.346925,
	43.377493,43.408046,43.438585,43.469109,43.499618,43.530113,43.560593,43.591059,43.621510,43.651947,43.682369,43.712777,43.743170,43.773549,43.803914,43.834264,43.864600,43.894922,43.925229,43.955522,43.985801,44.016065,44.046316,44.076552,44.106774,44.136982,44.167176,44.197356,44.227521,44.257673,44.287811,44.317935,
	44.348044,44.378140,44.408222,44.438290,44.468344,44.498385,44.528411,44.558424,44.588423,44.618408,44.648379,44.678337,44.708281,44.738211,44.768128,44.798031,44.827921,44.857797,44.887659,44.917508,44.947343,44.977165,45.006973,45.036768,45.066549,45.096317,45.126072,45.155813,45.185541,45.215255,45.244957,45.274645,
	45.304319,45.333981,45.363629,45.393264,45.422886,45.452495,45.482090,45.511673,45.541242,45.570798,45.600341,45.629871,45.659389,45.688893,45.718384,45.747862,45.777327,45.806779,45.836219,45.865645,45.895059,45.924460,45.953848,45.983223,46.012586,46.041935,46.071272,46.100596,46.129908,46.159207,46.188493,46.217766,
	46.247027,46.276275,46.305511,46.334734,46.363945,46.393143,46.422328,46.451501,46.480661,46.509810,46.538945,46.568068,46.597179,46.626277,46.655364,46.684437,46.713499,46.742548,46.771584,46.800609,46.829621,46.858621,46.887609,46.916584,46.945548,46.974499,47.003438,47.032365,47.061280,47.090182,47.119073,47.147952
};

// Y = 0:1023;A = 1+1.0*(Y-64).^0.6; A(1:64)=1; figure,hold on, plot(Y,A, 'r')
RK_F32 MotionDetectTable6[MOTION_DETECT_TALBE_LEN] = {
	1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,
	1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,1.000000,
	1.000000,2.000000,2.515717,2.933182,3.297397,3.626528,3.930156,4.214096,4.482202,4.737193,4.981072,5.215369,5.441286,5.659786,5.871658,6.077556,6.278032,6.473553,6.664525,6.851297,7.034176,7.213432,7.389305,7.562007,7.731731,7.898648,8.062915,8.224674,8.384053,8.541171,8.696136,8.849049,
	9.000000,9.149076,9.296355,9.441912,9.585814,9.728127,9.868908,10.008215,10.146101,10.282614,10.417802,10.551709,10.684375,10.815841,10.946143,11.075317,11.203396,11.330412,11.456396,11.581375,11.705378,11.828431,11.950558,12.071784,12.192132,12.311623,12.430278,12.548118,12.665161,12.781427,12.896933,13.011696,
	13.125733,13.239059,13.351689,13.463640,13.574923,13.685554,13.795546,13.904911,14.013661,14.121809,14.229366,14.336343,14.442751,14.548600,14.653901,14.758664,14.862897,14.966610,15.069813,15.172513,15.274719,15.376440,15.477683,15.578457,15.678768,15.778624,15.878033,15.977000,16.075534,16.173640,16.271325,16.368595,
	16.465456,16.561915,16.657977,16.753647,16.848932,16.943836,17.038365,17.132525,17.226319,17.319753,17.412832,17.505560,17.597942,17.689983,17.781687,17.873058,17.964100,18.054817,18.145214,18.235294,18.325062,18.414520,18.503674,18.592525,18.681078,18.769337,18.857304,18.944984,19.032378,19.119492,19.206327,19.292886,
	19.379174,19.465192,19.550944,19.636432,19.721660,19.806630,19.891345,19.975807,20.060020,20.143985,20.227705,20.311183,20.394421,20.477422,20.560187,20.642720,20.725022,20.807096,20.888943,20.970567,21.051969,21.133151,21.214116,21.294865,21.375400,21.455724,21.535838,21.615744,21.695445,21.774941,21.854234,21.933328,
	22.012222,22.090920,22.169422,22.247731,22.325848,22.403774,22.481512,22.559063,22.636428,22.713609,22.790608,22.867426,22.944064,23.020525,23.096808,23.172917,23.248852,23.324614,23.400205,23.475627,23.550880,23.625967,23.700887,23.775643,23.850236,23.924667,23.998937,24.073048,24.147000,24.220795,24.294434,24.367918,
	24.441248,24.514426,24.587452,24.660328,24.733055,24.805633,24.878064,24.950349,25.022489,25.094484,25.166337,25.238047,25.309616,25.381045,25.452335,25.523486,25.594500,25.665378,25.736120,25.806727,25.877201,25.947542,26.017751,26.087829,26.157776,26.227594,26.297284,26.366846,26.436281,26.505589,26.574773,26.643832,
	26.712767,26.781579,26.850269,26.918837,26.987285,27.055613,27.123821,27.191911,27.259883,27.327738,27.395477,27.463100,27.530608,27.598002,27.665282,27.732449,27.799503,27.866446,27.933278,28.000000,28.066612,28.133115,28.199509,28.265795,28.331975,28.398047,28.464014,28.529875,28.595631,28.661283,28.726831,28.792276,
	28.857618,28.922858,28.987997,29.053035,29.117973,29.182811,29.247549,29.312189,29.376731,29.441174,29.505521,29.569771,29.633925,29.697983,29.761945,29.825814,29.889588,29.953268,30.016855,30.080349,30.143751,30.207061,30.270280,30.333408,30.396445,30.459393,30.522251,30.585020,30.647700,30.710292,30.772796,30.835213,
	30.897543,30.959786,31.021943,31.084015,31.146001,31.207903,31.269720,31.331453,31.393102,31.454668,31.516151,31.577552,31.638871,31.700108,31.761263,31.822338,31.883332,31.944246,32.005080,32.065835,32.126510,32.187107,32.247625,32.308065,32.368428,32.428713,32.488922,32.549053,32.609109,32.669088,32.728992,32.788820,
	32.848574,32.908252,32.967857,33.027387,33.086844,33.146228,33.205538,33.264776,33.323941,33.383034,33.442056,33.501005,33.559884,33.618692,33.677429,33.736096,33.794693,33.853220,33.911678,33.970066,34.028386,34.086637,34.144820,34.202935,34.260982,34.318962,34.376874,34.434720,34.492498,34.550211,34.607857,34.665438,
	34.722953,34.780403,34.837787,34.895107,34.952362,35.009553,35.066680,35.123744,35.180743,35.237679,35.294553,35.351363,35.408111,35.464797,35.521420,35.577982,35.634482,35.690920,35.747298,35.803614,35.859870,35.916065,35.972201,36.028276,36.084291,36.140247,36.196144,36.251981,36.307759,36.363479,36.419140,36.474744,
	36.530289,36.585776,36.641205,36.696577,36.751892,36.807150,36.862352,36.917496,36.972584,37.027616,37.082592,37.137513,37.192377,37.247187,37.301941,37.356640,37.411284,37.465874,37.520409,37.574890,37.629317,37.683690,37.738009,37.792275,37.846488,37.900647,37.954754,38.008808,38.062809,38.116758,38.170654,38.224499,
	38.278291,38.332032,38.385722,38.439360,38.492947,38.546483,38.599968,38.653402,38.706786,38.760119,38.813403,38.866636,38.919819,38.972953,39.026038,39.079073,39.132058,39.184995,39.237883,39.290722,39.343512,39.396255,39.448948,39.501594,39.554192,39.606742,39.659244,39.711699,39.764107,39.816467,39.868781,39.921047,
	39.973267,40.025440,40.077566,40.129647,40.181681,40.233669,40.285611,40.337507,40.389358,40.441164,40.492924,40.544639,40.596308,40.647933,40.699514,40.751049,40.802540,40.853987,40.905389,40.956747,41.008062,41.059332,41.110559,41.161742,41.212882,41.263978,41.315032,41.366042,41.417009,41.467933,41.518815,41.569654,
	41.620451,41.671206,41.721918,41.772588,41.823216,41.873803,41.924347,41.974850,42.025312,42.075732,42.126111,42.176449,42.226746,42.277002,42.327218,42.377393,42.427527,42.477620,42.527674,42.577687,42.627660,42.677594,42.727487,42.777341,42.827155,42.876929,42.926664,42.976360,43.026017,43.075634,43.125213,43.174752,
	43.224253,43.273715,43.323139,43.372524,43.421871,43.471180,43.520450,43.569683,43.618877,43.668034,43.717153,43.766235,43.815278,43.864285,43.913254,43.962186,44.011081,44.059938,44.108759,44.157543,44.206290,44.255001,44.303675,44.352313,44.400914,44.449479,44.498008,44.546500,44.594957,44.643378,44.691763,44.740113,
	44.788427,44.836705,44.884948,44.933155,44.981328,45.029465,45.077567,45.125634,45.173666,45.221664,45.269627,45.317555,45.365448,45.413308,45.461132,45.508923,45.556679,45.604402,45.652090,45.699744,45.747365,45.794951,45.842504,45.890024,45.937510,45.984962,46.032381,46.079767,46.127120,46.174440,46.221726,46.268980,
	46.316201,46.363389,46.410544,46.457667,46.504757,46.551814,46.598840,46.645833,46.692793,46.739722,46.786618,46.833483,46.880315,46.927116,46.973885,47.020622,47.067328,47.114002,47.160645,47.207256,47.253836,47.300385,47.346902,47.393388,47.439844,47.486268,47.532662,47.579024,47.625356,47.671658,47.717928,47.764168,
	47.810378,47.856557,47.902706,47.948825,47.994913,48.040972,48.087000,48.132998,48.178967,48.224906,48.270814,48.316694,48.362543,48.408363,48.454154,48.499915,48.545646,48.591348,48.637022,48.682665,48.728280,48.773866,48.819423,48.864951,48.910450,48.955920,49.001361,49.046774,49.092158,49.137514,49.182841,49.228140,
	49.273411,49.318653,49.363867,49.409053,49.454210,49.499340,49.544442,49.589515,49.634561,49.679579,49.724570,49.769533,49.814468,49.859375,49.904255,49.949108,49.993933,50.038731,50.083501,50.128245,50.172961,50.217650,50.262312,50.306948,50.351556,50.396137,50.440692,50.485219,50.529721,50.574195,50.618643,50.663064,
	50.707459,50.751828,50.796170,50.840485,50.884775,50.929038,50.973276,51.017487,51.061672,51.105831,51.149964,51.194071,51.238153,51.282208,51.326238,51.370243,51.414221,51.458174,51.502102,51.546004,51.589881,51.633732,51.677558,51.721359,51.765135,51.808885,51.852611,51.896311,51.939986,51.983637,52.027262,52.070863,
	52.114439,52.157990,52.201516,52.245018,52.288495,52.331947,52.375376,52.418779,52.462158,52.505513,52.548844,52.592150,52.635432,52.678690,52.721923,52.765133,52.808319,52.851480,52.894618,52.937732,52.980822,53.023888,53.066930,53.109949,53.152944,53.195915,53.238863,53.281787,53.324688,53.367566,53.410420,53.453250,
	53.496057,53.538842,53.581602,53.624340,53.667055,53.709746,53.752415,53.795060,53.837683,53.880282,53.922859,53.965413,54.007944,54.050452,54.092938,54.135401,54.177841,54.220259,54.262655,54.305027,54.347378,54.389706,54.432011,54.474295,54.516556,54.558795,54.601011,54.643206,54.685378,54.727528,54.769656,54.811763,
	54.853847,54.895909,54.937950,54.979969,55.021965,55.063940,55.105894,55.147826,55.189736,55.231624,55.273491,55.315337,55.357160,55.398963,55.440744,55.482504,55.524242,55.565959,55.607655,55.649330,55.690983,55.732615,55.774227,55.815817,55.857386,55.898934,55.940461,55.981968,56.023453,56.064917,56.106361,56.147784,
	56.189186,56.230568,56.271929,56.313269,56.354589,56.395888,56.437167,56.478425,56.519662,56.560880,56.602077,56.643253,56.684409,56.725545,56.766661,56.807757,56.848832,56.889887,56.930922,56.971938,57.012933,57.053908,57.094863,57.135798,57.176713,57.217609,57.258484,57.299340,57.340176,57.380993,57.421789,57.462566,
	57.503324,57.544062,57.584780,57.625479,57.666158,57.706818,57.747458,57.788079,57.828680,57.869263,57.909826,57.950369,57.990894,58.031399,58.071885,58.112352,58.152800,58.193229,58.233638,58.274029,58.314401,58.354754,58.395088,58.435402,58.475699,58.515976,58.556234,58.596474,58.636695,58.676897,58.717081,58.757246,
	58.797392,58.837520,58.877629,58.917720,58.957792,58.997846,59.037882,59.077898,59.117897,59.157877,59.197839,59.237783,59.277708,59.317615,59.357504,59.397375,59.437228,59.477062,59.516878,59.556677,59.596457,59.636220,59.675964,59.715690,59.755399,59.795090,59.834762,59.874417,59.914055,59.953674,59.993276,60.032860,
	60.072426,60.111974,60.151505,60.191019,60.230515,60.269993,60.309454,60.348897,60.388323,60.427731,60.467122,60.506495,60.545851,60.585190,60.624512,60.663816,60.703103,60.742373,60.781625,60.820861,60.860079,60.899280,60.938464,60.977631,61.016781,61.055914,61.095029,61.134128,61.173210,61.212275,61.251324,61.290355,
	61.329369,61.368367,61.407348,61.446312,61.485259,61.524190,61.563104,61.602001,61.640882,61.679746,61.718594,61.757424,61.796239,61.835037,61.873818,61.912583,61.951331,61.990063,62.028779,62.067478,62.106161,62.144828,62.183478,62.222112,62.260730,62.299332,62.337917,62.376486,62.415039,62.453576,62.492097,62.530602
};


// Y = 0:1023; gain=8; A=max(4,0.648*sqrt(max((Y-64),0)*gain)); figure,hold on, plot(Y,A, 'r')
RK_F32 MotionDetectTable7[MOTION_DETECT_TALBE_LEN] = {
	4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,
	4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,
	4.000000,4.000000,4.000000,4.000000,4.000000,4.098312,4.489476,4.849188,5.184000,5.498462,5.795888,6.078779,6.349077,6.608329,6.857787,7.098484,7.331283,7.556914,7.776000,7.989081,8.196624,8.399040,8.596691,8.789900,8.978951,9.164104,9.345589,9.523616,9.698376,9.870042,10.038773,10.204714,
	10.368000,10.528754,10.687090,10.843114,10.996925,11.148614,11.298266,11.445962,11.591776,11.735779,11.878036,12.018610,12.157558,12.294936,12.430795,12.565186,12.698155,12.829745,12.960000,13.088958,13.216659,13.343137,13.468427,13.592563,13.715575,13.837493,13.958347,14.078164,14.196969,14.314788,14.431645,14.547564,
	14.662566,14.776674,14.889906,15.002285,15.113827,15.224553,15.334479,15.443622,15.552000,15.659628,15.766520,15.872694,15.978161,16.082937,16.187035,16.290467,16.393247,16.495387,16.596898,16.697792,16.798080,16.897773,16.996881,17.095414,17.193383,17.290797,17.387665,17.483996,17.579799,17.675083,17.769857,17.864127,
	17.957903,18.051191,18.144000,18.236336,18.328208,18.419621,18.510582,18.601099,18.691178,18.780824,18.870045,18.958846,19.047232,19.135211,19.222786,19.309965,19.396752,19.483152,19.569171,19.654813,19.740084,19.824988,19.909530,19.993714,20.077546,20.161029,20.244167,20.326966,20.409428,20.491559,20.573362,20.654841,
	20.736000,20.816842,20.897372,20.977593,21.057508,21.137120,21.216434,21.295453,21.374180,21.452617,21.530769,21.608638,21.686228,21.763541,21.840580,21.917349,21.993849,22.070085,22.146058,22.221771,22.297227,22.372429,22.447378,22.522079,22.596532,22.670741,22.744708,22.818435,22.891924,22.965179,23.038200,23.110991,
	23.183553,23.255889,23.328000,23.399889,23.471558,23.543009,23.614244,23.685264,23.756072,23.826670,23.897059,23.967242,24.037219,24.106994,24.176567,24.245940,24.315115,24.384094,24.452879,24.521471,24.589871,24.658082,24.726104,24.793940,24.861591,24.929058,24.996343,25.063447,25.130372,25.197120,25.263691,25.330087,
	25.396310,25.462360,25.528239,25.593949,25.659491,25.724865,25.790074,25.855119,25.920000,25.984719,26.049278,26.113676,26.177917,26.242000,26.305927,26.369699,26.433317,26.496783,26.560096,26.623260,26.686273,26.749139,26.811856,26.874428,26.936854,26.999136,27.061274,27.123271,27.185125,27.246840,27.308415,27.369851,
	27.431150,27.492312,27.553338,27.614229,27.674987,27.735611,27.796103,27.856464,27.916694,27.976795,28.036767,28.096610,28.156327,28.215917,28.275382,28.334722,28.393937,28.453030,28.512000,28.570848,28.629576,28.688183,28.746671,28.805040,28.863290,28.921424,28.979441,29.037342,29.095128,29.152799,29.210357,29.267801,
	29.325132,29.382352,29.439461,29.496459,29.553347,29.610126,29.666796,29.723358,29.779813,29.836161,29.892402,29.948538,30.004569,30.060496,30.116319,30.172038,30.227655,30.283169,30.338582,30.393894,30.449106,30.504217,30.559229,30.614143,30.668958,30.723675,30.778295,30.832818,30.887245,30.941576,30.995812,31.049953,
	31.104000,31.157953,31.211813,31.265580,31.319255,31.372838,31.426330,31.479731,31.533041,31.586261,31.639392,31.692434,31.745387,31.798252,31.851029,31.903719,31.956322,32.008839,32.061269,32.113614,32.165874,32.218049,32.270140,32.322146,32.374070,32.425910,32.477667,32.529342,32.580935,32.632446,32.683876,32.735226,
	32.786495,32.837684,32.888793,32.939823,32.990774,33.041646,33.092441,33.143157,33.193796,33.244358,33.294843,33.345251,33.395584,33.445841,33.496022,33.546128,33.596160,33.646117,33.696000,33.745809,33.795545,33.845208,33.894798,33.944316,33.993761,34.043135,34.092437,34.141668,34.190828,34.239918,34.288937,34.337886,
	34.386766,34.435576,34.484317,34.532989,34.581593,34.630129,34.678597,34.726997,34.775329,34.823595,34.871794,34.919926,34.967992,35.015992,35.063926,35.111795,35.159599,35.207337,35.255012,35.302621,35.350167,35.397649,35.445067,35.492422,35.539713,35.586942,35.634109,35.681213,35.728254,35.775234,35.822153,35.869010,
	35.915806,35.962541,36.009215,36.055829,36.102382,36.148876,36.195310,36.241685,36.288000,36.334256,36.380454,36.426592,36.472673,36.518695,36.564660,36.610566,36.656416,36.702207,36.747942,36.793620,36.839242,36.884807,36.930315,36.975768,37.021165,37.066506,37.111792,37.157023,37.202199,37.247320,37.292386,37.337398,
	37.382356,37.427259,37.472109,37.516906,37.561649,37.606338,37.650975,37.695559,37.740090,37.784568,37.828995,37.873369,37.917691,37.961962,38.006181,38.050348,38.094464,38.138530,38.182544,38.226508,38.270421,38.314284,38.358097,38.401860,38.445573,38.489236,38.532850,38.576415,38.619930,38.663397,38.706814,38.750183,
	38.793504,38.836776,38.880000,38.923176,38.966304,39.009385,39.052418,39.095403,39.138342,39.181233,39.224078,39.266875,39.309626,39.352331,39.394989,39.437602,39.480168,39.522688,39.565163,39.607592,39.649976,39.692314,39.734608,39.776856,39.819060,39.861218,39.903333,39.945403,39.987428,40.029410,40.071348,40.113241,
	40.155091,40.196898,40.238661,40.280381,40.322057,40.363691,40.405281,40.446829,40.488334,40.529797,40.571217,40.612595,40.653931,40.695225,40.736478,40.777688,40.818857,40.859984,40.901070,40.942115,40.983118,41.024081,41.065003,41.105884,41.146724,41.187524,41.228284,41.269003,41.309682,41.350321,41.390921,41.431480,
	41.472000,41.512480,41.552921,41.593323,41.633685,41.674008,41.714292,41.754538,41.794744,41.834912,41.875042,41.915133,41.955185,41.995200,42.035176,42.075115,42.115015,42.154878,42.194703,42.234491,42.274241,42.313953,42.353629,42.393267,42.432869,42.472433,42.511961,42.551452,42.590906,42.630324,42.669705,42.709050,
	42.748359,42.787632,42.826869,42.866069,42.905234,42.944364,42.983457,43.022515,43.061538,43.100525,43.139478,43.178395,43.217277,43.256124,43.294936,43.333713,43.372456,43.411164,43.449838,43.488477,43.527082,43.565653,43.604189,43.642692,43.681160,43.719595,43.757996,43.796364,43.834697,43.872998,43.911265,43.949498,
	43.987699,44.025866,44.064000,44.102101,44.140169,44.178205,44.216208,44.254178,44.292115,44.330021,44.367893,44.405734,44.443542,44.481318,44.519062,44.556774,44.594454,44.632103,44.669719,44.707304,44.744857,44.782379,44.819870,44.857329,44.894757,44.932154,44.969519,45.006854,45.044158,45.081430,45.118672,45.155884,
	45.193064,45.230214,45.267334,45.304423,45.341482,45.378511,45.415509,45.452477,45.489415,45.526324,45.563202,45.600051,45.636869,45.673658,45.710418,45.747148,45.783848,45.820519,45.857161,45.893774,45.930357,45.966911,46.003436,46.039933,46.076400,46.112838,46.149248,46.185629,46.221981,46.258305,46.294600,46.330867,
	46.367106,46.403316,46.439498,46.475651,46.511777,46.547875,46.583944,46.619986,46.656000,46.691986,46.727945,46.763875,46.799778,46.835654,46.871502,46.907323,46.943117,46.978883,47.014622,47.050334,47.086018,47.121676,47.157307,47.192911,47.228488,47.264038,47.299561,47.335058,47.370529,47.405972,47.441390,47.476780,
	47.512145,47.547483,47.582795,47.618081,47.653340,47.688574,47.723781,47.758963,47.794118,47.829248,47.864352,47.899431,47.934483,47.969510,48.004512,48.039488,48.074438,48.109363,48.144263,48.179138,48.213987,48.248811,48.283610,48.318384,48.353133,48.387857,48.422556,48.457230,48.491880,48.526504,48.561104,48.595680,
	48.630231,48.664757,48.699259,48.733736,48.768189,48.802618,48.837022,48.871402,48.905758,48.940090,48.974398,49.008682,49.042942,49.077177,49.111389,49.145578,49.179742,49.213883,49.248000,49.282093,49.316163,49.350210,49.384233,49.418232,49.452208,49.486161,49.520090,49.553997,49.587880,49.621740,49.655577,49.689390,
	49.723181,49.756949,49.790694,49.824416,49.858115,49.891792,49.925446,49.959077,49.992686,50.026271,50.059835,50.093376,50.126894,50.160390,50.193864,50.227316,50.260745,50.294152,50.327536,50.360899,50.394240,50.427558,50.460855,50.494129,50.527382,50.560613,50.593822,50.627009,50.660174,50.693318,50.726440,50.759540,
	50.792619,50.825677,50.858713,50.891727,50.924720,50.957692,50.990642,51.023571,51.056479,51.089365,51.122231,51.155075,51.187899,51.220701,51.253482,51.286242,51.318982,51.351700,51.384398,51.417075,51.449731,51.482366,51.514981,51.547575,51.580149,51.612702,51.645234,51.677746,51.710238,51.742709,51.775159,51.807590,
	51.840000,51.872390,51.904760,51.937109,51.969438,52.001748,52.034037,52.066306,52.098555,52.130784,52.162994,52.195183,52.227353,52.259503,52.291633,52.323743,52.355834,52.387905,52.419956,52.451988,52.484000,52.515993,52.547966,52.579920,52.611854,52.643769,52.675665,52.707541,52.739398,52.771236,52.803054,52.834854,
	52.866634,52.898396,52.930138,52.961861,52.993565,53.025250,53.056917,53.088564,53.120193,53.151803,53.183393,53.214966,53.246519,53.278054,53.309570,53.341068,53.372547,53.404007,53.435449,53.466872,53.498277,53.529664,53.561032,53.592382,53.623713,53.655026,53.686321,53.717598,53.748856,53.780096,53.811318,53.842522,
	53.873708,53.904876,53.936026,53.967158,53.998272,54.029368,54.060446,54.091506,54.122549,54.153574,54.184581,54.215570,54.246541,54.277495,54.308431,54.339350,54.370251,54.401134,54.432000,54.462848,54.493679,54.524493,54.555289,54.586068,54.616829,54.647573,54.678300,54.709009,54.739702,54.770377,54.801035,54.831676,
	54.862299,54.892906,54.923495,54.954068,54.984623,55.015162,55.045683,55.076188,55.106676,55.137147,55.167601,55.198038,55.228459,55.258863,55.289250,55.319620,55.349974,55.380311,55.410631,55.440935,55.471222,55.501493,55.531747,55.561985,55.592207,55.622412,55.652600,55.682772,55.712928,55.743068,55.773191,55.803298,
	55.833389,55.863463,55.893522,55.923564,55.953590,55.983600,56.013594,56.043572,56.073533,56.103479,56.133409,56.163323,56.193221,56.223103,56.252969,56.282820,56.312654,56.342473,56.372276,56.402063,56.431834,56.461590,56.491330,56.521055,56.550764,56.580457,56.610134,56.639797,56.669443,56.699074,56.728690,56.758290
};


// Y = 0:1023; gain=8; A=max(4,0.8*sqrt(max((Y-64),0)*gain)); figure,hold on, plot(Y,A, 'r')
RK_F32 MotionDetectTable8[MOTION_DETECT_TALBE_LEN] = {
	4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,
	4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,4.000000,
	4.000000,4.000000,4.000000,4.409082,5.091169,5.692100,6.235383,6.734983,7.200000,7.636753,8.049845,8.442748,8.818163,9.178235,9.524705,9.859006,10.182338,10.495713,10.800000,11.095945,11.384200,11.665333,11.939849,12.208194,12.470766,12.727922,12.979985,13.227245,13.469967,13.708392,13.942740,14.173214,
	14.400000,14.623269,14.843180,15.059880,15.273506,15.484185,15.692036,15.897170,16.099689,16.299693,16.497273,16.692513,16.885497,17.076299,17.264993,17.451647,17.636326,17.819091,18.000000,18.179109,18.356470,18.532134,18.706149,18.878559,19.049409,19.218741,19.386593,19.553005,19.718012,19.881650,20.043952,20.204950,
	20.364675,20.523158,20.680426,20.836506,20.991427,21.145212,21.297887,21.449476,21.600000,21.749483,21.897945,22.045408,22.191890,22.337413,22.481993,22.625649,22.768399,22.910260,23.051247,23.191378,23.330667,23.469129,23.606779,23.743631,23.879698,24.014995,24.149534,24.283328,24.416388,24.548727,24.680357,24.811288,
	24.941532,25.071099,25.200000,25.328245,25.455844,25.582807,25.709142,25.834860,25.959969,26.084478,26.208396,26.331730,26.454489,26.576682,26.698315,26.819396,26.939933,27.059933,27.179404,27.298352,27.416783,27.534705,27.652125,27.769048,27.885480,28.001429,28.116899,28.231897,28.346428,28.460499,28.574114,28.687279,
	28.800000,28.912281,29.024128,29.135545,29.246538,29.357112,29.467270,29.577018,29.686361,29.795302,29.903846,30.011998,30.119761,30.227140,30.334139,30.440762,30.547013,30.652895,30.758413,30.863571,30.968371,31.072818,31.176915,31.280665,31.384072,31.487140,31.589872,31.692270,31.794339,31.896081,31.997500,32.098598,
	32.199379,32.299845,32.400000,32.499846,32.599386,32.698624,32.797561,32.896200,32.994545,33.092597,33.190360,33.287836,33.385027,33.481935,33.578565,33.674916,33.770993,33.866798,33.962332,34.057598,34.152599,34.247336,34.341811,34.436028,34.529987,34.623691,34.717143,34.810343,34.903295,34.996000,35.088460,35.180677,
	35.272652,35.364389,35.455888,35.547152,35.638182,35.728980,35.819548,35.909887,36.000000,36.089888,36.179552,36.268995,36.358218,36.447222,36.536010,36.624582,36.712940,36.801087,36.889023,36.976749,37.064269,37.151581,37.238690,37.325594,37.412297,37.498800,37.585103,37.671209,37.757119,37.842833,37.928354,38.013682,
	38.098819,38.183766,38.268525,38.353096,38.437482,38.521682,38.605699,38.689533,38.773187,38.856660,38.939954,39.023070,39.106010,39.188774,39.271364,39.353780,39.436024,39.518097,39.600000,39.681734,39.763300,39.844699,39.925931,40.006999,40.087903,40.168644,40.249224,40.329642,40.409900,40.489999,40.569940,40.649723,
	40.729351,40.808823,40.888140,40.967304,41.046315,41.125175,41.203883,41.282442,41.360851,41.439112,41.517225,41.595192,41.673013,41.750689,41.828220,41.905608,41.982854,42.059957,42.136920,42.213742,42.290424,42.366968,42.443374,42.519643,42.595774,42.671771,42.747632,42.823358,42.898951,42.974411,43.049739,43.124935,
	43.200000,43.274935,43.349740,43.424417,43.498966,43.573386,43.647680,43.721848,43.795890,43.869807,43.943600,44.017269,44.090815,44.164239,44.237541,44.310721,44.383781,44.456721,44.529541,44.602242,44.674825,44.747290,44.819639,44.891870,44.963986,45.035986,45.107871,45.179641,45.251298,45.322842,45.394273,45.465591,
	45.536798,45.607894,45.678879,45.749754,45.820519,45.891176,45.961723,46.032163,46.102495,46.172719,46.242837,46.312849,46.382755,46.452556,46.522253,46.591845,46.661333,46.730718,46.800000,46.869180,46.938257,47.007233,47.076109,47.144883,47.213557,47.282132,47.350607,47.418984,47.487261,47.555441,47.623524,47.691509,
	47.759397,47.827189,47.894885,47.962485,48.029991,48.097401,48.164717,48.231940,48.299068,48.366104,48.433047,48.499897,48.566655,48.633322,48.699897,48.766382,48.832776,48.899080,48.965294,49.031418,49.097454,49.163401,49.229260,49.295030,49.360713,49.426309,49.491818,49.557240,49.622576,49.687825,49.752990,49.818069,
	49.883063,49.947973,50.012798,50.077540,50.142198,50.206772,50.271264,50.335673,50.400000,50.464245,50.528408,50.592490,50.656490,50.720410,50.784250,50.848009,50.911688,50.975288,51.038809,51.102250,51.165613,51.228898,51.292105,51.355233,51.418285,51.481259,51.544156,51.606976,51.669720,51.732388,51.794980,51.857497,
	51.919938,51.982305,52.044596,52.106813,52.168956,52.231025,52.293021,52.354942,52.416791,52.478567,52.540270,52.601901,52.663460,52.724947,52.786362,52.847706,52.908978,52.970180,53.031312,53.092372,53.153363,53.214284,53.275135,53.335917,53.396629,53.457273,53.517847,53.578354,53.638792,53.699162,53.759464,53.819699,
	53.879866,53.939967,54.000000,54.059967,54.119867,54.179701,54.239469,54.299171,54.358808,54.418379,54.477885,54.537327,54.596703,54.656015,54.715263,54.774447,54.833566,54.892622,54.951615,55.010544,55.069411,55.128214,55.186955,55.245633,55.304249,55.362803,55.421296,55.479726,55.538095,55.596403,55.654649,55.712835,
	55.770960,55.829025,55.887029,55.944973,56.002857,56.060681,56.118446,56.176152,56.233798,56.291385,56.348913,56.406383,56.463794,56.521146,56.578441,56.635678,56.692857,56.749978,56.807042,56.864048,56.920998,56.977890,57.034726,57.091505,57.148228,57.204895,57.261505,57.318060,57.374559,57.431002,57.487390,57.543723,
	57.600000,57.656223,57.712390,57.768504,57.824562,57.880567,57.936517,57.992413,58.048256,58.104045,58.159780,58.215462,58.271091,58.326666,58.382189,58.437659,58.493077,58.548441,58.603754,58.659015,58.714223,58.769380,58.824485,58.879538,58.934540,58.989491,59.044390,59.099239,59.154036,59.208783,59.263479,59.318125,
	59.372721,59.427266,59.481762,59.536207,59.590603,59.644949,59.699246,59.753494,59.807692,59.861841,59.915941,59.969992,60.023995,60.077949,60.131855,60.185713,60.239522,60.293283,60.346997,60.400662,60.454280,60.507851,60.561374,60.614850,60.668278,60.721660,60.774995,60.828283,60.881524,60.934719,60.987868,61.040970,
	61.094026,61.147036,61.200000,61.252918,61.305791,61.358618,61.411400,61.464136,61.516827,61.569473,61.622074,61.674630,61.727142,61.779608,61.832031,61.884408,61.936742,61.989031,62.041277,62.093478,62.145635,62.197749,62.249819,62.301846,62.353829,62.405769,62.457666,62.509519,62.561330,62.613098,62.664823,62.716505,
	62.768145,62.819742,62.871297,62.922810,62.974280,63.025709,63.077096,63.128441,63.179744,63.231005,63.282225,63.333404,63.384541,63.435637,63.486692,63.537705,63.588678,63.639610,63.690502,63.741352,63.792163,63.842932,63.893662,63.944351,63.995000,64.045609,64.096178,64.146707,64.197196,64.247646,64.298056,64.348427,
	64.398758,64.449050,64.499302,64.549516,64.599690,64.649826,64.699923,64.749981,64.800000,64.849981,64.899923,64.949827,64.999692,65.049520,65.099309,65.149060,65.198773,65.248448,65.298086,65.347685,65.397248,65.446772,65.496259,65.545709,65.595122,65.644497,65.693835,65.743137,65.792401,65.841628,65.890819,65.939973,
	65.989090,66.038171,66.087215,66.136223,66.185195,66.234130,66.283030,66.331893,66.380720,66.429512,66.478267,66.526987,66.575671,66.624320,66.672933,66.721511,66.770053,66.818560,66.867032,66.915469,66.963871,67.012238,67.060570,67.108867,67.157129,67.205357,67.253550,67.301709,67.349833,67.397923,67.445978,67.494000,
	67.541987,67.589940,67.637859,67.685744,67.733596,67.781413,67.829197,67.876947,67.924664,67.972347,68.019997,68.067613,68.115197,68.162746,68.210263,68.257747,68.305197,68.352615,68.400000,68.447352,68.494671,68.541958,68.589212,68.636433,68.683623,68.730779,68.777903,68.824995,68.872055,68.919083,68.966079,69.013042,
	69.059974,69.106874,69.153742,69.200578,69.247383,69.294156,69.340897,69.387607,69.434285,69.480933,69.527548,69.574133,69.620687,69.667209,69.713700,69.760161,69.806590,69.852988,69.899356,69.945693,69.992000,70.038275,70.084520,70.130735,70.176919,70.223073,70.269197,70.315290,70.361353,70.407386,70.453389,70.499362,
	70.545305,70.591218,70.637101,70.682954,70.728778,70.774572,70.820336,70.866071,70.911776,70.957452,71.003099,71.048716,71.094304,71.139862,71.185392,71.230892,71.276364,71.321806,71.367219,71.412604,71.457960,71.503287,71.548585,71.593854,71.639095,71.684308,71.729492,71.774647,71.819774,71.864873,71.909944,71.954986,
	72.000000,72.044986,72.089944,72.134874,72.179776,72.224650,72.269496,72.314314,72.359104,72.403867,72.448602,72.493310,72.537990,72.582643,72.627268,72.671865,72.716436,72.760979,72.805494,72.849983,72.894444,72.938879,72.983286,73.027666,73.072019,73.116346,73.160645,73.204918,73.249164,73.293383,73.337576,73.381742,
	73.425881,73.469994,73.514080,73.558140,73.602174,73.646181,73.690162,73.734117,73.778046,73.821948,73.865824,73.909675,73.953499,73.997297,74.041070,74.084816,74.128537,74.172232,74.215901,74.259545,74.303163,74.346755,74.390322,74.433863,74.477379,74.520870,74.564335,74.607774,74.651189,74.694578,74.737942,74.781281,
	74.824595,74.867884,74.911147,74.954386,74.997600,75.040789,75.083953,75.127092,75.170207,75.213297,75.256362,75.299402,75.342418,75.385410,75.428377,75.471319,75.514237,75.557131,75.600000,75.642845,75.685666,75.728462,75.771235,75.813983,75.856707,75.899407,75.942083,75.984735,76.027363,76.069968,76.112548,76.155105,
	76.197638,76.240147,76.282632,76.325094,76.367532,76.409947,76.452338,76.494706,76.537050,76.579371,76.621668,76.663942,76.706193,76.748420,76.790624,76.832805,76.874963,76.917098,76.959210,77.001299,77.043364,77.085407,77.127427,77.169424,77.211398,77.253349,77.295278,77.337184,77.379067,77.420927,77.462765,77.504581,
	77.546373,77.588143,77.629891,77.671616,77.713319,77.755000,77.796658,77.838294,77.879908,77.921499,77.963068,78.004615,78.046140,78.087643,78.129124,78.170583,78.212020,78.253434,78.294827,78.336199,78.377548,78.418875,78.460181,78.501465,78.542727,78.583968,78.625187,78.666384,78.707560,78.748714,78.789847,78.830958
};

#endif


//////////////////////////////////////////////////////////////////////////
////---- LowLightTable: Revised by yousf 20160513
#if USE_LOW_LIGHT_ENHANCER == 1 // 1-use LowLightEnhancer
RK_U16 LowLightTable[LOW_LIGHT_TALBE_LEN] = {
    1,   2,   4,   7,   9,  11,  13,  14,  16,  18,  19,  21,  23,  24,  26,  28,  29,  31,  33,  34,  36,  37,  38,  40,  41,  43,  44,  46,  47,  49,  50,  51,
    53,  55,  56,  58,  59,  61,  62,  64,  65,  67,  68,  70,  71,  73,  74,  76,  78,  79,  81,  83,  84,  86,  88,  89,  91,  93,  94,  96,  98, 100, 101, 103,
    105, 107, 108, 110, 112, 113, 115, 116, 118, 119, 121, 122, 124, 125, 127, 128, 130, 132, 133, 135, 136, 138, 139, 141, 143, 144, 146, 147, 149, 150, 152, 153,
    155, 156, 157, 159, 160, 162, 163, 165, 166, 168, 169, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 186, 188, 189, 190, 192, 193, 194, 196, 197,
    198, 199, 201, 202, 203, 205, 206, 207, 208, 210, 211, 212, 214, 215, 216, 218, 219, 220, 221, 223, 224, 225, 226, 228, 229, 230, 231, 232, 234, 235, 236, 237,
    238, 240, 241, 242, 243, 244, 245, 246, 248, 249, 250, 252, 253, 254, 255, 257, 258, 259, 261, 262, 263, 265, 266, 267, 269, 270, 272, 273, 274, 276, 277, 279,
    280, 281, 283, 284, 285, 287, 288, 289, 290, 292, 293, 294, 295, 296, 298, 299, 300, 301, 303, 304, 305, 306, 308, 309, 310, 311, 312, 313, 315, 316, 317, 319,
    320, 322, 323, 324, 326, 327, 328, 329, 331, 332, 333, 334, 335, 337, 338, 339, 340, 341, 343, 344, 345, 346, 347, 349, 350, 351, 352, 353, 354, 356, 357, 358,
    359, 360, 361, 363, 364, 365, 366, 367, 369, 370, 371, 372, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 385, 386, 387, 388, 389, 390, 391, 392, 394, 395,
    396, 397, 398, 400, 401, 403, 404, 405, 406, 408, 409, 410, 411, 413, 414, 415, 416, 417, 418, 418, 419, 420, 421, 422, 423, 425, 426, 427, 428, 429, 430, 431,
    433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 446, 447, 448, 450, 451, 452, 453, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 467, 468,
    469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 496, 497, 498,
    499, 500, 501, 502, 503, 504, 505, 506, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529,
    529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559,
    559, 560, 561, 562, 563, 564, 565, 566, 567, 567, 568, 569, 570, 571, 572, 573, 574, 574, 575, 576, 577, 578, 579, 580, 580, 581, 582, 583, 584, 585, 586, 587,
    588, 589, 589, 590, 591, 592, 593, 594, 595, 595, 596, 597, 598, 599, 600, 601, 602, 603, 604, 604, 605, 606, 607, 608, 609, 610, 610, 611, 612, 613, 614, 615,
    616, 617, 617, 618, 619, 620, 621, 622, 623, 624, 624, 625, 626, 627, 628, 629, 630, 631, 632, 632, 633, 634, 635, 636, 637, 638, 639, 640, 640, 641, 642, 643,
    644, 645, 646, 647, 647, 648, 649, 650, 651, 652, 653, 654, 655, 656, 656, 657, 658, 659, 660, 661, 662, 662, 663, 664, 665, 666, 667, 668, 669, 670, 670, 671,
    672, 673, 674, 675, 676, 677, 677, 678, 679, 680, 681, 682, 682, 683, 684, 685, 686, 686, 687, 688, 689, 690, 691, 691, 692, 693, 694, 695, 695, 696, 697, 698,
    699, 700, 700, 701, 702, 703, 704, 705, 706, 706, 707, 708, 709, 710, 710, 711, 712, 713, 714, 715, 715, 716, 717, 718, 719, 719, 720, 721, 722, 723, 724, 724,
    725, 726, 727, 728, 728, 729, 730, 731, 731, 732, 733, 734, 735, 735, 736, 737, 738, 739, 739, 740, 741, 742, 743, 743, 744, 745, 746, 747, 747, 748, 749, 750,
    751, 751, 752, 753, 754, 754, 755, 756, 757, 757, 758, 759, 760, 761, 761, 762, 763, 764, 765, 765, 766, 767, 768, 768, 769, 770, 771, 771, 772, 773, 774, 774,
    775, 776, 777, 778, 778, 779, 780, 781, 782, 782, 783, 784, 785, 785, 786, 787, 788, 789, 789, 790, 791, 792, 793, 793, 794, 795, 796, 796, 797, 798, 799, 800,
    800, 801, 802, 803, 803, 804, 805, 806, 806, 807, 808, 809, 810, 810, 811, 812, 813, 813, 814, 815, 816, 816, 817, 818, 819, 819, 820, 821, 822, 822, 823, 824,
    825, 825, 826, 827, 828, 828, 829, 830, 831, 831, 832, 833, 834, 834, 835, 836, 837, 837, 838, 839, 840, 840, 841, 842, 843, 843, 844, 845, 846, 847, 847, 848,
    849, 850, 850, 851, 852, 853, 853, 854, 855, 856, 856, 857, 858, 859, 859, 860, 861, 862, 862, 863, 864, 865, 866, 866, 867, 868, 869, 870, 870, 871, 872, 873,
    874, 874, 875, 876, 877, 878, 878, 879, 880, 881, 881, 882, 883, 884, 884, 885, 886, 886, 887, 888, 889, 889, 890, 891, 892, 892, 893, 894, 894, 895, 896, 896,
    897, 898, 899, 899, 900, 901, 901, 902, 903, 903, 904, 905, 906, 906, 907, 908, 908, 909, 910, 910, 911, 912, 912, 913, 914, 915, 916, 916, 917, 918, 918, 919,
    920, 921, 921, 922, 923, 924, 924, 925, 926, 926, 927, 928, 929, 929, 930, 931, 931, 932, 933, 933, 934, 935, 935, 936, 937, 937, 938, 939, 940, 940, 941, 941,
    942, 943, 943, 944, 945, 945, 946, 946, 947, 948, 948, 949, 949, 950, 951, 951, 952, 952, 953, 954, 954, 955, 955, 956, 957, 957, 958, 958, 958, 958, 958, 961,
    961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961,
    961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961, 961
};

RK_F32 LowLightGainTable[LOW_LIGHT_TALBE_LEN] = {
    1.00,1.00,1.33,1.75,1.80,1.83,1.86,1.75,1.78,1.80,1.73,1.75,1.77,1.71,1.73,1.75,1.71,1.72,1.74,1.70,1.71,1.68,1.65,1.67,1.64,1.65,1.63,1.64,1.62,1.63,1.61,1.59,
    1.61,1.62,1.60,1.61,1.59,1.61,1.59,1.60,1.59,1.60,1.58,1.59,1.58,1.59,1.57,1.58,1.59,1.58,1.59,1.60,1.58,1.59,1.60,1.59,1.60,1.60,1.59,1.60,1.61,1.61,1.60,1.61,
    1.62,1.62,1.61,1.62,1.62,1.61,1.62,1.61,1.62,1.61,1.61,1.61,1.61,1.60,1.61,1.60,1.60,1.61,1.60,1.61,1.60,1.60,1.60,1.60,1.61,1.60,1.60,1.60,1.60,1.60,1.60,1.59,
    1.60,1.59,1.59,1.59,1.58,1.59,1.58,1.59,1.58,1.58,1.58,1.57,1.58,1.57,1.58,1.57,1.57,1.57,1.57,1.56,1.56,1.56,1.55,1.55,1.55,1.55,1.54,1.55,1.54,1.54,1.54,1.54,
    1.53,1.53,1.53,1.53,1.53,1.53,1.53,1.52,1.52,1.52,1.52,1.51,1.52,1.51,1.51,1.51,1.51,1.51,1.50,1.51,1.50,1.50,1.50,1.50,1.50,1.49,1.49,1.49,1.49,1.49,1.48,1.48,
    1.48,1.48,1.48,1.48,1.47,1.47,1.47,1.46,1.47,1.46,1.46,1.47,1.46,1.46,1.46,1.46,1.46,1.46,1.46,1.46,1.45,1.46,1.45,1.45,1.45,1.45,1.45,1.45,1.45,1.45,1.45,1.45,
    1.45,1.45,1.45,1.45,1.45,1.45,1.45,1.45,1.44,1.45,1.44,1.44,1.44,1.44,1.44,1.44,1.44,1.43,1.44,1.43,1.43,1.43,1.43,1.43,1.43,1.43,1.42,1.42,1.43,1.42,1.42,1.42,
    1.42,1.42,1.42,1.42,1.42,1.42,1.42,1.42,1.42,1.42,1.42,1.42,1.41,1.42,1.41,1.41,1.41,1.41,1.41,1.41,1.41,1.41,1.40,1.41,1.41,1.40,1.40,1.40,1.40,1.40,1.40,1.40,
    1.40,1.40,1.39,1.40,1.39,1.39,1.39,1.39,1.39,1.39,1.39,1.39,1.39,1.39,1.39,1.39,1.38,1.38,1.38,1.38,1.38,1.38,1.38,1.38,1.38,1.38,1.37,1.37,1.37,1.37,1.37,1.37,
    1.37,1.37,1.37,1.37,1.37,1.37,1.37,1.37,1.37,1.37,1.37,1.37,1.37,1.37,1.37,1.37,1.36,1.36,1.36,1.36,1.36,1.35,1.35,1.35,1.35,1.35,1.35,1.35,1.35,1.35,1.35,1.35,
    1.35,1.35,1.35,1.35,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.34,1.33,1.33,1.33,1.33,1.33,1.33,1.33,1.33,1.33,
    1.33,1.33,1.33,1.33,1.32,1.32,1.32,1.32,1.32,1.32,1.32,1.32,1.32,1.32,1.32,1.32,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.31,1.30,1.30,1.30,1.30,1.30,1.30,1.30,
    1.30,1.30,1.29,1.29,1.29,1.29,1.29,1.29,1.29,1.29,1.29,1.29,1.28,1.28,1.28,1.28,1.28,1.28,1.28,1.28,1.28,1.28,1.28,1.28,1.28,1.28,1.27,1.27,1.27,1.27,1.27,1.27,
    1.27,1.27,1.27,1.27,1.27,1.27,1.26,1.26,1.26,1.26,1.26,1.26,1.26,1.26,1.26,1.26,1.26,1.26,1.26,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,1.25,
    1.24,1.24,1.24,1.24,1.24,1.24,1.24,1.24,1.24,1.24,1.24,1.24,1.24,1.24,1.24,1.23,1.23,1.23,1.23,1.23,1.23,1.23,1.23,1.23,1.23,1.23,1.23,1.22,1.22,1.22,1.22,1.22,
    1.22,1.22,1.22,1.22,1.22,1.22,1.22,1.22,1.22,1.21,1.21,1.21,1.21,1.21,1.21,1.21,1.21,1.21,1.21,1.21,1.21,1.21,1.21,1.21,1.21,1.21,1.20,1.20,1.20,1.20,1.20,1.20,
    1.20,1.20,1.20,1.20,1.20,1.20,1.20,1.20,1.20,1.20,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.19,1.18,1.18,1.18,1.18,
    1.18,1.18,1.18,1.18,1.18,1.18,1.18,1.18,1.18,1.18,1.18,1.18,1.18,1.18,1.17,1.17,1.17,1.17,1.17,1.17,1.17,1.17,1.17,1.17,1.17,1.17,1.17,1.17,1.17,1.17,1.17,1.16,
    1.16,1.16,1.16,1.16,1.16,1.16,1.16,1.16,1.16,1.16,1.16,1.16,1.16,1.16,1.16,1.16,1.16,1.15,1.15,1.15,1.15,1.15,1.15,1.15,1.15,1.15,1.15,1.15,1.15,1.15,1.15,1.15,
    1.15,1.15,1.15,1.15,1.15,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.14,1.13,1.13,1.13,1.13,1.13,1.13,1.13,
    1.13,1.13,1.13,1.13,1.13,1.13,1.13,1.13,1.13,1.13,1.13,1.13,1.13,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,1.12,
    1.12,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.11,1.10,1.10,1.10,1.10,1.10,1.10,1.10,1.10,1.10,
    1.10,1.10,1.10,1.10,1.10,1.10,1.10,1.10,1.10,1.10,1.10,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,1.09,
    1.09,1.09,1.09,1.09,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.08,1.07,1.07,1.07,1.07,1.07,1.07,1.07,
    1.07,1.07,1.07,1.07,1.07,1.07,1.07,1.07,1.07,1.07,1.07,1.07,1.07,1.07,1.07,1.07,1.07,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,
    1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.06,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,
    1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.05,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,1.04,
    1.04,1.04,1.04,1.04,1.04,1.04,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,1.03,
    1.03,1.03,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.02,1.01,
    1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.01,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,1.00,
    1.00,1.00,1.00,1.00,1.00,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.99,0.98,0.98,0.98,0.98,0.98,0.98,0.98,0.98,0.98,0.98,0.97,0.97,0.97,0.97,0.97,0.97,0.97,
    0.97,0.97,0.97,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.96,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.95,0.94,0.94,0.94,0.94,0.94,0.94,0.94,0.94
};

// NewNonLinearGain 
RK_F32 LowLightGainTable2[3][LOW_LIGHT_TALBE_LEN] =
{ 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 0.00 , 2.97 , 2.99 , 2.99 , 2.99 , 2.99 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 3.00 , 2.97 , 2.97 , 2.97 , 2.97 , 2.98 , 2.98 , 2.98 , 2.98 , 2.98 , 2.98 , 2.98 , 2.98 , 2.98 , 2.98 , 2.98 , 2.98 , 2.96 , 2.96 , 2.96 , 2.96 , 2.97 , 2.97 , 2.97 , 2.97 , 2.97 , 2.97 , 2.95 , 2.95 , 2.95 , 2.95 , 2.96 , 2.96 , 2.96 , 2.96 , 2.94 , 2.94 , 2.95 , 2.95 , 2.95 , 2.95 , 2.94 , 2.94 , 2.94 , 2.94 , 2.94 , 2.94 , 2.93 , 2.93 , 2.93 , 2.93 , 2.93 , 2.92 , 2.92 , 2.92 , 2.92 , 2.91 , 2.91 , 2.92 , 2.92 , 2.91 , 2.91 , 2.91 , 2.91 , 2.90 , 2.90 , 2.90 , 2.89 , 2.89 , 2.90 , 2.90 , 2.89 , 2.89 , 2.89 , 2.88 , 2.88 , 2.88 , 2.88 , 2.88 , 2.88 , 2.87 , 2.87 , 2.87 , 2.87 , 2.87 , 2.86 , 2.86 , 2.85 , 2.86 , 2.86 , 2.85 , 2.85 , 2.84 , 2.85 , 2.84 , 2.84 , 2.84 , 2.84 , 2.84 , 2.83 , 2.83 , 2.83 , 2.83 , 2.82 , 2.82 , 2.82 , 2.82 , 2.81 , 2.81 , 2.81 , 2.80 , 2.80 , 2.80 , 2.80 , 2.79 , 2.80 , 2.79 , 2.79 , 2.79 , 2.78 , 2.78 , 2.78 , 2.77 , 2.77 , 2.77 , 2.77 , 2.77 , 2.76 , 2.76 , 2.76 , 2.75 , 2.75 , 2.75 , 2.75 , 2.74 , 2.74 , 2.74 , 2.74 , 2.73 , 2.73 , 2.73 , 2.72 , 2.72 , 2.72 , 2.72 , 2.71 , 2.71 , 2.71 , 2.70 , 2.70 , 2.70 , 2.70 , 2.69 , 2.69 , 2.69 , 2.69 , 2.68 , 2.68 , 2.68 , 2.67 , 2.67 , 2.67 , 2.66 , 2.66 , 2.66 , 2.66 , 2.66 , 2.65 , 2.65 , 2.65 , 2.64 , 2.64 , 2.64 , 2.63 , 2.63 , 2.63 , 2.62 , 2.62 , 2.62 , 2.62 , 2.61 , 2.61 , 2.61 , 2.60 , 2.60 , 2.59 , 2.59 , 2.59 , 2.59 , 2.58 , 2.58 , 2.58 , 2.58 , 2.57 , 2.57 , 2.56 , 2.56 , 2.56 , 2.56 , 2.55 , 2.55 , 2.55 , 2.54 , 2.54 , 2.54 , 2.53 , 2.53 , 2.53 , 2.53 , 2.52 , 2.52 , 2.52 , 2.51 , 2.51 , 2.51 , 2.50 , 2.50 , 2.50 , 2.49 , 2.49 , 2.49 , 2.48 , 2.48 , 2.48 , 2.48 , 2.47 , 2.47 , 2.47 , 2.46 , 2.46 , 2.46 , 2.45 , 2.45 , 2.44 , 2.44 , 2.44 , 2.44 , 2.43 , 2.43 , 2.43 , 2.42 , 2.42 , 2.42 , 2.41 , 2.41 , 2.41 , 2.40 , 2.40 , 2.40 , 2.40 , 2.39 , 2.39 , 2.38 , 2.38 , 2.38 , 2.37 , 2.37 , 2.37 , 2.37 , 2.36 , 2.36 , 2.36 , 2.35 , 2.35 , 2.35 , 2.34 , 2.34 , 2.34 , 2.33 , 2.33 , 2.33 , 2.32 , 2.32 , 2.32 , 2.32 , 2.31 , 2.31 , 2.30 , 2.30 , 2.30 , 2.29 , 2.29 , 2.29 , 2.28 , 2.28 , 2.28 , 2.28 , 2.27 , 2.27 , 2.27 , 2.26 , 2.26 , 2.26 , 2.25 , 2.25 , 2.25 , 2.24 , 2.24 , 2.24 , 2.24 , 2.23 , 2.23 , 2.22 , 2.22 , 2.22 , 2.21 , 2.21 , 2.21 , 2.21 , 2.20 , 2.20 , 2.20 , 2.19 , 2.19 , 2.19 , 2.18 , 2.18 , 2.18 , 2.17 , 2.17 , 2.17 , 2.16 , 2.16 , 2.16 , 2.16 , 2.15 , 2.15 , 2.15 , 2.14 , 2.14 , 2.14 , 2.13 , 2.13 , 2.13 , 2.12 , 2.12 , 2.12 , 2.11 , 2.11 , 2.11 , 2.11 , 2.10 , 2.10 , 2.10 , 2.09 , 2.09 , 2.09 , 2.08 , 2.08 , 2.08 , 2.07 , 2.07 , 2.07 , 2.07 , 2.06 , 2.06 , 2.06 , 2.05 , 2.05 , 2.05 , 2.05 , 2.04 , 2.04 , 2.03 , 2.03 , 2.03 , 2.03 , 2.02 , 2.02 , 2.02 , 2.01 , 2.01 , 2.01 , 2.01 , 2.00 , 2.00 , 2.00 , 2.00 , 1.99 , 1.99 , 1.99 , 1.98 , 1.98 , 1.98 , 1.97 , 1.97 , 1.97 , 1.96 , 1.96 , 1.96 , 1.96 , 1.95 , 1.95 , 1.95 , 1.94 , 1.94 , 1.94 , 1.94 , 1.93 , 1.93 , 1.93 , 1.92 , 1.92 , 1.92 , 1.92 , 1.91 , 1.91 , 1.91 , 1.91 , 1.90 , 1.90 , 1.90 , 1.90 , 1.89 , 1.89 , 1.89 , 1.88 , 1.88 , 1.88 , 1.87 , 1.87 , 1.87 , 1.87 , 1.86 , 1.86 , 1.86 , 1.86 , 1.85 , 1.85 , 1.85 , 1.85 , 1.84 , 1.84 , 1.84 , 1.83 , 1.83 , 1.83 , 1.83 , 1.82 , 1.82 , 1.82 , 1.82 , 1.81 , 1.81 , 1.81 , 1.80 , 1.80 , 1.80 , 1.80 , 1.79 , 1.79 , 1.79 , 1.79 , 1.78 , 1.78 , 1.78 , 1.78 , 1.77 , 1.77 , 1.77 , 1.77 , 1.76 , 1.76 , 1.76 , 1.76 , 1.75 , 1.75 , 1.75 , 1.75 , 1.74 , 1.74 , 1.74 , 1.73 , 1.73 , 1.73 , 1.73 , 1.73 , 1.72 , 1.72 , 1.72 , 1.72 , 1.71 , 1.71 , 1.71 , 1.71 , 1.70 , 1.70 , 1.70 , 1.70 , 1.69 , 1.69 , 1.69 , 1.69 , 1.68 , 1.68 , 1.68 , 1.68 , 1.67 , 1.67 , 1.67 , 1.67 , 1.67 , 1.66 , 1.66 , 1.66 , 1.65 , 1.65 , 1.65 , 1.65 , 1.65 , 1.64 , 1.64 , 1.64 , 1.64 , 1.64 , 1.63 , 1.63 , 1.63 , 1.63 , 1.62 , 1.62 , 1.62 , 1.62 , 1.61 , 1.61 , 1.61 , 1.61 , 1.60 , 1.60 , 1.60 , 1.60 , 1.60 , 1.59 , 1.59 , 1.59 , 1.59 , 1.58 , 1.58 , 1.58 , 1.58 , 1.58 , 1.57 , 1.57 , 1.57 , 1.57 , 1.57 , 1.56 , 1.56 , 1.56 , 1.56 , 1.55 , 1.55 , 1.55 , 1.55 , 1.54 , 1.54 , 1.54 , 1.54 , 1.54 , 1.54 , 1.53 , 1.53 , 1.53 , 1.53 , 1.52 , 1.52 , 1.52 , 1.52 , 1.52 , 1.51 , 1.51 , 1.51 , 1.51 , 1.50 , 1.50 , 1.50 , 1.50 , 1.50 , 1.50 , 1.49 , 1.49 , 1.49 , 1.49 , 1.49 , 1.48 , 1.48 , 1.48 , 1.48 , 1.48 , 1.47 , 1.47 , 1.47 , 1.47 , 1.47 , 1.46 , 1.46 , 1.46 , 1.46 , 1.46 , 1.45 , 1.45 , 1.45 , 1.45 , 1.45 , 1.44 , 1.44 , 1.44 , 1.44 , 1.44 , 1.43 , 1.43 , 1.43 , 1.43 , 1.43 , 1.43 , 1.42 , 1.42 , 1.42 , 1.42 , 1.42 , 1.41 , 1.41 , 1.41 , 1.41 , 1.41 , 1.40 , 1.40 , 1.40 , 1.40 , 1.40 , 1.40 , 1.39 , 1.39 , 1.39 , 1.39 , 1.39 , 1.38 , 1.38 , 1.38 , 1.38 , 1.38 , 1.38 , 1.37 , 1.37 , 1.37 , 1.37 , 1.37 , 1.37 , 1.36 , 1.36 , 1.36 , 1.36 , 1.36 , 1.36 , 1.35 , 1.35 , 1.35 , 1.35 , 1.35 , 1.34 , 1.34 , 1.34 , 1.34 , 1.34 , 1.34 , 1.33 , 1.33 , 1.33 , 1.33 , 1.33 , 1.33 , 1.32 , 1.32 , 1.32 , 1.32 , 1.32 , 1.32 , 1.31 , 1.31 , 1.31 , 1.31 , 1.31 , 1.31 , 1.30 , 1.30 , 1.30 , 1.30 , 1.30 , 1.30 , 1.29 , 1.29 , 1.29 , 1.29 , 1.29 , 1.29 , 1.28 , 1.28 , 1.28 , 1.28 , 1.28 , 1.28 , 1.28 , 1.27 , 1.27 , 1.27 , 1.27 , 1.27 , 1.27 , 1.26 , 1.26 , 1.26 , 1.26 , 1.26 , 1.26 , 1.26 , 1.25 , 1.25 , 1.25 , 1.25 , 1.25 , 1.25 , 1.24 , 1.24 , 1.24 , 1.24 , 1.24 , 1.24 , 1.24 , 1.23 , 1.23 , 1.23 , 1.23 , 1.23 , 1.23 , 1.23 , 1.22 , 1.22 , 1.22 , 1.22 , 1.22 , 1.22 , 1.21 , 1.21 , 1.21 , 1.21 , 1.21 , 1.21 , 1.21 , 1.21 , 1.20 , 1.20 , 1.20 , 1.20 , 1.20 , 1.20 , 1.19 , 1.19 , 1.19 , 1.19 , 1.19 , 1.19 , 1.19 , 1.19 , 1.18 , 1.18 , 1.18 , 1.18 , 1.18 , 1.18 , 1.18 , 1.17 , 1.17 , 1.17 , 1.17 , 1.17 , 1.17 , 1.17 , 1.16 , 1.16 , 1.16 , 1.16 , 1.16 , 1.16 , 1.16 , 1.16 , 1.15 , 1.15 , 1.15 , 1.15 , 1.15 , 1.15 , 1.15 , 1.14 , 1.14 , 1.14 , 1.14 , 1.14 , 1.14 , 1.14 , 1.14 , 1.13 , 1.13 , 1.13 , 1.13 , 1.13 , 1.13 , 1.13 , 1.13 , 1.12 , 1.12 , 1.12 , 1.12 , 1.12 , 1.12 , 1.12 , 1.12 , 1.11 , 1.11 , 1.11 , 1.11 , 1.11 , 1.11 , 1.11 , 1.11 , 1.10 , 1.10 , 1.10 , 1.10 , 1.10 , 1.10 , 1.10 , 1.10 , 1.10 , 1.09 , 1.09 , 1.09 , 1.09 , 1.09 , 1.09 , 1.09 , 1.09 , 1.08 , 1.08 , 1.08 , 1.08 , 1.08 , 1.08 , 1.08 , 1.08 , 1.07 , 1.07 , 1.07 , 1.07 , 1.07 , 1.07 , 1.07 , 1.07 , 1.07 , 1.06 , 1.06 , 1.06 , 1.06 , 1.06 , 1.06 , 1.06 , 1.06 , 1.06 , 1.05 , 1.05 , 1.05 , 1.05 , 1.05 , 1.05 , 1.05 , 1.05 , 1.05 , 1.04 , 1.04 , 1.04 , 1.04 , 1.04 , 1.04 , 1.04 , 1.04 , 1.04 , 1.03 , 1.03 , 1.03 , 1.03 , 1.03 , 1.03 , 1.03 , 1.03 , 1.03 , 1.02 , 1.02 , 1.02 , 1.02 , 1.02 , 1.02 , 1.02 , 1.02 , 1.02 , 1.02 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.94 , 0.94 , 0.94 , 0.94 , 0.94 , 0.94 , 0.94 , 0.94 , 0.94 , 0.94 , 0.94 , 0.00 , 4.95 , 4.98 , 4.98 , 4.99 , 4.99 , 4.99 , 4.99 , 4.99 , 4.99 , 5.00 , 5.00 , 5.00 , 5.00 , 5.00 , 5.00 , 5.00 , 5.00 , 5.00 , 5.00 , 5.00 , 5.00 , 5.00 , 4.95 , 4.96 , 4.96 , 4.96 , 4.96 , 4.96 , 4.96 , 4.97 , 4.97 , 4.97 , 4.94 , 4.94 , 4.94 , 4.94 , 4.94 , 4.95 , 4.92 , 4.92 , 4.93 , 4.93 , 4.91 , 4.91 , 4.91 , 4.91 , 4.89 , 4.89 , 4.90 , 4.88 , 4.88 , 4.88 , 4.87 , 4.87 , 4.87 , 4.86 , 4.86 , 4.84 , 4.85 , 4.85 , 4.84 , 4.84 , 4.82 , 4.83 , 4.81 , 4.82 , 4.81 , 4.79 , 4.80 , 4.79 , 4.79 , 4.78 , 4.77 , 4.77 , 4.76 , 4.75 , 4.75 , 4.74 , 4.73 , 4.72 , 4.73 , 4.72 , 4.71 , 4.70 , 4.69 , 4.69 , 4.68 , 4.68 , 4.67 , 4.67 , 4.66 , 4.65 , 4.64 , 4.64 , 4.63 , 4.62 , 4.62 , 4.60 , 4.60 , 4.59 , 4.58 , 4.58 , 4.57 , 4.56 , 4.55 , 4.55 , 4.54 , 4.53 , 4.52 , 4.52 , 4.50 , 4.50 , 4.50 , 4.48 , 4.48 , 4.47 , 4.46 , 4.45 , 4.45 , 4.43 , 4.43 , 4.42 , 4.41 , 4.40 , 4.39 , 4.39 , 4.38 , 4.37 , 4.36 , 4.35 , 4.34 , 4.34 , 4.33 , 4.32 , 4.31 , 4.30 , 4.29 , 4.28 , 4.28 , 4.27 , 4.26 , 4.25 , 4.24 , 4.24 , 4.23 , 4.22 , 4.21 , 4.20 , 4.19 , 4.18 , 4.17 , 4.16 , 4.16 , 4.15 , 4.14 , 4.13 , 4.12 , 4.11 , 4.10 , 4.09 , 4.09 , 4.07 , 4.07 , 4.06 , 4.05 , 4.04 , 4.03 , 4.02 , 4.01 , 4.01 , 3.99 , 3.99 , 3.98 , 3.97 , 3.96 , 3.95 , 3.94 , 3.93 , 3.92 , 3.92 , 3.91 , 3.90 , 3.89 , 3.88 , 3.87 , 3.86 , 3.85 , 3.85 , 3.84 , 3.83 , 3.82 , 3.81 , 3.80 , 3.79 , 3.78 , 3.77 , 3.76 , 3.75 , 3.74 , 3.73 , 3.73 , 3.72 , 3.71 , 3.70 , 3.69 , 3.68 , 3.68 , 3.67 , 3.66 , 3.65 , 3.64 , 3.63 , 3.62 , 3.61 , 3.60 , 3.60 , 3.59 , 3.58 , 3.57 , 3.56 , 3.55 , 3.54 , 3.54 , 3.53 , 3.52 , 3.51 , 3.50 , 3.50 , 3.48 , 3.48 , 3.47 , 3.46 , 3.45 , 3.44 , 3.43 , 3.43 , 3.42 , 3.41 , 3.40 , 3.39 , 3.39 , 3.38 , 3.37 , 3.36 , 3.35 , 3.35 , 3.34 , 3.33 , 3.32 , 3.31 , 3.30 , 3.29 , 3.29 , 3.28 , 3.27 , 3.26 , 3.25 , 3.25 , 3.24 , 3.23 , 3.22 , 3.21 , 3.21 , 3.20 , 3.19 , 3.18 , 3.18 , 3.17 , 3.16 , 3.15 , 3.14 , 3.14 , 3.13 , 3.12 , 3.11 , 3.10 , 3.10 , 3.09 , 3.08 , 3.07 , 3.07 , 3.06 , 3.05 , 3.05 , 3.04 , 3.03 , 3.02 , 3.02 , 3.01 , 3.00 , 3.00 , 2.99 , 2.98 , 2.97 , 2.97 , 2.96 , 2.95 , 2.95 , 2.94 , 2.93 , 2.92 , 2.92 , 2.91 , 2.90 , 2.89 , 2.89 , 2.88 , 2.87 , 2.87 , 2.86 , 2.86 , 2.85 , 2.84 , 2.83 , 2.83 , 2.82 , 2.81 , 2.81 , 2.80 , 2.79 , 2.79 , 2.78 , 2.77 , 2.77 , 2.76 , 2.75 , 2.75 , 2.74 , 2.74 , 2.73 , 2.72 , 2.71 , 2.71 , 2.70 , 2.70 , 2.69 , 2.68 , 2.68 , 2.67 , 2.66 , 2.66 , 2.65 , 2.65 , 2.64 , 2.63 , 2.63 , 2.62 , 2.61 , 2.61 , 2.60 , 2.60 , 2.59 , 2.59 , 2.58 , 2.57 , 2.57 , 2.56 , 2.56 , 2.55 , 2.54 , 2.54 , 2.53 , 2.53 , 2.52 , 2.51 , 2.51 , 2.50 , 2.50 , 2.49 , 2.49 , 2.48 , 2.48 , 2.47 , 2.47 , 2.46 , 2.45 , 2.45 , 2.44 , 2.44 , 2.43 , 2.43 , 2.42 , 2.42 , 2.41 , 2.41 , 2.40 , 2.40 , 2.39 , 2.38 , 2.38 , 2.37 , 2.37 , 2.36 , 2.36 , 2.35 , 2.35 , 2.34 , 2.34 , 2.33 , 2.33 , 2.32 , 2.32 , 2.31 , 2.31 , 2.30 , 2.30 , 2.29 , 2.29 , 2.28 , 2.28 , 2.27 , 2.27 , 2.26 , 2.26 , 2.25 , 2.25 , 2.24 , 2.24 , 2.23 , 2.23 , 2.22 , 2.22 , 2.22 , 2.21 , 2.20 , 2.20 , 2.20 , 2.19 , 2.19 , 2.18 , 2.18 , 2.17 , 2.17 , 2.16 , 2.16 , 2.16 , 2.15 , 2.15 , 2.14 , 2.14 , 2.13 , 2.13 , 2.12 , 2.12 , 2.12 , 2.11 , 2.11 , 2.10 , 2.10 , 2.09 , 2.09 , 2.09 , 2.08 , 2.08 , 2.07 , 2.07 , 2.07 , 2.06 , 2.06 , 2.05 , 2.05 , 2.05 , 2.04 , 2.04 , 2.03 , 2.03 , 2.02 , 2.02 , 2.02 , 2.01 , 2.01 , 2.00 , 2.00 , 2.00 , 1.99 , 1.99 , 1.99 , 1.98 , 1.98 , 1.97 , 1.97 , 1.96 , 1.96 , 1.96 , 1.95 , 1.95 , 1.95 , 1.94 , 1.94 , 1.93 , 1.93 , 1.93 , 1.92 , 1.92 , 1.92 , 1.91 , 1.91 , 1.91 , 1.90 , 1.90 , 1.90 , 1.89 , 1.89 , 1.88 , 1.88 , 1.88 , 1.87 , 1.87 , 1.87 , 1.86 , 1.86 , 1.86 , 1.85 , 1.85 , 1.85 , 1.84 , 1.84 , 1.84 , 1.83 , 1.83 , 1.83 , 1.82 , 1.82 , 1.82 , 1.81 , 1.81 , 1.81 , 1.80 , 1.80 , 1.80 , 1.79 , 1.79 , 1.79 , 1.78 , 1.78 , 1.78 , 1.77 , 1.77 , 1.77 , 1.76 , 1.76 , 1.76 , 1.76 , 1.75 , 1.75 , 1.75 , 1.74 , 1.74 , 1.74 , 1.73 , 1.73 , 1.73 , 1.73 , 1.72 , 1.72 , 1.72 , 1.71 , 1.71 , 1.71 , 1.70 , 1.70 , 1.70 , 1.70 , 1.69 , 1.69 , 1.69 , 1.68 , 1.68 , 1.68 , 1.68 , 1.67 , 1.67 , 1.67 , 1.66 , 1.66 , 1.66 , 1.66 , 1.65 , 1.65 , 1.65 , 1.64 , 1.64 , 1.64 , 1.64 , 1.63 , 1.63 , 1.63 , 1.63 , 1.62 , 1.62 , 1.62 , 1.61 , 1.61 , 1.61 , 1.61 , 1.60 , 1.60 , 1.60 , 1.60 , 1.59 , 1.59 , 1.59 , 1.59 , 1.58 , 1.58 , 1.58 , 1.58 , 1.57 , 1.57 , 1.57 , 1.57 , 1.56 , 1.56 , 1.56 , 1.56 , 1.55 , 1.55 , 1.55 , 1.55 , 1.54 , 1.54 , 1.54 , 1.54 , 1.53 , 1.53 , 1.53 , 1.53 , 1.52 , 1.52 , 1.52 , 1.52 , 1.51 , 1.51 , 1.51 , 1.51 , 1.50 , 1.50 , 1.50 , 1.50 , 1.50 , 1.49 , 1.49 , 1.49 , 1.49 , 1.49 , 1.48 , 1.48 , 1.48 , 1.48 , 1.47 , 1.47 , 1.47 , 1.47 , 1.46 , 1.46 , 1.46 , 1.46 , 1.46 , 1.45 , 1.45 , 1.45 , 1.45 , 1.44 , 1.44 , 1.44 , 1.44 , 1.44 , 1.43 , 1.43 , 1.43 , 1.43 , 1.43 , 1.42 , 1.42 , 1.42 , 1.42 , 1.42 , 1.41 , 1.41 , 1.41 , 1.41 , 1.40 , 1.40 , 1.40 , 1.40 , 1.40 , 1.40 , 1.39 , 1.39 , 1.39 , 1.39 , 1.39 , 1.38 , 1.38 , 1.38 , 1.38 , 1.38 , 1.37 , 1.37 , 1.37 , 1.37 , 1.37 , 1.36 , 1.36 , 1.36 , 1.36 , 1.36 , 1.35 , 1.35 , 1.35 , 1.35 , 1.35 , 1.35 , 1.34 , 1.34 , 1.34 , 1.34 , 1.34 , 1.33 , 1.33 , 1.33 , 1.33 , 1.33 , 1.32 , 1.32 , 1.32 , 1.32 , 1.32 , 1.32 , 1.31 , 1.31 , 1.31 , 1.31 , 1.31 , 1.30 , 1.30 , 1.30 , 1.30 , 1.30 , 1.30 , 1.29 , 1.29 , 1.29 , 1.29 , 1.29 , 1.29 , 1.28 , 1.28 , 1.28 , 1.28 , 1.28 , 1.28 , 1.27 , 1.27 , 1.27 , 1.27 , 1.27 , 1.27 , 1.26 , 1.26 , 1.26 , 1.26 , 1.26 , 1.26 , 1.25 , 1.25 , 1.25 , 1.25 , 1.25 , 1.25 , 1.24 , 1.24 , 1.24 , 1.24 , 1.24 , 1.24 , 1.23 , 1.23 , 1.23 , 1.23 , 1.23 , 1.23 , 1.22 , 1.22 , 1.22 , 1.22 , 1.22 , 1.22 , 1.22 , 1.21 , 1.21 , 1.21 , 1.21 , 1.21 , 1.21 , 1.21 , 1.20 , 1.20 , 1.20 , 1.20 , 1.20 , 1.20 , 1.20 , 1.19 , 1.19 , 1.19 , 1.19 , 1.19 , 1.19 , 1.19 , 1.18 , 1.18 , 1.18 , 1.18 , 1.18 , 1.18 , 1.18 , 1.17 , 1.17 , 1.17 , 1.17 , 1.17 , 1.17 , 1.17 , 1.16 , 1.16 , 1.16 , 1.16 , 1.16 , 1.16 , 1.16 , 1.15 , 1.15 , 1.15 , 1.15 , 1.15 , 1.15 , 1.15 , 1.14 , 1.14 , 1.14 , 1.14 , 1.14 , 1.14 , 1.14 , 1.13 , 1.13 , 1.13 , 1.13 , 1.13 , 1.13 , 1.13 , 1.13 , 1.12 , 1.12 , 1.12 , 1.12 , 1.12 , 1.12 , 1.12 , 1.11 , 1.11 , 1.11 , 1.11 , 1.11 , 1.11 , 1.11 , 1.11 , 1.10 , 1.10 , 1.10 , 1.10 , 1.10 , 1.10 , 1.10 , 1.10 , 1.09 , 1.09 , 1.09 , 1.09 , 1.09 , 1.09 , 1.09 , 1.09 , 1.08 , 1.08 , 1.08 , 1.08 , 1.08 , 1.08 , 1.08 , 1.08 , 1.08 , 1.07 , 1.07 , 1.07 , 1.07 , 1.07 , 1.07 , 1.07 , 1.07 , 1.06 , 1.06 , 1.06 , 1.06 , 1.06 , 1.06 , 1.06 , 1.06 , 1.05 , 1.05 , 1.05 , 1.05 , 1.05 , 1.05 , 1.05 , 1.05 , 1.05 , 1.04 , 1.04 , 1.04 , 1.04 , 1.04 , 1.04 , 1.04 , 1.04 , 1.04 , 1.03 , 1.03 , 1.03 , 1.03 , 1.03 , 1.03 , 1.03 , 1.03 , 1.03 , 1.02 , 1.02 , 1.02 , 1.02 , 1.02 , 1.02 , 1.02 , 1.02 , 1.02 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.01 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 1.00 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.99 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.98 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.97 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.96 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.95 , 0.94 , 0.94 , 0.94 , 0.94 , 0.94 , 0.94 , 0.94 , 0.94 };

#endif


//////////////////////////////////////////////////////////////////////////
////-------- Functions Definition
//
/************************************************************************/
// Func: classMFNR::classMFNR()
// Desc: classMFNR constructor
//   In: 
//  Out: 
// 
// Date: Revised by yousf 20160428
// 
/*************************************************************************/
classMFNR::classMFNR(void)
{
    //

} // classMFNR::classMFNR()


/************************************************************************/
// Func: classMFNR::~classMFNR()
// Desc: classMFNR destructor
//   In: 
//  Out: 
// 
// Date: Revised by yousf 20160428
// 
/*************************************************************************/
classMFNR::~classMFNR(void)
{
    //

} // classMFNR::~classMFNR()


/************************************************************************/
// Func: classMFNR::MFNR_Open()
// Desc: MFNR Initialization
//   In: wid            - Raw data width
//       hgt            - Raw data height
//       stride         - Raw data stride (Bytes)
//       size           - Raw data size
//       numPic         - Raw data file num
//       bayerType      - Bayer Type
//       redGain        - AWB Red Gain
//       blueGain       - AWB Blue Gain
//       pRSrcs         - input Raw data pointers
//       pTSrcs         - input Thumb data pointers
//  Out: 
// 
// Date: Revised by yousf 20160721
// 
/*************************************************************************/
int classMFNR::MFNR_Open(int wid, int hgt, int stride, int size, int numPic, 
	RK_U8* bayerType, RK_F32 redGain, RK_F32 blueGain, int lumIntensity,
	RK_F32 sensorGain, RK_F32 ispGain, RK_F32 shutter,
	int luxIndex, int expIndex, RK_S16 blackLevel[],
	void* pRSrcs[], RK_U16* pTSrcs[], 
	/*RK_F32 useGain*/
	RK_F32 testParams[])
{
    //
    int     ret = 0; // return value
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::MFNR_Open()\n");
#endif
    // RawSrcs
    mRawWid         = wid;					            // Raw data width
    mRawHgt         = hgt;					            // Raw data height
    mRawFileNum     = numPic;				            // number of Raw data files
    mRaw10Stride    = (wid * 10 + 31) / 32 * 4;         // Raw10bit data Stride (Bytes, 4ByteAlign) in DDR
    mRaw10DataSize  = mRawHgt * mRaw10Stride;           // Raw10bit data Size (Bytes)
    mRaw16Stride    = (wid * 16 + 31) / 32 * 4;         // Raw16bit data Stride (Bytes, 4ByteAlign) in ARM
    mRaw16DataSize  = mRawHgt * mRaw16Stride;           // Raw10bit data Size (Bytes)
    for (int k=0; k < RK_MAX_FILE_NUM; k++)             // Raw Srcs data pointers
    {
        if (k < mRawFileNum)
        {
            pRawSrcs[k] = (RK_U16*)pRSrcs[k];
        }
        else
        {
            pRawSrcs[k] = NULL;
        }
    }

    // Scaler
    mScaleRaw2Raw   = SCALER_FACTOR_R2R;                // scale factor for Raw to Raw (for Preview)
    mScaleRaw2Luma  = SCALER_FACTOR_R2L;                // scale factor for Raw to Luma
    mScaleRaw2Thumb = SCALER_FACTOR_R2T;                // scale factor for Raw to Thumbnail

    // ThumbSrcs
    mThumbWid        = wid / mScaleRaw2Thumb;	        // Thumb data width  (floor)
    mThumbHgt        = hgt / mScaleRaw2Thumb;	        // Thumb data height (floor)
    mThumb16Stride   = (mThumbWid * 16 + 31) / 32 * 4;  // Thumb data Stride (Bytes, 4ByteAlign)
    mThumb16DataSize = mThumbHgt * mThumb16Stride;      // Thumb data Size (Bytes)
    for (int k=0; k < RK_MAX_FILE_NUM; k++)             // Thumb Srcs data pointers
    {
        if (k < mRawFileNum)
        {
            pThumbSrcs[k] = (RK_U16*)pTSrcs[k];
        }
        else
        {
            pThumbSrcs[k] = NULL;
        }
    }


    //////////////////////////////////////////////////////////////////////////
    //// DSP Memory
    DSP_UsedCount       = 0;                                // DSP Memory used count


    //////////////////////////////////////////////////////////////////////////
    //// Determine Base Frame
    mThumbFeatWinSize   = DIV_FIXED_WIN_SIZE;               // Thumb Feature Win Size
    mThumbDivSegCol     = mThumbWid / mThumbFeatWinSize;    // number of Seg Col
    mThumbDivSegRow     = mThumbHgt / mThumbFeatWinSize;    // number of Seg Row
    pSharpOfAllFrm      = (RK_U32*)malloc(sizeof(RK_U32) * mRawFileNum);    // Sharpness of All Frame
    DSP_UsedCount      += sizeof(RK_U32) * mRawFileNum;                     // DSP Memory used count
    if(pSharpOfAllFrm == NULL)
    {
        ret = -1;
        return ret;
    }
    memset(pSharpOfAllFrm, 0, sizeof(RK_U32)*mRawFileNum);
    for (int k=0; k < RK_MAX_FILE_NUM; k++)                                 // Sharpness of All 32x32 Segment in Frames
    {
        if (k < mRawFileNum)
        {
            // sharpness in 32x32 in Frame#k
            pSharpOfAllSeg[k] = (RK_U32*)malloc(sizeof(RK_U32) * mThumbDivSegCol * mThumbDivSegRow); 
            DSP_UsedCount    += sizeof(RK_U32) * mThumbDivSegCol * mThumbDivSegRow;     // DSP Memory used count
            if(pSharpOfAllSeg[k] == NULL)
            {
                ret = -1;
                return ret;
            }
        }
        else
        {
            pSharpOfAllSeg[k] = NULL;
        }
    }
    for (int k=0; k < RK_MAX_FILE_NUM; k++)                                 // Sharpness of All 32x32 Segment in Frames
    {
        if (k < mRawFileNum)
        {
            // [y, x, maxgradin32x32] in Frame#k
            pMaxSharpFrmSeg[k] = (RK_U32*)malloc(sizeof(RK_U32) * mThumbDivSegCol * mThumbDivSegRow * 3); 
            DSP_UsedCount     += sizeof(RK_U32) * mThumbDivSegCol * mThumbDivSegRow * 3;     // DSP Memory used count
            if(pMaxSharpFrmSeg[k] == NULL)
            {
                ret = -1;
                return ret;
            }
        }
        else
        {
            pMaxSharpFrmSeg[k] = NULL;
        }
    }
    pThumbDataChunk = (RK_U16*)malloc(sizeof(RK_U16) * NUM_LINE_DDR2DSP_THUMB * mThumb16Stride/2);  // Thumb Data Chunk
    DSP_UsedCount  += sizeof(RK_U16) * NUM_LINE_DDR2DSP_THUMB * mThumb16Stride/2;                   // DSP Memory used count
    if(pThumbDataChunk == NULL)
    {
        ret = -1;
        return ret;
    }

    //////////////////////////////////////////////////////////////////////////
    //// Block Coarse Matching
    pValidMark       = (RK_U8*)malloc(sizeof(RK_U8)*mRawFileNum);                               // Frame Mark: 0-Base 1-ValidRef 2-InvalidRef
    DSP_UsedCount   += sizeof(RK_U8)*mRawFileNum;                                               // DSP Memory used count
    pMaxSharpBaseSeg = (RK_U32*)malloc(sizeof(RK_U32) * mThumbDivSegCol * mThumbDivSegRow * 3); // MaxSharpness in each 32x32 Segment in BaseFrame
    DSP_UsedCount   += sizeof(RK_U32) * mThumbDivSegCol * mThumbDivSegRow * 3;                  // DSP Memory used count
    pMatchPoints     = (RK_U16*)malloc(sizeof(RK_U16) * (2+3*mRawFileNum)*mThumbDivSegCol*mThumbDivSegRow); // MatchResult: { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature
    DSP_UsedCount   += sizeof(RK_U16) * (2+3*mRawFileNum)*mThumbDivSegCol*mThumbDivSegRow;                  // DSP Memory used count
    int     radius   = COARSE_MATCH_RADIUS;                                                     // ceil(MAX_OFFSET * 1.0 / SCALER_FACTOR_R2T);     // search radius
    int     radius2  = CEIL(radius*1.0/2)*2;                                                    // search radius for 4ByteAlign
    pThumbBaseBlk    = (RK_U16*)malloc(sizeof(RK_U16)*COARSE_MATCH_WIN_SIZE*COARSE_MATCH_WIN_SIZE); // 16x16Block in 32x32 Segment in BaseFrame
    DSP_UsedCount   += sizeof(RK_U16)*COARSE_MATCH_WIN_SIZE*COARSE_MATCH_WIN_SIZE;                  // DSP Memory used count
    pThumbRefBlk     = (RK_U16*)malloc(sizeof(RK_U16)*(COARSE_MATCH_WIN_SIZE+2*radius)*(COARSE_MATCH_WIN_SIZE+2*radius2));  // (16+2*radius)x(16+2*radius')Block in RefFrame
    DSP_UsedCount   += sizeof(RK_U16)*(COARSE_MATCH_WIN_SIZE+2*radius)*(COARSE_MATCH_WIN_SIZE+2*radius2);                   // DSP Memory used count
    if(pValidMark == NULL || pMaxSharpBaseSeg == NULL || pMatchPoints == NULL || pThumbBaseBlk == NULL || pThumbRefBlk == NULL)
    {
        ret = -1;
        return ret;
    }

    //////////////////////////////////////////////////////////////////////////
    //// Block Fine Matching
    pRawBaseBlk     = (RK_U16*)malloc(sizeof(RK_U16)*FINE_MATCH_WIN_SIZE*FINE_MATCH_WIN_SIZE);	    // 64x64Block in 256x256 Segment in BaseFrame
    DSP_UsedCount  += sizeof(RK_U16)*FINE_MATCH_WIN_SIZE*FINE_MATCH_WIN_SIZE;                       // DSP Memory used count
    pRawBaseBlkLuma = (RK_U16*)malloc(sizeof(RK_U16)*FINE_MATCH_WIN_SIZE*FINE_MATCH_WIN_SIZE/4);    // Luma of 64x64Block in 256x256 Segment in BaseFrame
    DSP_UsedCount  += sizeof(RK_U16)*FINE_MATCH_WIN_SIZE*FINE_MATCH_WIN_SIZE/4;                     // DSP Memory used count
    pRawRefBlk      = (RK_U16*)malloc(sizeof(RK_U16)*(FINE_MATCH_WIN_SIZE+2*radius)*(FINE_MATCH_WIN_SIZE+2*radius+32));     // (64+2*radius)x(64+2*radius')Block in RefFrame
    DSP_UsedCount  += sizeof(RK_U16)*(FINE_MATCH_WIN_SIZE+2*radius)*(FINE_MATCH_WIN_SIZE+2*radius+32);                      // DSP Memory used count
    pRawRefBlkLuma  = (RK_U16*)malloc(sizeof(RK_U16)*(FINE_MATCH_WIN_SIZE+2*radius)*(FINE_MATCH_WIN_SIZE+2*radius+32)/4);   // Luma of (64+2*radius)x(64+2*radius')Block in RefFrame
    DSP_UsedCount  += sizeof(RK_U16)*(FINE_MATCH_WIN_SIZE+2*radius)*(FINE_MATCH_WIN_SIZE+2*radius+32)/4;                    // DSP Memory used count
    if(pRawBaseBlk == NULL || pRawBaseBlkLuma == NULL || pRawRefBlk == NULL || pRawRefBlkLuma == NULL)
    {
        ret = -1;
        return ret;
    }

    //////////////////////////////////////////////////////////////////////////
    //// Compute Homography
#if USE_MV_HIST_FILTRATE == 1
    pRowMvHist         = (RK_U8*)malloc(sizeof(RK_U8)*LEN_MV_HIST); // RowMV Hist
    DSP_UsedCount     += sizeof(RK_U8)*LEN_MV_HIST;                 // DSP Memory used count
    memset(pRowMvHist, 0, sizeof(RK_U8) * LEN_MV_HIST);
    pColMvHist         = (RK_U8*)malloc(sizeof(RK_U8)*LEN_MV_HIST); // ColMV Hist
    DSP_UsedCount     += sizeof(RK_U8)*LEN_MV_HIST;                 // DSP Memory used count
    memset(pColMvHist, 0, sizeof(RK_U8) * LEN_MV_HIST);
#endif
	pMarkMatchFeature  = (RK_U8*)malloc(sizeof(RK_U8)*MAX_NUM_MATCH_FEATURE); // Marks of Match Feature in BaseFrame & RefFrame#k
    DSP_UsedCount     += sizeof(RK_U8)*MAX_NUM_MATCH_FEATURE;                 // DSP Memory used count
	memset(pMarkMatchFeature, 1, sizeof(RK_U8) * MAX_NUM_MATCH_FEATURE);
    pAgentsIn4x4Region = (RK_U16*)malloc(sizeof(RK_U16)*NUM_DIVIDE_IMAGE * NUM_DIVIDE_IMAGE * (2 + 2*mRawFileNum)); // Agents in 4x4 Region [RegMark4x4, Sharp/SAD, 2*RawFileNum]*16
    DSP_UsedCount     += sizeof(RK_U16)*NUM_DIVIDE_IMAGE * NUM_DIVIDE_IMAGE * (2 + 2*mRawFileNum);                  // DSP Memory used count
    memset(pAgentsIn4x4Region, 0, sizeof(RK_U16)*NUM_DIVIDE_IMAGE * NUM_DIVIDE_IMAGE * (2 + 2*mRawFileNum));
    pRegion4Points     = (RK_U16*)malloc(sizeof(RK_U16) * 4 * 4);   // 4 points in 4 Regions: [x0,y0,x1,y1] * 4Points * 2Byte
    DSP_UsedCount     += sizeof(RK_U16) * 4 * 4;                    // DSP Memory used count
    pHomographyMatrix  = (RK_F32*)malloc(sizeof(RK_F32) * 9 * mRawFileNum); // Homography: [9*RawFileNum] * 4Byte
    DSP_UsedCount     += sizeof(RK_F32) * 9 * mRawFileNum;                  // DSP Memory used count
    pMatrixA           = (RK_F32*)malloc(sizeof(RK_F32) * 8 * 8);   // Coefficient Matrix A for A*X = B: 8*8*4Byte
    DSP_UsedCount     += sizeof(RK_F32) * 8 * 8;                    // DSP Memory used count
    pVectorB           = (RK_F32*)malloc(sizeof(RK_F32) * 8 * 1);   // Coefficient Vector B for A*X = B: 8*1*4Byte
    DSP_UsedCount     += sizeof(RK_F32) * 8 * 1;                    // DSP Memory used count
    pVectorX           = (RK_F32*)malloc(sizeof(RK_F32) * 3 * 3);   // Coefficient Vector X for A*X = B: 3*3*4Byte
    DSP_UsedCount     += sizeof(RK_F32) * 3 * 3;                    // DSP Memory used count
    pProjectPoint      = (RK_S32*)malloc(sizeof(RK_S32) * 2);       // Perspective Project Point: 2*4Byte
    DSP_UsedCount     += sizeof(RK_S32) * 2;                        // DSP Memory used count
    if(pAgentsIn4x4Region == NULL || pRegion4Points == NULL || pHomographyMatrix == NULL
        || pMatrixA == NULL || pVectorB == NULL || pVectorX == NULL || pProjectPoint == NULL)
    {
        ret = -1;
        return ret;
    }

    //////////////////////////////////////////////////////////////////////////
    //// BlockMatching & Multi-Frame MV Compensate
    radius = LUMA_MATCH_RADIUS*2;	// Block Matching search radius in Raw
    for (int m=0; m < LUMA_MATCH_WIN_NUM; m++)
    {
        pBlkMatchBaseBlks[m]     = (RK_U16*)malloc(sizeof(RK_U16) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE);	    // BlockMatching Base Blocks: 32*32*2Byte * 4
        DSP_UsedCount           += sizeof(RK_U16) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE;                      // DSP Memory used count
        pBlkMatchBaseBlksLuma[m] = (RK_U16*)malloc(sizeof(RK_U16) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE / 4); // Luma of BlockMatching Base Blocks: 16*16*2Byte * 4
        DSP_UsedCount           += sizeof(RK_U16) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE / 4;                  // DSP Memory used count
        pBlkMatchRefBlks[m]      = (RK_U16*)malloc(sizeof(RK_U16) * (LUMA_MATCH_WIN_SIZE+2*radius)*(LUMA_MATCH_WIN_SIZE+2*radius+32));      // BlockMatching Ref Block: (32+2*radius)*(32+2*radius')*2Byte * 4
        DSP_UsedCount           += sizeof(RK_U16) * (LUMA_MATCH_WIN_SIZE+2*radius)*(LUMA_MATCH_WIN_SIZE+2*radius+32);                       // DSP Memory used count
        pBlkMatchRefBlksLuma[m]  = (RK_U16*)malloc(sizeof(RK_U16) * (LUMA_MATCH_WIN_SIZE+2*radius)*(LUMA_MATCH_WIN_SIZE+2*radius+32) / 4);  // Luma of BlockMatching Ref Block: (32+2*radius)/2*(32+2*radius')/2*2Byte * 4
        DSP_UsedCount           += sizeof(RK_U16) * (LUMA_MATCH_WIN_SIZE+2*radius)*(LUMA_MATCH_WIN_SIZE+2*radius+32) / 4;                   // DSP Memory used count
        pBlkMatchDstBlks[m]      = (RK_U16*)malloc(sizeof(RK_U16) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE); // BlockMatching Dst Block: 32*32*2Byte * 4
        DSP_UsedCount           += sizeof(RK_U16) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE;                  // DSP Memory used count
        if(pBlkMatchBaseBlks[m] == NULL || pBlkMatchBaseBlksLuma[m] == NULL 
            || pBlkMatchRefBlks[m] == NULL || pBlkMatchRefBlksLuma[m] == NULL
            || pBlkMatchDstBlks[m] == NULL)
        {
            ret = -1;
            return ret;
        }
    }
    pBlkCenterPoint = (RK_U16*)malloc(sizeof(RK_U16) * 2);	    // Block Center Point: 2*2Byte
    DSP_UsedCount  += sizeof(RK_U16) * 2;                       // DSP Memory used count
    if(pBlkCenterPoint == NULL)
    {
        ret = -1;
        return ret;
    }
    int numValue    = CEIL(CEIL(mRawWid*1.0/LUMA_MATCH_WIN_SIZE)/LUMA_MATCH_WIN_NUM)*LUMA_MATCH_WIN_NUM*2;
    int nLineBlkLen = numValue * mRawFileNum;
    pTwoLineBlkMPs[0] = (RK_S16*)malloc(sizeof(RK_S16) * nLineBlkLen);      // Even Block Match Points Cache: ceil(ceil(RawWid/32)/4)*4 * 2 * 6 * 2Byte
    DSP_UsedCount    += sizeof(RK_S16) * nLineBlkLen;                       // DSP Memory used count
    pTwoLineBlkMPs[1] = (RK_S16*)malloc(sizeof(RK_S16) * nLineBlkLen);		// Odd Block Match Points Cache:  ceil(ceil(RawWid/32)/4)*4 * 2 * 6 * 2Byte
    DSP_UsedCount    += sizeof(RK_S16) * nLineBlkLen;                       // DSP Memory used count
    if(pTwoLineBlkMPs[0] == NULL || pTwoLineBlkMPs[1] == NULL)
    {
        ret = -1;
        return ret;
    }
    memset(pTwoLineBlkMPs[0], 0, sizeof(RK_S16) * nLineBlkLen);             // init
    memset(pTwoLineBlkMPs[1], 0, sizeof(RK_S16) * nLineBlkLen);             // init
    pMatchResultRects = (RK_U16*)malloc(sizeof(RK_U16) * 2 * mRawFileNum);  // Match Result Rects of All RefFrame: 2 * 6 * 2Bte
    DSP_UsedCount    += sizeof(RK_U16) * 2 * mRawFileNum;                   // DSP Memory used count
    pBlockWeights     = (RK_U8*)malloc(sizeof(RK_U8) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_NUM); // Block Weights: 32*32*4*1Byte
    DSP_UsedCount    += sizeof(RK_U8) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_NUM;                 // DSP Memory used count
    if(pMatchResultRects == NULL || pBlockWeights == NULL)
    {
        ret = -1;
        return ret;
    }
#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
    for (int m=0; m < LUMA_MATCH_WIN_NUM; m++)
    {
        pBlkMatchBaseBlksFilt[m] = (RK_U16*)malloc(sizeof(RK_U16) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE);	// Filtered Base Raw data
        DSP_UsedCount           += sizeof(RK_U16) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE;                  // DSP Memory used count
        pBlkMatchRefBlksFilt[m]  = (RK_U16*)malloc(sizeof(RK_U16) * (LUMA_MATCH_WIN_SIZE+2*radius)*(LUMA_MATCH_WIN_SIZE+2*radius+32)); // Filtered Ref Raw data
        DSP_UsedCount           += sizeof(RK_U16) * (LUMA_MATCH_WIN_SIZE+2*radius)*(LUMA_MATCH_WIN_SIZE+2*radius+32);                  // DSP Memory used count
        if(pBlkMatchBaseBlksFilt[m] == NULL || pBlkMatchRefBlksFilt[m] == NULL)
        {
            ret = -1;
            return ret;
        }
    }
#endif


	//
	//---- testParams[]
	for (int k=0; k < TEST_PARAMS_NUM; k++)
	{
		mTestParams[k] = testParams[k];
		// mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
		// mTestParams[1]	 1-Use PreGain-PostBlk   2-Use PreBlk-PostGain
		// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
		// mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
		// mTestParams[4]    0-FixedMotionDetectThreshold, n-MotionDetectTable[n], n=1,2,...,8
		// mTestParams[5]    0-OldWdrParamPol, 1-NewWdrParamMax
		// mTestParams[6]    0-NotUseRegister, 1-UseRegister
		// mTestParams[7]    0-NotUseOppoBlk, 1-UseOppoBlk
	}

    // Auto White Balance
#if USE_AWB == 1 // 1-use Auto White Balance, 0-not use
    sprintf(mBayerType,"%s", bayerType);
    if(!strcmp(mBayerType, "GRBG"))
    {
        mAwbGains[0] = 1.0f;
        mAwbGains[1] = redGain;
        mAwbGains[2] = blueGain;
        mAwbGains[3] = 1.0f;
    }
    else if(!strcmp(mBayerType, "GBRG"))
    {
        mAwbGains[0] = 1.0f;
        mAwbGains[1] = blueGain;
        mAwbGains[2] = redGain;
        mAwbGains[3] = 1.0f;
    }
    else if(!strcmp(mBayerType, "RGGB"))
    {
        mAwbGains[0] = redGain;
        mAwbGains[1] = 1.0f;
        mAwbGains[2] = 1.0f;
        mAwbGains[3] = blueGain;
    }
    else if(!strcmp(mBayerType, "BGGR"))
    {
        mAwbGains[0] = blueGain;
        mAwbGains[1] = 1.0f;
        mAwbGains[2] = 1.0f;
        mAwbGains[3] = redGain;
    }
#endif
	// 
	mLumIntensity	= lumIntensity;
	mSensorGain		= sensorGain;
	mIspGain		= ispGain;
	mShutter		= shutter;
	mLuxIndex		= luxIndex;
	mExpIndex		= expIndex;
	if (mTestParams[7] == 0) // mTestParams[7]    0-NotUseOppoBlk, 1-UseOppoBlk
	{
		mBlackLevel[0] = 64*4;
		mBlackLevel[1] = 64*4;
		mBlackLevel[2] = 64*4;
		mBlackLevel[3] = 64*4;
	}
	else if (mTestParams[7] == 1)
	{
		mBlackLevel[0] = blackLevel[0];
		mBlackLevel[1] = blackLevel[1];
		mBlackLevel[2] = blackLevel[2];
		mBlackLevel[3] = blackLevel[3];
	}
	
	


    // RawDst
    pRawDst = NULL;    // Raw Dst data pointer
	

	// WDR
	pRawDstGain    = (RK_U16 *)malloc(sizeof(RK_U16) * mRawWid * mRawHgt);// // for ln-test
	pRawDstGainWDR = (RK_U16 *)malloc(sizeof(RK_U16) * mRawWid * mRawHgt);// // for ln-test
	pRawDstGainWDR_CEVA = (RK_U16 *)malloc(sizeof(RK_U16) * mRawWid * mRawHgt);// // for ln-test

	memset(pRawDstGain,    0, sizeof(RK_U16) * mRawWid * mRawHgt);
	memset(pRawDstGainWDR, 0, sizeof(RK_U16) * mRawWid * mRawHgt);
	memset(pRawDstGainWDR_CEVA, 0, sizeof(RK_U16) * mRawWid * mRawHgt);

	// SpaceDenoise
	pRawDstWeight = (RK_U32 *)malloc(sizeof(RK_U32) * mRawWid * mRawHgt);  // for zlf-SpaceDenoise
	//memset(pRawDstWeight, 0, sizeof(RK_U32) * mRawWid * mRawHgt);
	pRawDstCpy  = (RK_U16 *)malloc(sizeof(RK_U16) * mRawWid * mRawHgt);

	/*/
	for (int i=0; i < mRawWid * mRawHgt; i++)
	{
		printf("i=%d/%d\n", i, mRawWid * mRawHgt);
		*(pRawDstGain    + i) = 0;
		*(pRawDstGainWDR + i) = 0;
		*(pRawDstCpy     + i) = 0;
	}//*/

    //
    return ret;

} // classMFNR::MFNR_Open()


/************************************************************************/
// Func: classMFNR::ComputeGrad()
// Desc: Compute Grad
//   In: numFrame       - cur frame number
//       rowSeg         - Seg(rowSeg,m)
//  Out: pSharpOfAllFrm - Sharpness of All Frame
//       pSharpOfAllSeg - Sharpness of All 32x32 Segment in Frames
//       pMaxSharpFrmSeg- MaxSharpness in each 32x32 Segment in Frames
// 
// Date: Revised by yousf 20160602
// 
/*************************************************************************/
int classMFNR::ComputeGrad(int numFrame, int rowSeg)
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::ComputeGrad()\n");
// #endif
    //
    int Grdx, Grdy, Grad;
    int sumGrad;
    int maxGrad, maxGrdRow, maxGrdCol;

    int wid = mThumb16Stride/2;

    for (int m=0; m < mThumbDivSegCol; m++) // Seg(rowSeg,m)
    {
        // init
        sumGrad   = 0; // Seg(rowSeg,m)
        maxGrad   = 0; // Max
        maxGrdRow = 0; // row
        maxGrdCol = 0; // col

        // 
        for (int i=1; i<mThumbFeatWinSize-1; i++)
        {
            for (int j=1; j <mThumbFeatWinSize-1; j++)
            {
//                printf("m=%d,i=%d,j=%d\n",m,i,j);
                // grad
                Grdx = *(pThumbDataChunk +   i   * wid + j-1 + m * mThumbFeatWinSize) 
                     - *(pThumbDataChunk +   i   * wid + j+1 + m * mThumbFeatWinSize);
                Grdy = *(pThumbDataChunk + (i-1) * wid + j   + m * mThumbFeatWinSize) 
                     - *(pThumbDataChunk + (i+1) * wid + j   + m * mThumbFeatWinSize);
                Grdx = ABS_U16(Grdx);
                Grdy = ABS_U16(Grdy);
                Grad = Grdx + Grdy; // overflow ?
                //Grad = (Grdx + Grdy) / 2; // floor()

#if USE_MAX_GRAD == 1
                Grad = MIN(Grad, MAX_GRAD); // truncate 10bit: // max grad 0xFFF= 2^12-1
#endif

                // sumGrad
                sumGrad += Grad;

                // maxGrad
                if (Grad > maxGrad)
                {
                    maxGrad = Grad;
                    maxGrdRow = rowSeg * mThumbFeatWinSize + i;
                    maxGrdCol = m * mThumbFeatWinSize + j;
                }

            } // for j
        } // for i

        //sumGrad = sumGrad >> 2; // 32*32=2^10

        // Sharpness of All Frame -> baseFrame
        pSharpOfAllFrm[numFrame] += sumGrad;  // sharp of #numFrame

        // Sharpness of All 32x32 Segment in Frames
        *(pSharpOfAllSeg[numFrame] + rowSeg*mThumbDivSegCol + m) = sumGrad;// sumGrad of Seg(rowSeg,m)

        // [maxGrad row col]
        *(pMaxSharpFrmSeg[numFrame] + (rowSeg*mThumbDivSegCol + m) * 3 )    = maxGrad;
        *(pMaxSharpFrmSeg[numFrame] + (rowSeg*mThumbDivSegCol + m) * 3 + 1) = maxGrdRow;
        *(pMaxSharpFrmSeg[numFrame] + (rowSeg*mThumbDivSegCol + m) * 3 + 2) = maxGrdCol;
    }

    //
    return ret;

} // classMFNR::ComputeGrad()


/************************************************************************/
// Func: classMFNR::DetermineBaseFrame()
// Desc: Determine Base Frame
//   In: pThumbSrcs			- Thumb Srcs data pointers
//  Out: mBasePicNum		- Base Picture Num
//       pValidMark			- Frame Mark: 0-Base 1-ValidRef 2-InvalidRef
//       pMaxSharpBaseSeg	- MaxSharpness in each 32x32 Segment in BaseFrame
// 
// Date: Revised by yousf 20160602
// 
/*************************************************************************/
int classMFNR::DetermineBaseFrame()
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::DetermineBaseFrame()\n");
// #endif
    //
    int     cntRow   = NUM_LINE_DDR2DSP_THUMB;
    RK_U32  MaxSharp = 0;
    for (int k=0; k < mRawFileNum; k++)
    {
        // modified by yousf20160720
        if (k > 0)
        {
            pSharpOfAllFrm[k] = pSharpOfAllFrm[k-1];
            continue;
        }
        
        // Compute Grad
        for (int i=0; i < mThumbDivSegRow; i++)
        {
#if MY_DEBUG_PRINTF == 1
            printf("classMFNR::DetermineBaseFrame()----Frame#k=%d, SegRow#i=%d\n", k, i);
#endif
            // pThumbSrcs[k]:32lines -> pThumbDataChunk
            memcpy(pThumbDataChunk, pThumbSrcs[k]+i*mThumb16Stride/2*cntRow, sizeof(RK_U8) * mThumb16Stride * cntRow);

            // (Frame#k rowSeg#i)
            ComputeGrad(k, i);
        }

        // Base Frame
        if (MaxSharp < pSharpOfAllFrm[k])
        {
            MaxSharp    = pSharpOfAllFrm[k];
            mBasePicNum = k;
        }
    }

    // Frame Mark: 0-Base 1-ValidRef 2-InvalidRef 
    mCntValidRefFrm = 0;    // count Valid RefFrame
    for (int k=0; k < mRawFileNum; k++)
    {
        if (pSharpOfAllFrm[k] < MaxSharp * MAX_SHARP_RATIO)
        {
            pValidMark[k]   = MARK_INVALID_REF;     // invalid ref frame mark: 2
        }
        else
        {
            pValidMark[k]   = MARK_VALID_REF;       // valid ref frame mark: 1
            mCntValidRefFrm++;                      // count Valid RefFrame
        }
    }
    pValidMark[mBasePicNum] = MARK_BASE_FRAME;      // base frame mark: 0
    mCntValidRefFrm--;                              // - BaseFrame
    if (mCntValidRefFrm == 0)                       // Num of Valid RefFrame = 0
    {
        return 0;
    }

    //
    int         SharpTh; // sharpness threshold
    RK_U32*     pTmpSegSharp = pMaxSharpFrmSeg[mBasePicNum]; // temp pointer: point to BaseFrame
#if FEATURE_TH_METHOD == USE_MIN2_TH
    // first min & second min
    int         FirstMinSegSharp    = 0xFFFF;   // init First Min Segment Sharpness
    int         SecondMinSegSharp   = 0xFFFF;   // init Second Min Segment Sharpness
    int         fstMinRow           = 0;        // row
    int         fstMinCol           = 0;        // col
    int         sndMinRow           = 0;        // row
    int         sndMinCol           = 0;        // col
    for (int i=0; i < mThumbDivSegRow; i++)
    {
        for (int j=0; j < mThumbDivSegCol; j++)
        {
            if (FirstMinSegSharp >= (int)*pTmpSegSharp)
            {
                // second min
                SecondMinSegSharp = FirstMinSegSharp;
                sndMinRow         = fstMinRow;
                sndMinCol         = fstMinCol;
                // first min
                FirstMinSegSharp  = *(pTmpSegSharp + 0);  // maxGrad
                fstMinRow         = *(pTmpSegSharp + 1);  // maxGrdRow
                fstMinCol         = *(pTmpSegSharp + 2);  // maxGrdCol
            }
            else if(SecondMinSegSharp >= (int)*pTmpSegSharp)
            {
                // second min
                SecondMinSegSharp = *(pTmpSegSharp + 0);  // maxGrad  
                sndMinRow         = *(pTmpSegSharp + 1);  // maxGrdRow
                sndMinCol         = *(pTmpSegSharp + 2);  // maxGrdCol
            }
            pTmpSegSharp += 3;  // [maxGrad, maxGrdRow, maxGrdCol]

        } // for j
    } // for i
    SharpTh = SecondMinSegSharp + FirstMinSegSharp; // sharpness threshold

#elif FEATURE_TH_METHOD == USE_AVE_TH
    // ave
    int     sumGrd = 0;
    for (int i=0; i < mThumbDivSegRow; i++)
    {
        for (int j=0; j < mThumbDivSegCol; j++)
        {

            sumGrd += *(pTmpSegSharp + 0);
            pTmpSegSharp += 3;  // [maxGrad, maxGrdRow, maxGrdCol]

        } // for j
    } // for i
    SharpTh = sumGrd / (mThumbDivSegRow*mThumbDivSegCol);

#endif

    // Valid Features
    RK_U32*     pTmpBaseSegSharp = NULL;
    pTmpSegSharp        = pMaxSharpFrmSeg[mBasePicNum]; // temp pointer
    pTmpBaseSegSharp    = pMaxSharpBaseSeg;             // temp pointer 
    mNumValidFeature    = 0;                            // num of Valid Feature
    for (int i=0; i < mThumbDivSegRow; i++)
    {
        for (int j=0; j < mThumbDivSegCol; j++)
        {
            if ((int)*pTmpSegSharp >= SharpTh) // Segment
            {
                // MaxSharp Feature in Segment
                if (   (int)*(pTmpSegSharp+1) < COARSE_MATCH_WIN_SIZE
                    || (int)*(pTmpSegSharp+2) < COARSE_MATCH_WIN_SIZE 
                    || (int)*(pTmpSegSharp+1) >= mThumbHgt - COARSE_MATCH_WIN_SIZE 
                    || (int)*(pTmpSegSharp+2) >= mThumbWid - COARSE_MATCH_WIN_SIZE)
                {
                    pTmpSegSharp += 3; // [maxGrad, maxGrdRow, maxGrdCol]
                }
                else
                {
                    *(pTmpBaseSegSharp + 0) = *(pTmpSegSharp + 0); // sharp value
                    *(pTmpBaseSegSharp + 1) = *(pTmpSegSharp + 1); // row
                    *(pTmpBaseSegSharp + 2) = *(pTmpSegSharp + 2); // col
                    pTmpBaseSegSharp       += 3;
                    pTmpSegSharp           += 3;
                    mNumValidFeature++; // 
                }
            }
            else
            {
                pTmpSegSharp += 3; // [maxGrad, maxGrdRow, maxGrdCol]
            }
        } // for j
    } // for i


    //
    return ret;

} // classMFNR::DetermineBaseFrame()


/************************************************************************/
// Func: classMFNR::GetThumbBlock()
// Desc: Get Thumb Block
//   In: numFrame       - cur frame number
//       rowDDR         - row in DDR
//       colDDR         - col in DDR
//       hgtDDR         - height in DDR 
//       widDDR         - width in DDR
//  Out: pThumbDsp      - Thumb data pointer in DSP
// 
// Date: Revised by yousf 20160602
// 
/*************************************************************************/
int classMFNR::GetThumbBlock(int numFrame, int rowDDR, int colDDR, int hgtDDR, int widDDR, RK_U16* pThumbDsp)
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::GetThumbBlock()\n");
// #endif
    // init vars
    RK_U16*          pTmpSrc = NULL;                // temp pointer
    RK_U16*          pTmpDst = NULL;                // temp pointer

    //
    pTmpSrc = pThumbSrcs[numFrame];
    pTmpDst = pThumbDsp;
    for (int r = rowDDR; r < rowDDR + hgtDDR; r++)
    {
        memcpy(pTmpDst, (pTmpSrc + r * mThumb16Stride/2 + colDDR), sizeof(RK_U16)*widDDR);
        pTmpDst += widDDR; // 2BytePerPixel
    }

    //
    return ret;

} // classMFNR::GetThumbBlock()


/************************************************************************/
// Func: classMFNR::ThumbSparseMatching()
// Desc: Thumb Sparse Matching
//   In: pThumbBase     - Thumb Block in Base Frame
//       widBase        - width
//       hgtBase        - height
//       pThumbRef      - Thumb Block in Ref Frame
//       widRef         - width
//       hgtRef         - height
//       colStart       - col start in Ref Block data
//  Out: row            - match result row
//       col            - match result row
//       sad            - match result SAD
// 
// Date: Revised by yousf 20160602
// 
/*************************************************************************/
int classMFNR::ThumbSparseMatching(RK_U16* pThumbBase, int widBase, int hgtBase, RK_U16* pThumbRef, int widRef, int hgtRef, int colStart, RK_U16& row, RK_U16& col, RK_U16& sad)
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::ThumbSparseMatching()\n");
// #endif
    // init vars
    RK_U16*         pTmpBase        = NULL;             // temp pointer
    RK_U16*         pTmpRef         = NULL;             // temp pointer
    RK_U32          minSAD;
    RK_U32          curSAD;

    // init min SAD
    minSAD = 0xFFFFFFFF; // 2^32 - 1

    //
    if (widBase != COARSE_MATCH_WIN_SIZE || hgtBase != COARSE_MATCH_WIN_SIZE)
    {
        ret = -1;
        return ret;
    }

    // Matching
    for (int i=0; i < hgtRef - hgtBase + 1; i++)
    {
        //for (int j=0; j < widRef - COARSE_MATCH_WIN_SIZE + 1; j++)
        for (int j=colStart; j < MIN(colStart+2*COARSE_MATCH_RADIUS+1, widRef-widBase+1); j++)
        {
            pTmpBase = pThumbBase;                  // Base data
            pTmpRef  = pThumbRef + i*widRef + j;    // Ref data
            curSAD   = 0;
            for (int m=0; m < hgtBase; m++)
            {
                for (int n=0; n < widBase; n++)
                {
                    //curSAD += ABS_U16(*pTmpBase - *pTmpRef);
                    curSAD += MIN(ABS_U16(*pTmpBase - *pTmpRef), 0xFF); // 16x16 * 8bitSAD -> 16bit
                    pTmpBase++;
                    pTmpRef++;
                }
                pTmpRef += (widRef - widBase);
            }
            if (curSAD < minSAD)
            {
                minSAD = curSAD;
                row    = i;
                col    = j;
            }
        }
    }

    // Matching Min SAD
    sad = minSAD;

    //
    return ret;

} // classMFNR::ThumbSparseMatching()


/************************************************************************/
// Func: classMFNR::BlockCoarseMatching()
// Desc: Block Coarse Matching
//   In: pThumbSrcs			- Thumb Srcs data pointers
//       mBasePicNum		- Base Picture Num
//       pValidMark			- Frame Mark: 0-Base 1-ValidRef 2-InvalidRef
//       pMaxSharpBaseSeg	- MaxSharpness in each 32x32 Segment in BaseFrame
//  Out: pMatchPoints		- MatchResult: { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature
// 
// Date: Revised by yousf 20160602
// 
/*************************************************************************/
int classMFNR::BlockCoarseMatching()
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::BlockCoarseMatching()\n");
// #endif
    //
    int         sharp_v, sharp_r, sharp_c;
    int         sharp_r_div16, sharp_c_div16;
    int         coarseBlkRow, coarseBlkCol;
    int         radius, radius2;  // search radius
    
    // DDR block
    int         rowDDR0, rowDDR1;   // row in DDR
    int         colDDR0, colDDR1;   // col in DDR
    int			colDDR2, colDDR3;	// Align
    int         hgtDDR;             // height in DDR 
    int         widDDR;             // width in DDR
    int         colStart;           // col start in Ref Block data
    RK_U16      matchRow, matchCol, matchSad;   // match result
    RK_U16*     pTmpMatchResult  = NULL; // { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature *2Byte
    RK_U32*     pTmpBaseSegSharp = NULL; // temp pointer 
    
    //
    radius  = COARSE_MATCH_RADIUS;          // ceil(MAX_OFFSET * 1.0 / SCALER_FACTOR_R2T);     // search radius
    //radius2 = CEIL(radius*1.0/2)*2;         // search radius for 4ByteAlign
    pTmpMatchResult  = pMatchPoints;        // { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature *2Byte
    pTmpBaseSegSharp = pMaxSharpBaseSeg;    // MaxSharpness in each 32x32 Segment in BaseFrame

    // Matching
    for (int n=0; n < mNumValidFeature; n++)    // num of Valid Feature
    {
        // BaseFrame Feature: [sharp, row, col]
        sharp_v = *(pTmpBaseSegSharp + 0);
        sharp_r = *(pTmpBaseSegSharp + 1);
        sharp_c = *(pTmpBaseSegSharp + 2);
        pTmpBaseSegSharp += 3;

        // Feature belong to which Region in 4x4
        *(pTmpMatchResult + 0) = sharp_r / (mThumbHgt / NUM_DIVIDE_IMAGE); // RegMarkRow in 4x4
        *(pTmpMatchResult + 1) = sharp_c / (mThumbWid / NUM_DIVIDE_IMAGE); // RegMarkCol in 4x4
        pTmpMatchResult   += 2;

        // select 16x16Block in 32x32Block in BaseThumb
        sharp_r_div16 = sharp_r / COARSE_MATCH_WIN_SIZE; // floor div16
        sharp_c_div16 = sharp_c / COARSE_MATCH_WIN_SIZE; // floor div16
        // block(row, col) 16x16
        coarseBlkRow = COARSE_MATCH_WIN_SIZE * sharp_r_div16;
        coarseBlkCol = COARSE_MATCH_WIN_SIZE * sharp_c_div16;

        // BaseFrame ThumbBlock
        rowDDR0 = coarseBlkRow;          // BaseBlock row in DDR
        colDDR0 = coarseBlkCol;          // BaseBlock col in DDR
        hgtDDR  = COARSE_MATCH_WIN_SIZE; // BaseBlock height in DDR 
        widDDR  = COARSE_MATCH_WIN_SIZE; // BaseBlock width in DDR
        GetThumbBlock(mBasePicNum, rowDDR0, colDDR0, hgtDDR, widDDR, pThumbBaseBlk);


        // RefFrame ThumbBlock (2BytePerPixel & 4ByteAlign)
        rowDDR0 = MAX(coarseBlkRow - radius, 0) ;	// RefBlock row in DDR
        colDDR0 = MAX(coarseBlkCol - radius, 0) ;
        colDDR2 = FLOOR(colDDR0 * 1.0 / 2) * 2;	// BaseBlock col in DDR (must even number)
        rowDDR1 = MIN(coarseBlkRow + COARSE_MATCH_WIN_SIZE - 1 + radius, mThumbHgt - 1) ; // RefBlock row in DDR
        colDDR1 = MIN(coarseBlkCol + COARSE_MATCH_WIN_SIZE - 1 + radius, mThumbWid - 1) ;
        colDDR3 = CEIL((colDDR1+1) * 1.0 / 2) * 2 - 1;											// RefBlock col in DDR (must odd number)
        hgtDDR  = rowDDR1 - rowDDR0 + 1;	// BaseBlock height in DDR 
        widDDR  = colDDR3 - colDDR2 + 1;    // BaseBlock width in DDR
        colStart= colDDR0 - colDDR2;       // col start in Ref Block data
        for (int k=0; k < mRawFileNum; k++)
        {
            if (pValidMark[k] == MARK_VALID_REF) // valid ref frame mark: 1
            {
#if MY_DEBUG_PRINTF == 1
                printf("classMFNR::BlockCoarseMatching()----Feature#n=%d/%d, Frame#k=%d\n", n, mNumValidFeature, k);
#endif
                // ValidRef ThumbBlock data
                GetThumbBlock(k, rowDDR0, colDDR2, hgtDDR, widDDR, pThumbRefBlk);

                // Thumb Sparse Matching
                ThumbSparseMatching(pThumbBaseBlk, COARSE_MATCH_WIN_SIZE, COARSE_MATCH_WIN_SIZE, 
                    pThumbRefBlk, widDDR, hgtDDR, colStart,
                    matchRow, matchCol, matchSad);

                // ThumbCoarseMatching Result
                *(pTmpMatchResult + 0) = matchRow + (RK_U16)rowDDR0; // match row in Raw
                *(pTmpMatchResult + 1) = matchCol + (RK_U16)colDDR2; // match col in Raw
                *(pTmpMatchResult + 2) = matchSad;	                 // match SAD in Luma
                pTmpMatchResult   += 3;

            }
            else
            {
                //pTmpMatchResult += 3; // Base || InvalidRef
                *(pTmpMatchResult + 0) = coarseBlkRow;
                *(pTmpMatchResult + 1) = coarseBlkCol;
                *(pTmpMatchResult + 2) = 0;
                pTmpMatchResult   += 3;
            }
        }
    }

    //
    return ret;

} // lassMFNR::BlockCoarseMatching()


/************************************************************************/
// Func: classMFNR::GetRaw16Block()
// Desc: Get Raw16 Block
//   In: numFrame       - cur frame number
//       rowDDR         - row in DDR
//       colDDR         - col in DDR
//       hgtDDR         - height in DDR 
//       widDDR         - width in DDR
//  Out: pRawDsp        - Raw data pointer in DSP
// 
// Date: Revised by yousf 20160503
// 
/*************************************************************************/
int classMFNR::GetRaw16Block(int numFrame, int rowDDR, int colDDR, int hgtDDR, int widDDR, RK_U16* pRawDsp)
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::GetRaw16Block()\n");
// #endif
    // init vars
    RK_U16*          pTmpSrc = NULL;                // temp pointer
    RK_U16*          pTmpDst = NULL;                // temp pointer

    //
    pTmpSrc = pRawSrcs[numFrame];
    pTmpDst = pRawDsp;
    for (int r = rowDDR; r < rowDDR + hgtDDR; r++)
    {
        memcpy(pTmpDst, (pTmpSrc + r * mRaw16Stride/2 + colDDR), sizeof(RK_U16)*widDDR);
        pTmpDst += widDDR; // 2BytePerPixel
    }


    //
    return ret;

} // classMFNR::GetRaw16Block()


/************************************************************************/
// Func: classMFNR::Scaler_Raw2Luma()
// Desc: Scaler Raw to Luma
//   In: pRawData       - Raw data pointer
//       nRawWid        - Raw data width
//       nRawHgt        - Raw data height
//       nThumbWid      - Thumb data width
//       nThumbHgt      - Thumb data height
//  Out: pThumbData     - Thumb data pointer
// 
// Date: Revised by yousf 20160504
// 
/*************************************************************************/
int classMFNR::Scaler_Raw2Luma(RK_U16* pRawData, int nRawWid, int nRawHgt, int nLumaWid, int nLumaHgt, RK_U16* pLumaData)
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::Scaler_Raw2Luma()\n");
// #endif
    // init vars
	RK_U16*         pTmp0           = NULL;             // temp pointer for Raw data
	RK_U16*         pTmp1           = NULL;             // temp pointer for Raw data
	RK_U16*         pTmp2           = NULL;             // temp pointer for Luma data
	//float           LumaValue       = 0;                // Luma Value
    RK_U16          LumaValue       = 0;                // Luma Value

    //
    if (nRawHgt/mScaleRaw2Luma != nLumaHgt)
    {
        ret = -1;
        return ret;
    }

	// Raw to Luma -- 1/(2x2)
	pTmp2 = pLumaData;
	for (int i=0; i < nLumaHgt; i++)
	{
		for (int j=0; j <nLumaWid; j++)
		{
			// 2x2 Rect left-top
			pTmp0 = pRawData + (i * nRawWid + j) * mScaleRaw2Luma;

			// average(2x2Raw) -> LumaValue
			LumaValue = 0;
			for (int m=0; m<mScaleRaw2Luma; m++)
			{
				// m-th line in 2x2 Rect
				pTmp1 = pTmp0 + m * nRawWid;
				for (int n=0; n<mScaleRaw2Luma; n++)
				{
					LumaValue += *(pTmp1++);
				}
			}
            *pTmp2 = LumaValue;
            pTmp2++;

		}
	}

    //
    return ret;
} // classMFNR::Scaler_Raw2Luma()


/************************************************************************/
// Func: classMFNR::LumaSparseMatching()
// Desc: Luma Sparse Matching
//   In: pLumaBase      - Luma Block in Base Frame
//       widBase        - width
//       hgtBase        - height
//       pLumaRef       - Luma Block in Ref Frame
//       widRef         - width
//       hgtRef         - height
//       colStart       - col start in Ref Block data
//  Out: row            - match result row
//       col            - match result row
//       sad            - match result SAD
// 
// Date: Revised by yousf 20160506
// 
/*************************************************************************/
int classMFNR::LumaSparseMatching(RK_U16* pLumaBase, int widBase, int hgtBase, RK_U16* pLumaRef, int widRef, int hgtRef, int colStart, RK_U16& row, RK_U16& col, RK_U32& sad)
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::LumaSparseMatching()\n");
// #endif
    // 
    RK_U16*         pTmpBase        = NULL;             // temp pointer
    RK_U16*         pTmpRef         = NULL;             // temp pointer
    RK_U32          minSAD;
    RK_U32          curSAD;

    // init min SAD
    minSAD = 0xFFFFFFFF; // 2^32 - 1

    //
    if (widBase != FINE_MATCH_WIN_SIZE/2 || hgtBase != FINE_MATCH_WIN_SIZE/2)
    {
        ret = -1;
        return ret;
    }

    // Matching
    for (int i=0; i < hgtRef - FINE_MATCH_WIN_SIZE/2 + 1; i++)
    {
        //for (int j=0; j < widRef - FINE_MATCH_WIN_SIZE/2 + 1; j++)
        for (int j=colStart; j < MIN(colStart + 2*FINE_LUMA_RADIUS+1, widRef-FINE_MATCH_WIN_SIZE/2+1); j++)
        {
            pTmpBase = pLumaBase;                   // Base data
            pTmpRef  = pLumaRef + i*widRef + j;     // Res data
            curSAD = 0;
            for (int m=0; m < FINE_MATCH_WIN_SIZE/2; m++)
            {
                for (int n=0; n < FINE_MATCH_WIN_SIZE/2; n++)
                {
                    //curSAD += ABS_U16(*pTmpBase - *pTmpRef);
                    curSAD += MIN(ABS_U16(*pTmpBase - *pTmpRef), 0x3F); // 32x32 * 6bitSAD -> 16bit
                    pTmpBase++;
                    pTmpRef++;
                }
                pTmpRef += (widRef - FINE_MATCH_WIN_SIZE/2);
            }
            if (curSAD < minSAD)
            {
                minSAD = curSAD;
                row    = i;
                col    = j;
            }
        }
    }

    // Matching Min SAD
    sad = minSAD;

    //
    return ret;

} // classMFNR::LumaSparseMatching()


/************************************************************************/
// Func: classMFNR::BlockFineMatching()
// Desc: Block Fine Matching
//   In: mBasePicNum		- Base Picture Num
//       pValidMark			- Frame Mark: 0-Base 1-ValidRef 2-InvalidRef
//       pMaxSharpBaseSeg	- MaxSharpness in each 32x32 Segment in BaseFrame
//       pMatchPoints		- MatchResult: { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature
//       pRawSrcs			- Raw Srcs data pointers
//  Out: pMatchPoints		- MatchResult: { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature
// 
// Date: Revised by yousf 20160506
// 
/*************************************************************************/
int classMFNR::BlockFineMatching()
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::BlockFineMatching()\n");
// #endif
    // 
    RK_U32*     pTmpBaseSegSharp = NULL;    // {[sharp_v, sharp_r, sharp_c]} * cntFeature
    RK_U16*     pTmpMatchResult  = NULL;    // { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature *2Byte
    
    // MatchPoints map to Raw 
    pTmpBaseSegSharp = pMaxSharpBaseSeg;    // {[sharp_v, sharp_r, sharp_c]} * cntFeature
    pTmpMatchResult  = pMatchPoints;        // { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature *2Byte
    for (int n=0; n < mNumValidFeature; n++)
    {
        // BaseFrame Feature: [sharp, row, col]
        pTmpBaseSegSharp++; // Thumb sharp_v
        *pTmpBaseSegSharp = *pTmpBaseSegSharp * SCALER_FACTOR_R2T; // sharp_r
        pTmpBaseSegSharp++;
        *pTmpBaseSegSharp = *pTmpBaseSegSharp * SCALER_FACTOR_R2T; // sharp_c
        pTmpBaseSegSharp++;

        // Feature belong to which Region in 4x4
        pTmpMatchResult += 2; // [RegMarkRow, RegMarkCol]

        // Matching
        for (int k=0; k < mRawFileNum; k++)
        {
            if (pValidMark[k] == MARK_VALID_REF) // valid ref frame mark: 1
            {
                // ValidRef
                *pTmpMatchResult = *pTmpMatchResult * SCALER_FACTOR_R2T;
                pTmpMatchResult++;
                *pTmpMatchResult = *pTmpMatchResult * SCALER_FACTOR_R2T;
                pTmpMatchResult++;
                pTmpMatchResult++; // sad
            }
            else
            {
                //pTmpMatchResult += 3; // Base || InvalidRef
                *pTmpMatchResult = *pTmpMatchResult * SCALER_FACTOR_R2T;
                pTmpMatchResult++;
                *pTmpMatchResult = *pTmpMatchResult * SCALER_FACTOR_R2T;
                pTmpMatchResult++;
                pTmpMatchResult++; // sad
            }
        }
    } // for n

    // Raw2Luma -> Luma Fine Matching
    int         sharp_v, sharp_r, sharp_c;
    int         sharp_r_div64, sharp_c_div64;
    int         fineBlkRow, fineBlkCol;
    int			flagRow, flagCol;				// 0-Left/Up 1-Right/Down
    int         rowDDR0, rowDDR1;				// row in DDR
    int         colDDR0, colDDR1;				// col in DDR
    int			colDDR2, colDDR3;				// Align
    int         hgtDDR;							// height in DDR 
    int         widDDR;							// width in DDR
    int         colStart;						// col start in Ref Block data
    RK_U16      matchRow, matchCol;				// match result
    RK_U32      matchSad;						// match SAD
    int         radius  = FINE_LUMA_RADIUS * 2; // search radius in Raw

    // Matching
    pTmpBaseSegSharp = pMaxSharpBaseSeg; // {[sharp_v, sharp_r, sharp_c]} * cntFeature
    pTmpMatchResult  = pMatchPoints;     // { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature *2Byte
    for (int n=0; n < mNumValidFeature; n++)    // num of Valid Feature
    {
        // BaseFrame Feature: [sharp, row, col]
        sharp_v = *(pTmpBaseSegSharp + 0);
        sharp_r = *(pTmpBaseSegSharp + 1);
        sharp_c = *(pTmpBaseSegSharp + 2);
        pTmpBaseSegSharp += 3;

        // Feature belong to which Region in 4x4
        *(pTmpMatchResult + 0) = sharp_r / (mRawHgt / NUM_DIVIDE_IMAGE); // RegMarkRow in 4x4
        *(pTmpMatchResult + 1) = sharp_c / (mRawWid / NUM_DIVIDE_IMAGE); // RegMarkCol in 4x4
        pTmpMatchResult   += 2;

        // select 64x64Block in BaseRaw
        sharp_r_div64 = sharp_r / FINE_MATCH_WIN_SIZE; // floor div64
        sharp_c_div64 = sharp_c / FINE_MATCH_WIN_SIZE; // floor div64

        // block(row, col) 64x64
        fineBlkRow = FINE_MATCH_WIN_SIZE * sharp_r_div64;
        fineBlkCol = FINE_MATCH_WIN_SIZE * sharp_c_div64;

        // BaseFrame RawBlock
        rowDDR0 = fineBlkRow;          // BaseBlock row in DDR
        colDDR0 = fineBlkCol;          // BaseBlock col in DDR
        hgtDDR  = FINE_MATCH_WIN_SIZE; // BaseBlock height in DDR 
        widDDR  = FINE_MATCH_WIN_SIZE; // BaseBlock width in DDR
        
        // Base data
        GetRaw16Block(mBasePicNum, rowDDR0, colDDR0, hgtDDR, widDDR, pRawBaseBlk);
        Scaler_Raw2Luma(pRawBaseBlk, widDDR, hgtDDR, widDDR/2, hgtDDR/2, pRawBaseBlkLuma);

        // which 64x64 in 256x256
        flagRow = 1;
        flagCol = 1;
        if (fineBlkRow == *(pTmpMatchResult + mBasePicNum*3 + 0))
        {
            flagRow = 0;	// Up
        }
        if (fineBlkCol == *(pTmpMatchResult + mBasePicNum*3 + 1))
        {
            flagCol = 0;	// Left
        }

        // Matching
        for (int k=0; k < mRawFileNum; k++)
        {
            if (pValidMark[k] == MARK_VALID_REF) // valid ref frame mark: 1
            {
#if MY_DEBUG_PRINTF == 1
                printf("classMFNR::BlockFineMatching()----Feature#n=%d/%d, Frame#k=%d\n", n, mNumValidFeature, k);
#endif
                // ValidRef
                matchRow = *(pTmpMatchResult + 0); // coarse matching result
                matchCol = *(pTmpMatchResult + 1); // coarse matching result

                // RefFrame RawBlock
                rowDDR0 = MAX(matchRow + flagRow*FINE_MATCH_WIN_SIZE - radius, 0) ;	// RefBlock row in DDR
                colDDR0 = MAX(matchCol + flagCol*FINE_MATCH_WIN_SIZE - radius, 0) ; // RefBlock col in DDR
                //colDDR2 = FLOOR(colDDR0 * 10.0 / 160) * 16;		    // col in Pixel
                colDDR2 = colDDR0;
                rowDDR1 = MIN(matchRow + flagRow*FINE_MATCH_WIN_SIZE + FINE_MATCH_WIN_SIZE - 1 + radius, mRawHgt - 1) ; // RefBlock row in DDR
                colDDR1 = MIN(matchCol + flagCol*FINE_MATCH_WIN_SIZE + FINE_MATCH_WIN_SIZE - 1 + radius, mRawWid - 1) ; // RefBlock col in DDR
                //colDDR3 = CEIL((colDDR1+1) * 10.0 / 160) * 16 - 1;	// col in Pixel											
                colDDR3 = colDDR1;
                hgtDDR  = rowDDR1 - rowDDR0 + 1;    // RefBlock height in DDR 
                widDDR  = colDDR3 - colDDR2 + 1;    // 20Byte -> 16Pixel
                colStart= colDDR0 - colDDR2;       // col start in Ref Block data

                // Ref data
                GetRaw16Block(k, rowDDR0, colDDR2, hgtDDR, widDDR, pRawRefBlk);
                Scaler_Raw2Luma(pRawRefBlk, widDDR, hgtDDR, widDDR/2, hgtDDR/2, pRawRefBlkLuma);
                
                // Luma Sparse Matching
                LumaSparseMatching(pRawBaseBlkLuma, FINE_MATCH_WIN_SIZE/2, FINE_MATCH_WIN_SIZE/2, 
                    pRawRefBlkLuma, widDDR/2, hgtDDR/2, colStart/2,
                    matchRow, matchCol, matchSad);

                // LumaFineMatching Result
                *(pTmpMatchResult + 0) = matchRow*2 + (RK_U16)rowDDR0; // match row in Raw
                *(pTmpMatchResult + 1) = matchCol*2 + (RK_U16)colDDR2; // match col in Raw
//                *(pTmpMatchResult + 2) = matchSad;					   // match SAD in Luma
                *(pTmpMatchResult + 2) = ROUND_U16( (sharp_v << 16) * 1.0 / matchSad ); // wgt = Sharp / matchSAD
                pTmpMatchResult   += 3;
            }
            else
            {
                //pTmpMatchResult += 3; // Base || InvalidRef
                *(pTmpMatchResult + 0) = fineBlkRow;
                *(pTmpMatchResult + 1) = fineBlkCol;
                *(pTmpMatchResult + 2) = 0; // wgt=0 in BaseFrame or InvalidRefFrame
                pTmpMatchResult   += 3;
            }
        }
    } // for n

    //
    return ret;

} // classMFNR::BlockFineMatching()


/************************************************************************/
// Func: classMFNR::GetRegion4Points()
// Desc: Get 4 points in 4 Regions
//   In: pAgents        - Agents in 4x4 Region
//       wid            - Agents width
//       pTable         - Region4 Index Table
//       idx            - Region4 Index Table idx
//       numBase        - number of Base Frame
//       numRef         - number of Ref Frame
//  Out: pPoints4       - 4 points in 4 Regions
// 
// Date: Revised by yousf 20160503
// 
/*************************************************************************/
int classMFNR::GetRegion4Points(RK_U16* pAgents, int wid, RK_U8* pTable, int idx, int numBase, int numRef, RK_U16* pPoints4)
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::GetRegion4Points()\n");
// #endif
    // Region4 Index Table[idx]
    RK_U8* pTableItem = NULL;
    pTableItem = pTable + idx * 4; 

    // Get 4 points in 4 Regions
    for (int i=0; i < 4; i++)
    {
        if (*(pAgents + *(pTableItem+i) * wid + 0) == MARK_EXIST_AGENT)     // mark
        {
            // BaseFrame Point
            *(pPoints4 + i*4 + 0) = *(pAgents + *(pTableItem+i) * wid + 2 + numBase * 2 + 0);
            *(pPoints4 + i*4 + 1) = *(pAgents + *(pTableItem+i) * wid + 2 + numBase * 2 + 1);
            // RefFrame Matching Point
            *(pPoints4 + i*4 + 2) = *(pAgents + *(pTableItem+i) * wid + 2 + numRef * 2 + 0);
            *(pPoints4 + i*4 + 3) = *(pAgents + *(pTableItem+i) * wid + 2 + numRef * 2 + 1);
        }
        else
        {
            ret = -1;
            return ret;
        }
    }

    //
    return ret;

} // classMFNR::GetRegion4Points()


/************************************************************************/
// Func: classMFNR::CreateCoefficient()
// Desc: Create Coefficient MatrixA & VectorB
//   In: pPoints4       - 4 points in 4 Regions
//  Out: pMatA          - Coefficient MatrixA for A*X = B
//       pVecB          - Coefficient VectorB for A*X = B
// 
// Date: Revised by yousf 20160507
// 
/*************************************************************************/
int classMFNR::CreateCoefficient(RK_U16* pPoints4, RK_F32* pMatA, RK_F32* pVecB)
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::CreateCoefficient()\n");
// #endif
    // pPoints4: Base & Ref
    /*
    RK_U16 x00, y00, x01, y01; // 0-pair Matching Points
    RK_U16 x10, y10, x11, y11; // 1-pair Matching Points
    RK_U16 x20, y20, x21, y21; // 2-pair Matching Points
    RK_U16 x30, y30, x31, y31; // 3-pair Matching Points
    */

    //              MatrixA                    VectorB
    /*
    x00 y00 1  0   0   0  -x00*x01 - y00*y01        x01    
    0   0   0  x00 y00 1  -x00*y01 - y00*y01        x01 
    ......
    */

    // Create Coefficient MatrixA & VectorB
    for (int i=0; i < 8; i++)
    {
        if (i<4)
        {
            //-- MatrixA
            *(pMatA + i * 8 + 0) = *(pPoints4 + i*4 + 0); // p[i,0]
            *(pMatA + i * 8 + 1) = *(pPoints4 + i*4 + 1); // p[i,1]
            *(pMatA + i * 8 + 2) = 1;
            *(pMatA + i * 8 + 3) = 0;
            *(pMatA + i * 8 + 4) = 0;
            *(pMatA + i * 8 + 5) = 0;
            *(pMatA + i * 8 + 6) = (RK_F32)(-1 * *(pPoints4 + i*4 + 0) * *(pPoints4 + i*4 + 2)); // p[i,0] * p[i,2]
            *(pMatA + i * 8 + 7) = (RK_F32)(-1 * *(pPoints4 + i*4 + 1) * *(pPoints4 + i*4 + 2)); // p[i,1] * p[i,2]
            //-- VectorB
            *(pVecB + i)         =  *(pPoints4 + i*4 + 2); // p[i,2] = x[i,1]
        }
        else
        {
            //-- MatrixA
            *(pMatA + i * 8 + 0) = 0;
            *(pMatA + i * 8 + 1) = 0;
            *(pMatA + i * 8 + 2) = 0;
            *(pMatA + i * 8 + 3) = *(pPoints4 + (i-4)*4 + 0); // p[i,0]
            *(pMatA + i * 8 + 4) = *(pPoints4 + (i-4)*4 + 1); // p[i,1]
            *(pMatA + i * 8 + 5) = 1;
            *(pMatA + i * 8 + 6) = (RK_F32)(-1 * *(pPoints4 + (i-4)*4 + 0) * *(pPoints4 + (i-4)*4 + 3)); // p[i,0] * p[i,3]
            *(pMatA + i * 8 + 7) = (RK_F32)(-1 * *(pPoints4 + (i-4)*4 + 1) * *(pPoints4 + (i-4)*4 + 3)); // p[i,1] * p[i,3]
            //-- VectorB
            *(pVecB + i)         =  *(pPoints4 + (i-4)*4 + 3); // p[i,3] = y[i,1]
        }
    }
    
    //
    return ret;

} // classMFNR::CreateCoefficient()


/************************************************************************/
// Func: classMFNR::GetPerspectMatrix()
// Desc: Get a PersPective Matrix
//   In: pMatA          - Coefficient MatrixA for A*X = B
//       pVecB          - Coefficient VectorB for A*X = B
//  Out: pVecX          - Coefficient VectorX for A*X = B
// 
// Date: Revised by yousf 20160503
// 
/*************************************************************************/
int classMFNR::GetPerspectMatrix(RK_F32* pMatA, RK_F32* pVecB, RK_F32* pVecX)
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::GetPerspectMatrix()\n");
// #endif
    // init vars
    int     i, j, k;
    float   s, t;
    int     n = 8;

    // Gaussian Elimination with Complete Pivoting    st. Ax=b -> Ux=b'
    for (k = 0; k < n; k++)
    {
        // Select Pivot Element: max_i(a[i,j])  
        j = k;  
        t = FABS(pMatA[k*n + k]);
        for (i = k + 1; i<n; i++)
        {
            if ((s = FABS(pMatA[i*n + k])) > t)
            {
                t = s; // max_i{pMatA(i,k)}
                j = i; // argmax_i{pMatA(i,k)}
            }
        }

        //  Ill-conditioned Equation
        if (t < 1.0e-30) 
        {
            ret = -1;
            return ret;  
        }

        // Exchange: pMatA(j,:) - pMatA(k,:)
        if (j != k)
        {
            for (i = k; i < n; i++)
            {
                t              = pMatA[j*n + i];
                pMatA[j*n + i] = pMatA[k*n + i];
                pMatA[k*n + i] = t;
            }
            t        = pVecB[j];
            pVecB[j] = pVecB[k];
            pVecB[k] = t;
        }

        // Recalculation pMatA(k,k:n-1): <- pMatA(k,k) = 1
        t = (RK_F32)(1.0 / pMatA[k*n + k]); 
        //for (i = k + 1; i < n; i++) 
        for (i = k ; i < n; i++) 
        {
            pMatA[k*n + i] *= t;
        }
        pVecB[k] *= t;

        // Elimination: pMatA(k+1:n-1,:)
        for (i = k + 1; i < n; i++)
        {
            t = pMatA[i*n + k];
            //for (j = k + 1; j < n; j++) 
            for (j = k; j < n; j++) 
            {
                pMatA[i*n + j] -= pMatA[k*n + j] * t;
            }
            pVecB[i] -= pVecB[k] * t;
        }
    }

    // U * X = b'  -> X 
    pVecX[n-1] = pVecB[n-1];
    for (i = n - 2; i >= 0; i--)
    {
        for (j = i + 1; j < n; j++) 
        {
            pVecB[i] -= pMatA[i*n + j] * pVecB[j];
        }
        pVecX[i] = pVecB[i];
    }
    
    //
    return ret;

} // classMFNR::GetPerspectMatrix()


/************************************************************************/
// Func: classMFNR::PerspectProject()
// Desc: Perspective Project: pVecX * pBasePoint = pProjectPoint
//   In: pVecX          - Coefficient VectorX for A*X = B
//       pBasePoint     - PointB(r,c) in BaseFrame
//  Out: pProjectPoint  - Perspective Projected PointP(r,c) in RefFrame
// 
// Date: Revised by yousf 20160507
// 
/*************************************************************************/
int classMFNR::PerspectProject(RK_F32* pVecX, RK_U16* pBasePoint, RK_S32* pProjectPoint)
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::PerspectProject()\n");
// #endif
	// Perspective Projected Coordinate
    RK_F32          X;
    RK_F32          Y;
    RK_F32          Z;
    // Perspective Projected
    //        A(0,0) * Bx                        A(0,1) * By                   A(0,2) * 1
    X = *(pVecX + 0) * *(pBasePoint + 0) + *(pVecX + 1) * *(pBasePoint + 1) + *(pVecX + 2);
    //        A(1,0) * Bx                        A(1,1) * By                   A(1,2) * 1
    Y = *(pVecX + 3) * *(pBasePoint + 0) + *(pVecX + 4) * *(pBasePoint + 1) + *(pVecX + 5);
    //        A(2,0) * Bx                        A(2,1) * By                   A(2,2) * 1
    Z = *(pVecX + 6) * *(pBasePoint + 0) + *(pVecX + 7) * *(pBasePoint + 1) + *(pVecX + 8);

    // Normalization
    *(pProjectPoint + 0) = ROUND_I32(X / Z);
    *(pProjectPoint + 1) = ROUND_I32(Y / Z);

    //
    return ret;
    
} // classMFNR::PerspectProject()


/************************************************************************/
// Func: classMFNR::ComputeHomography()
// Desc: Compute Homography
//   In: pMaxSharpBaseSeg	- MaxSharpness in each 32x32 Segment in BaseFrame
//       pMatchPoints		- MatchResult: { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature
//  Out: pHomographyMatrix  - Homography: [9*RawFileNum] * 4Byte
// 
// Date: Revised by yousf 20160714
// 
/*************************************************************************/
int classMFNR::ComputeHomography()
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::ComputeHomography()\n");
// #endif
    //
    RK_U32*     pTmpBaseSegSharp = NULL;    // {[sharp_v, sharp_r, sharp_c]} * cntFeature
    RK_U16*     pTmpMatchResult  = NULL;    // { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature *2Byte
    int         Index4x4;       // Index:0 -- (NUM_DIVIDE_IMAGE * NUM_DIVIDE_IMAGE - 1)
    RK_U16      wgt;            // wgt = sum(Sharp/SAD)
    int         rowDif;         // feature(row) - rect_top
    int         colDif;         // feature(col) - rect_left
    int         cnt4x4Region;   // count Agents In 4x4 Region
    int         sharp_v, sharp_r, sharp_c;

    // Matching Result
    pTmpBaseSegSharp = pMaxSharpBaseSeg; // {[sharp_v, sharp_r, sharp_c]} * cntFeature
    pTmpMatchResult  = pMatchPoints;     // { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature *2Byte

    // MatchingResult in Raw -> Luma
    for (int n=0; n < mNumValidFeature; n++)
    {
        // BaseFrame Feature: [sharp, row, col]
        sharp_v = *(pTmpBaseSegSharp++);
        sharp_r = *(pTmpBaseSegSharp++);
        sharp_c = *(pTmpBaseSegSharp++);

        pTmpMatchResult += 2;

        rowDif = sharp_r - *(pTmpMatchResult + 3 * mBasePicNum + 0);
        colDif = sharp_c - *(pTmpMatchResult + 3 * mBasePicNum + 1);

        // MatchingRects -> MatchingPoints
        for (int k=0; k < mRawFileNum; k++)
        {
            // row col sad
            *pTmpMatchResult += rowDif;
            *pTmpMatchResult /= 2; // Raw->Luma
            pTmpMatchResult++;
            *pTmpMatchResult += colDif;
            *pTmpMatchResult /= 2; // Raw->Luma
            pTmpMatchResult++;
            pTmpMatchResult++; // SAD
        }
    }

    
    // Compute RawFileNum-1 Best Homography for BaseFrame--RefFrame(#0 ~ RawFileNum-1)
    int         idxTable;                   // index in Region4IndexTable
    RK_U16*     pBasePoint      = NULL;     // temp pointer
    RK_U16*     pRefPoint       = NULL;     // temp pointer
    RK_U16      errRow, errCol;             // Project Errors: row error & col error
    int         corrCnt;                    // Correct Project Count <-- Error Threshold of Valid Homography
#if USE_EARLY_STOP_H == 1 // 1-use Early Stop Compute Homography
	int         goodCnt;                    // Correct Project Count <-- Error Threshold of Good Homography
#endif
    RK_U16      errSum_H;                   // Sum Project Errors: sum error of all features
    RK_U16      errMin_H;                   // Min Project Errors: min error of best Homography for BaseFrame--RefFrame#k
    RK_F32*     pHomogMat       = NULL;     // temp pointer
    // 
#if USE_MV_HIST_FILTRATE == 1
    int     MVy, MVx;
    int     minNumValidFeat = MAX((int)(mNumValidFeature * VALID_FEATURE_RATIO), 1);
#endif
    //
    for (int k=0; k < mRawFileNum; k++)
    {
        // Min Project Errors
        errMin_H  = (1 << 16) - 1; // init

        // Homography
        pHomogMat = pHomographyMatrix + 9*k; // Homography: [9*RawFileNum] * 4Byte
        // init eye(3)
        memset(pHomogMat, 0, sizeof(RK_F32)*9);         
        pHomogMat[0] = 1;   // H(0,0)
        pHomogMat[4] = 1;   // H(1,1)
        pHomogMat[8] = 1;   // H(2,2)

        //---- Compute a Best Homography for BaseFrame--RefFrame#k
        if (pValidMark[k] == MARK_VALID_REF) // valid ref frame mark: 1
        {

            //////////////////////////////////////////////////////////////////////////
#if USE_MV_HIST_FILTRATE == 1
            //-- Filtrate: Match Feature in BaseFrame & RefFrame#k

            // MV Hist
            pTmpMatchResult  = pMatchPoints;     // { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature *2Byte
            memset(pRowMvHist, 0, sizeof(RK_U8) * LEN_MV_HIST);
            memset(pColMvHist, 0, sizeof(RK_U8) * LEN_MV_HIST);
            for (int n=0; n < mNumValidFeature; n++)
            {
                // Feature belong to which Region in 4x4
                pTmpMatchResult += 2;

                // MVy
                MVy = *(pTmpMatchResult + mBasePicNum*3 + 0) - *(pTmpMatchResult + k*3 + 0);
                MVx = *(pTmpMatchResult + mBasePicNum*3 + 1) - *(pTmpMatchResult + k*3 + 1);
                pRowMvHist[HALF_LEN_MV_HIST + MVy] += 1; // hist +1
                pColMvHist[HALF_LEN_MV_HIST + MVx] += 1; // hist +1

                // Next Feature
                pTmpMatchResult += 3*mRawFileNum;
            }

            // MV Hist --> HistMark(0 or 1)
            for (int h=0; h < LEN_MV_HIST; h++)
            {
                // MVy
                if (pRowMvHist[h] > minNumValidFeat)
                {
                    pRowMvHist[h] = 1;  // Valid MVy
                }
                else
                {
                    pRowMvHist[h] = 0;  // Invalid MVy
                }
                // MVx
                if (pColMvHist[h] > minNumValidFeat)
                {
                    pColMvHist[h] = 1;  // Valid MVx
                }
                else
                {
                    pColMvHist[h] = 0;  // Invalid MVx
                }
            }

            // HistMark(0 or 1) --> pMarkMatchFeature
            memset(pMarkMatchFeature, 0, sizeof(RK_U8) * MAX_NUM_MATCH_FEATURE);
            if (mNumValidFeature > MAX_NUM_MATCH_FEATURE)
            {
                ret = -1;
                printf("Param Setting Error: MAX_NUM_MATCH_FEATURE is too small !\n");
                return ret;
            }
            pTmpMatchResult  = pMatchPoints;     // { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature *2Byte
            for (int n=0; n < mNumValidFeature; n++)
            {
                // Feature belong to which Region in 4x4
                pTmpMatchResult += 2;

                // MVy
                MVy = *(pTmpMatchResult + mBasePicNum*3 + 0) - *(pTmpMatchResult + k*3 + 0);
                MVx = *(pTmpMatchResult + mBasePicNum*3 + 1) - *(pTmpMatchResult + k*3 + 1);
                
                // Valid Feature
                if (pRowMvHist[HALF_LEN_MV_HIST + MVy] == 1 && pColMvHist[HALF_LEN_MV_HIST + MVx] == 1)
                {
                    pMarkMatchFeature[n] = 1; // Valid Feature
                }
                
                // Next Feature
                pTmpMatchResult += 3*mRawFileNum;

            }

#else
            memset(pMarkMatchFeature, 1, sizeof(RK_U8) * MAX_NUM_MATCH_FEATURE);
#endif
            //////////////////////////////////////////////////////////////////////////


            //-- Agents in 4x4 Region for BaseFrame & RefFrame#k
            cnt4x4Region = 0;
            pTmpBaseSegSharp = pMaxSharpBaseSeg; // {[sharp_v, sharp_r, sharp_c]} * cntFeature
            pTmpMatchResult  = pMatchPoints;     // { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature *2Byte
            memset(pAgentsIn4x4Region, 0, sizeof(RK_U16) * NUM_DIVIDE_IMAGE * NUM_DIVIDE_IMAGE * (2 + 2 * mRawFileNum));
            for (int n=0; n < mNumValidFeature; n++)
            {
                if (pMarkMatchFeature[n] == 1) // Valid Feature
                {
#if MY_DEBUG_PRINTF == 1
                    printf("classMFNR::ComputeHomography()----Frame#k=%d, Feature#n=%d/%d\n", k, n, mNumValidFeature);
#endif
                    // BaseFrame Feature: [sharp, row, col]
                    sharp_v = *(pTmpBaseSegSharp + 0);
                    sharp_r = *(pTmpBaseSegSharp + 1);
                    sharp_c = *(pTmpBaseSegSharp + 2);
                    pTmpBaseSegSharp += 3;

                    // Feature belong to which Region in 4x4
                    Index4x4 = *(pTmpMatchResult + 0) * NUM_DIVIDE_IMAGE + *(pTmpMatchResult + 1);
                    pTmpMatchResult += 2;

                    // wgt = Sharp / matchSAD <-- BaseFrame & RefFrame#k
                    wgt = *(pTmpMatchResult + k*3 + 2);

                    // Init or Update AgentsIn4x4Region
                    if (pAgentsIn4x4Region[Index4x4 * (2 + 2*mRawFileNum) + 0] == MARK_EXIST_AGENT)    // mark of ExistAgent in 4x4 Region
                    {
                        if (wgt > pAgentsIn4x4Region[Index4x4 * (2 + 2*mRawFileNum) + 1])              // bigger wgt
                        {
                            pAgentsIn4x4Region[Index4x4 * (2 + 2*mRawFileNum) + 0] = MARK_EXIST_AGENT; // mark
                            pAgentsIn4x4Region[Index4x4 * (2 + 2*mRawFileNum) + 1] = wgt;              // Sharp/SAD

                            // MatchingPoints
                            for (int kk=0; kk < mRawFileNum; kk++)
                            {
                                // row col sad
                                pAgentsIn4x4Region[Index4x4 * (2 + 2*mRawFileNum) + 2 + kk*2 + 0] = *(pTmpMatchResult + kk*3 + 0);
                                pAgentsIn4x4Region[Index4x4 * (2 + 2*mRawFileNum) + 2 + kk*2 + 1] = *(pTmpMatchResult + kk*3 + 1);
                            }
                        }
                    }
                    else
                    {
                        // New Agents In 4x4 Region
                        cnt4x4Region++; 
                        pAgentsIn4x4Region[Index4x4 * (2 + 2*mRawFileNum) + 0] = MARK_EXIST_AGENT;     // mark
                        pAgentsIn4x4Region[Index4x4 * (2 + 2*mRawFileNum) + 1] = wgt;                  // Sharp/SAD

                        // MatchingPoints
                        for (int kk=0; kk < mRawFileNum; kk++)
                        {
                            // row col sad
                            pAgentsIn4x4Region[Index4x4 * (2 + 2*mRawFileNum) + 2 + kk*2 + 0] = *(pTmpMatchResult + kk*3 + 0);
                            pAgentsIn4x4Region[Index4x4 * (2 + 2*mRawFileNum) + 2 + kk*2 + 1] = *(pTmpMatchResult + kk*3 + 1);
                        }
                    } // if

                    pTmpMatchResult += 3*mRawFileNum;
                }
                else
                {
                    pTmpBaseSegSharp += 3;
                    pTmpMatchResult += (2+3*mRawFileNum);
                }
            } // for n = Features

            //// num Region must be >= 4
            if (cnt4x4Region >= 4)
            {
                // 
                idxTable = 0;   // index in Region4IndexTable: m <= idxTable
                for (int m=0; m < NUM_HOMOGRAPHY; m++)
                {
                    //-- Get Valid 4-Points
                    ret = -1;
                    while (ret && idxTable < NUM_R4IT_CHOICE)
                    {
                        // Get 4 points in 4 Regions
                        ret = GetRegion4Points(pAgentsIn4x4Region, (2 + 2*mRawFileNum), Region4IndexTable, idxTable, mBasePicNum, k, pRegion4Points);
                        // Next Item in Region4IndexTable
                        idxTable++; 
                    }

                    //-- Create Coefficient MatrixA & VectorB
                    ret = CreateCoefficient(pRegion4Points, pMatrixA, pVectorB);
                    if (ret)
                    {
                        printf("Failed to Create Coefficient MatrixA & VectorB !\n");
                        //return ret;
						continue;
                    }

                    //-- Compute a Homography
                    pVectorX[8] = 1;
                    ret = GetPerspectMatrix(pMatrixA, pVectorB, pVectorX);
                    if (ret)
                    {
                        printf("Failed to Compute a Homography !\n");
                        //return ret;

						// init eye(3)
						memset(pHomogMat, 0, sizeof(RK_F32)*9);         
						pHomogMat[0] = 1;   // H(0,0)
						pHomogMat[4] = 1;   // H(1,1)
						pHomogMat[8] = 1;   // H(2,2)
						//break;
						continue;

                    }

                    //-- Agents' Error
                    corrCnt = 0;    // Correct Project Count <-- Error Threshold of Valid Homography
#if USE_EARLY_STOP_H == 1 // 1-use Early Stop Compute Homography
					goodCnt = 0;	// Correct Project Count <-- Error Threshold of Good Homography
#endif
                    for (int n=0; n < NUM_DIVIDE_IMAGE*NUM_DIVIDE_IMAGE; n++)
                    {
                        if (pAgentsIn4x4Region[n * (2 + 2*mRawFileNum) + 0] == MARK_EXIST_AGENT)
                        {
                            // Perspective Project: pVecX * pBasePoint = pProjectPoint
                            pBasePoint    = pAgentsIn4x4Region + n * (2 + 2*mRawFileNum) + 2 + 2 * mBasePicNum;
                            pRefPoint     = pAgentsIn4x4Region + n * (2 + 2*mRawFileNum) + 2 + 2 * k;
                            ret = PerspectProject(pVectorX, pBasePoint, pProjectPoint);
                            if (ret)
                            {
                                printf("Failed to PerspectProject !\n");
                                //return ret;
								continue;
                            }

                            // Project Errors
                            errRow = ABS_U16(pRefPoint[0] - pProjectPoint[0]);
                            errCol = ABS_U16(pRefPoint[1] - pProjectPoint[1]);   

                            // Error Threshold of Valid Homography
                            if (errRow <= ERR_TH_VALID_H && errCol <= ERR_TH_VALID_H)
                            {
                                corrCnt++; // Correct Project Count <-- Error Threshold of Valid Homography
                            }

#if USE_EARLY_STOP_H == 1 // 1-use Early Stop Compute Homography
							// Error Threshold of Good Homography
							if (errRow <= ERR_TH_GOOD_H && errCol <= ERR_TH_GOOD_H)
							{
								goodCnt++; // Correct Project Count <-- Error Threshold of Good Homography
							}
#endif

                        }
                    } // for n

#if USE_EARLY_STOP_H == 1 // 1-use Early Stop Compute Homography
					if (goodCnt > cnt4x4Region * GOOD_CNT_H_RATIO)// && goodCnt > CRRCNT_TH_VALID_H)
					{
						memcpy(pHomogMat, pVectorX, sizeof(RK_F32)*9);
						break;
					}
#endif

                    //-- Correct Count Threshold of Valid Homography
                    if (corrCnt > CRRCNT_TH_VALID_H)
                    {
                        // Compute Homography Error: All Features
                        errSum_H         = 0;                           // init
                        for (int n=0; n < mNumValidFeature; n++)
                        {
                            if (pMarkMatchFeature[n] == 1) // Valid Feature
                            {
                                // Perspective Project: pVecX * pBasePoint = pProjectPoint
                                pBasePoint    = pMatchPoints + n * (2 + 3*mRawFileNum) + 2 + 3 * mBasePicNum;
                                pRefPoint     = pMatchPoints + n * (2 + 3*mRawFileNum) + 2 + 3 * k;
                                ret = PerspectProject(pVectorX, pBasePoint, pProjectPoint);
                                if (ret)
                                {
                                    printf("Failed to PerspectProject !\n");
                                    //return ret;
									continue;
                                }

                                // Project Errors: row error & col error
                                errRow = ABS_U16(pRefPoint[0] - pProjectPoint[0]);
                                errCol = ABS_U16(pRefPoint[1] - pProjectPoint[1]);
                                errRow = MIN(errRow, MAX_PROJECT_ERROR);
                                errCol = MIN(errCol, MAX_PROJECT_ERROR);

                                // Sum Project Errors: sum error of all features
                                errSum_H += (errRow + errCol); 
                            }
                        }

                        // Better Homography
						RK_F32 offset1 = (FABS(*(pHomogMat+2)) + FABS(*(pHomogMat+5)));
						RK_F32 offset2 = (FABS(*(pVectorX+2)) + FABS(*(pVectorX+5)));
                        if (errSum_H < errMin_H)
                        {
                            // Update H: Min Project Errors & Homography
                            errMin_H = errSum_H;
                            memcpy(pHomogMat, pVectorX, sizeof(RK_F32)*9);
                        }
						else if (errSum_H == errMin_H) // Modify by yousf20160713
						{
							// Update H: Min Offset
							if ( offset1 > offset2 )
							{
								errMin_H = errSum_H;
								memcpy(pHomogMat, pVectorX, sizeof(RK_F32)*9);
							}
						}
						// Modify by yousf20160713
						if (errSum_H < 2 && offset2 == 0 && corrCnt > cnt4x4Region*0.9) 
						{
							// Update H: eye(3) & corrCnt
							memcpy(pHomogMat, pVectorX, sizeof(RK_F32)*9);
							break;
						}
						

                    } // if corrCnt

                } // for m

            } // if (cnt4x4Region >= 4)

        } // if pValidMark[k]
        else
        {
            // Base || InvalidRef
            pHomogMat[0] = 1;   // H(0,0)
            pHomogMat[4] = 1;   // H(1,1)
            pHomogMat[8] = 1;   // H(2,2)
        } // if pValidMark[k]

    } // for k

    //
    return ret;

} // classMFNR::ComputeHomography()


/************************************************************************/
// Func: classMFNR::PullRaw16Block()
// Desc: Pull Raw16 Block
//   In: pRawDsp        - Raw data pointer in DSP
//       rowDDR         - row in DSP
//       colDDR         - col in DSP
//       hgtDDR         - height in DSP 
//       widDDR         - width in DSP
//  Out: pRawDst        - Raw Dst data pointer
// 
// Date: Revised by yousf 20160624
// 
/*************************************************************************/
int classMFNR::PullRaw16Block(RK_U16* pRawDsp, int rowDDR, int colDDR, int hgtDDR, int widDDR)
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::PullRaw16Block()\n");
// #endif
    // init vars
    RK_U16*          pTmpSrc = NULL;                // temp pointer
    RK_U16*          pTmpDst = NULL;                // temp pointer

    //
    pTmpSrc = pRawDsp;
    pTmpDst = pRawDst;
    for (int r = rowDDR; r < rowDDR + hgtDDR; r++)
    {
		// mTestParams[9]    1-NonOverlap, 2-OverlapStep1/2, 4-OverlapStep1/4, ...
		if (mTestParams[9] == 1)
		{
			memcpy((pTmpDst + r * mRaw16Stride/2 + colDDR), pTmpSrc, sizeof(RK_U16)*widDDR);
		}
		else if (RK_U16(mTestParams[9]) % 2 == 0)
		{
			for (int c=0; c < widDDR; c++)
			{
				*(pTmpDst + r * mRaw16Stride/2 + colDDR + c) += *(pTmpSrc + c);
			}
			
		}
        

        pTmpSrc += widDDR; // 2BytePerPixel
    }

    //
    return ret;

} // classMFNR::PullRaw16Block()



/************************************************************************/
// Func: classMFNR::LumaDenseMatching()
// Desc: Luma Dense Matching
//   In: pLumaBase      - Luma Block in Base Frame
//       widBase        - width
//       hgtBase        - height
//       pLumaRef       - Luma Block in Ref Frame
//       widRef         - width
//       hgtRef         - height
//       colStart       - col start in Ref Block data
//  Out: row            - match result row
//       col            - match result row
//       sad            - match result SAD
// 
// Date: Revised by yousf 20160506
// 
/*************************************************************************/
int classMFNR::LumaDenseMatching(RK_U16* pLumaBase, int widBase, int hgtBase, RK_U16* pLumaRef, int widRef, int hgtRef, int colStart, RK_U16& row, RK_U16& col, RK_U16& sad)
{
    // common vars
    int             ret             = 0;			    // status init
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::LumaDenseMatching()\n");
// #endif
    // 
    RK_U16*         pTmpBase        = NULL;             // temp pointer
    RK_U16*         pTmpRef         = NULL;             // temp pointer
    RK_U32          minSAD;
    RK_U32          curSAD;

    // init min SAD
    minSAD = 0xFFFFFFFF; // 2^32 - 1

    //
    if (widBase != LUMA_MATCH_WIN_SIZE/2 || hgtBase != LUMA_MATCH_WIN_SIZE/2)
    {
        ret = -1;
        return ret;
    }

    // Matching
    for (int i=0; i < hgtRef - LUMA_MATCH_WIN_SIZE/2 + 1; i++)
    {
        //for (int j=0; j < widRef - LUMA_MATCH_WIN_SIZE/2 + 1; j++)
        for (int j=colStart; j < MIN(colStart + 2*LUMA_MATCH_RADIUS+1, widRef - LUMA_MATCH_WIN_SIZE/2 + 1); j++)
        {
            pTmpBase = pLumaBase;                   // Base data
            pTmpRef  = pLumaRef + i*widRef + j;     // Res data
            curSAD = 0;
            for (int m=0; m < LUMA_MATCH_WIN_SIZE/2; m++)
            {
                for (int n=0; n < LUMA_MATCH_WIN_SIZE/2; n++)
                {
                    //curSAD += ABS_U16(*pTmpBase - *pTmpRef);
                    curSAD += MIN(ABS_U16(*pTmpBase - *pTmpRef), 0xFF); // 16x16 * 8bitSAD -> 16bit
                    pTmpBase++;

                    pTmpRef++;
                }
                pTmpRef += (widRef - LUMA_MATCH_WIN_SIZE/2);
            }
            if (curSAD < minSAD)
            {
                minSAD = curSAD;
                row    = i;
                col    = j;
            }
        }
    }

    //sad = minSAD >> 8;
    sad = minSAD;

    //
    return ret;

} // classMFNR::LumaDenseMatching()


/************************************************************************/
// Func: classMFNR::MotionDetectFilter()
// Desc: Motion Detect Filter
//   In: pRawData       - Raw data pointer
//       wid            - width
//       hgt            - height
//  Out: pFiltData		- Filtered data pointer
// 
// Date: Revised by yousf 20160624
// 
/*************************************************************************/
int classMFNR::MotionDetectFilter(RK_U16* pRawData, int wid, int hgt, RK_U16* pFiltData)
{
    //
    int     ret = 0; // return value

    //
    if (wid < 6 || hgt < 6)
    {
        ret = -1;
        return ret;
    }

    //
    int         i0, i1, j0, j1;
    RK_U16*     pTmpDst = pFiltData;
    int         sumFilt;
    for (int i=0; i < hgt; i++)
    {
        for (int j=0; j < wid; j++)
        {
            //
            i0 = MAX(i - 2, i%2);
            i1 = MIN(i + 2, hgt - 1 - (i+1)%2);
            j0 = MAX(j - 2, j%2);
            j1 = MIN(j + 2, wid - 1 - (j+1)%2);

            //
//             sumFilt = *(pRawData + i0 * wid + j0) * 1
//                     + *(pRawData + i0 * wid + j ) * 2
// 					+ *(pRawData + i0 * wid + j1) * 1
// 					+ *(pRawData + i  * wid + j0) * 2
// 					+ *(pRawData + i  * wid + j ) * 4
// 					+ *(pRawData + i  * wid + j1) * 2
// 					+ *(pRawData + i1 * wid + j0) * 1
// 					+ *(pRawData + i1 * wid + j ) * 2
// 					+ *(pRawData + i1 * wid + j1) * 1;
			// *pTmpDst = (RK_U16)(sumFilt >> 4); // 2^4=16
			//
			sumFilt = *(pRawData + i0 * wid + j0) * 1
					+ *(pRawData + i0 * wid + j ) * 1
					+ *(pRawData + i0 * wid + j1) * 1
					+ *(pRawData + i  * wid + j0) * 1
					+ *(pRawData + i  * wid + j ) * 1
					+ *(pRawData + i  * wid + j1) * 1
					+ *(pRawData + i1 * wid + j0) * 1
					+ *(pRawData + i1 * wid + j ) * 1
					+ *(pRawData + i1 * wid + j1) * 1;
            //
            *pTmpDst = (RK_U16)(sumFilt * 1.0 / 9); // 2^4=16
            pTmpDst++;
        }
    }

    //
    return ret;

} // classMFNR::MotionDetectFilter()


/************************************************************************/
// Func: classMFNR::BlockMatching_MvCompensate()
// Desc: BlockMatching & Multi-Frame MV Compensate
//   In: 
//  Out: pRawDst		- Raw Dst data pointer
// 
// Date: Revised by yousf 20160624
// 
/*************************************************************************/
int classMFNR::BlockMatching_MvCompensate()
{
    //
    int     ret = 0; // return value
// #if MY_DEBUG_PRINTF == 1
//     printf("classMFNR::BlockMatching_MvCompensate()\n");
// #endif
    //
    RK_F32*     pTmpHomography = NULL;          // temp pointer
    int         rowDDR0, rowDDR1;               // row in DDR
    int         colDDR0, colDDR1;               // col in DDR
    int			colDDR2, colDDR3;	            // Align
    int         hgtDDR;                         // height in DDR 
    int         widDDR;                         // width in DDR
    int         colStart;                       // col start in Ref Block data
    RK_U16      matchRow, matchCol, matchSad;   // match result
    int         radius = LUMA_MATCH_RADIUS*2;	// Block Matching search radius in Raw

    // 
    int			blkSize  = LUMA_MATCH_WIN_SIZE;	// Block Size in Raw Allowed to Read In
#if MF_COMPOSE_METHOD == ONLY_USE_H
    RK_U8       sumWgtPixel;                    // Sum Weight of Composite Pixel
#endif
    RK_S16*     pTmpBlkMP_pre = NULL;           // temp pointer for pTwoLineBlkMPs[0] or [1]
    RK_S16*     pTmpBlkMP_cur = NULL;           // temp pointer for pTwoLineBlkMPs[1] or [0]
    int         curRow;                         // current Row to pTwoLineBlkMPs: 0 or 1
    int         curCol;                         // current Col = floor(j/blkSize)

    int			curWinNum;						// Current Num of Block
#if USE_PIXEL_NOISE_STD_TH == 0 // 0-use Region Noise Std Threshold
    RK_U32  	aveLuma;						// Average of Block Raw Luma
#endif
    float		blkStdTh;					    // MV Compensate Th
    int         coorAr, coorAc;                 // BlockA coordinate row & col
    int         coorBr, coorBc;                 // BlockB coordinate row & col
    int         coorCr, coorCc;                 // BlockC coordinate row & col
    int         coorDr, coorDc;                 // BlockD coordinate row & col 
    int         diffAr, diffAc;                 // BlockA diff row & col
    int         diffBr, diffBc;                 // BlockB diff row & col
    int         diffCr, diffCc;                 // BlockC diff row & col
    int         diffDr, diffDc;                 // BlockD diff row & col
    int         meanR,  meanC;                  // Blocks mean row & col
    RK_U16      baseValue, refValue;            // Raw value


    //////////////////////////////////////////////////////////////////////////
    ////---- Multi-Frame Composition Method Selection
    // Method-0: only use Homography
    // Method-1: use Homography + BlockLumaMatching version 1
    // Method-2: use Homography + BlockLumaMatching version 2
#if MF_COMPOSE_METHOD == ONLY_USE_H // Method-0: only use Homography

    for (int i=0; i < mRawHgt; i += blkSize)
    {
        if (i < (mRawHgt - blkSize + 1))
        {
            for (int j=0; j < mRawWid; j += blkSize)
            {
                // current Col = floor(j/blkSize)
                curCol = j / blkSize; // BlkIdx for firstBlk in 32x128

                if (j < (mRawWid - blkSize + 1))
                {
                    // BaseFrame RawBlock -> DSP
                    GetRaw16Block(mBasePicNum, i, j, blkSize, blkSize, pBlkMatchBaseBlks[0]);

                    // BaseFrame Block -> init Dst Block
                    memcpy(pBlkMatchDstBlks[0], pBlkMatchBaseBlks[0], sizeof(RK_U16)*blkSize*blkSize);
                    
                    // Base Point -> Perspective Project: pVecX * pBasePoint = pProjectPoint
                    pBlkCenterPoint[0]  = i + blkSize / 2;  // BlkCenter-row in Raw
                    pBlkCenterPoint[1]  = j + blkSize / 2;  // BlkCenter-col in Raw
                    pBlkCenterPoint[0] /= 2;                // BlkCenter-row in Raw->Luma
                    pBlkCenterPoint[1] /= 2;                // BlkCenter-col in Raw->Luma

                    //
                    sumWgtPixel = 1; // init Sum Weight of Composite Pixel   1=Base
                    for (int k=0; k < mRawFileNum; k++)
                    {
                        if (pValidMark[k] == MARK_VALID_REF) // valid ref frame mark: 1
                        {
                            // Homography[k]
                            pTmpHomography = pHomographyMatrix + 9 * k;     // H: 3x3

                            // Perspective Project
                            ret = PerspectProject(pTmpHomography, pBlkCenterPoint, pProjectPoint);
                            if (ret)
                            {
                                printf("Failed to PerspectProject !\n");
                                return ret;
                            }

                            // CenterPoint -> Left-Top Point
                            pProjectPoint[0] *= 2; // BlkCenter-row in Luma->Raw
                            pProjectPoint[1] *= 2; // BlkCenter-col in Luma->Raw
                            pProjectPoint[0] -= (blkSize / 2);
                            pProjectPoint[1] -= (blkSize / 2);

                            // MV Constraint
                            if (   pProjectPoint[0] < 0 
                                || pProjectPoint[0] > (mRawHgt - blkSize)
                                || pProjectPoint[1] < 0
                                || pProjectPoint[1] > (mRawWid - blkSize))
                            {
                                // No Composition <-  Coordinates Out of Image

                            }
                            else
                            {
                                //
                                sumWgtPixel++;
                                // RefFrame RawBlock (1.25BytePerPixel & 20ByteAlign)
                                rowDDR0 = pProjectPoint[0]; // RefBlock row in DDR
                                colDDR0 = pProjectPoint[1]; // BaseBlock col in DDR
                                //colDDR2 = FLOOR(colDDR0 * 10.0 / 160) * 16;		    // col in Pixel
                                colDDR2 = colDDR0;
                                rowDDR1 = MIN(pProjectPoint[0] + blkSize - 1, mRawHgt - 1) ; // RefBlock row in DDR
                                colDDR1 = MIN(pProjectPoint[1] + blkSize - 1, mRawWid - 1) ; // RefBlock col in DDR
                                //colDDR3 = CEIL((colDDR1+1) * 10.0 / 160) * 16 - 1;	// col in Pixel											
                                colDDR3 = colDDR1;
                                hgtDDR  = rowDDR1 - rowDDR0 + 1;    // RefBlock height in DDR 
                                widDDR  = colDDR3 - colDDR2 + 1;    // 20Byte -> 16Pixel
                                colStart= colDDR0 - colDDR2;       // col start in Ref Block data

                                // RefFrame RawBlock -> DSP
                                GetRaw16Block(k, rowDDR0, colDDR2, hgtDDR, widDDR, pBlkMatchRefBlks[0]);
                                for (int r=0; r < blkSize; r++)
                                {
                                    for (int c=0; c < blkSize; c++)
                                    {
                                        // DSP
                                        *(pBlkMatchDstBlks[0] + r*blkSize + c) += *(pBlkMatchRefBlks[0] + r*widDDR + c+colStart);
                                    }
                                }
                            }

                        } // if pValidMark[k]

                    } // for k

                    // Normalization
                    for (int r=0; r < blkSize; r++)
                    {
                        for (int c=0; c < blkSize; c++)
                        {
                            // DSP
                            *(pBlkMatchDstBlks[0] + r*blkSize + c) /= sumWgtPixel;
                        }
                    }

                    // DSP(16bit) to DDR(16bit,4ByteAlign)
                    PullRaw16Block(pBlkMatchDstBlks[0], i, j, blkSize, blkSize);


                } // if j
                else
                {
                    // RegionWid < blkSize
                    // ...Copy MV from PreColBlk

                }
            } // for j

        } // if i
        else
        {
            // RegionHgt < blkSize
            // ...Copy MV from PreRowBlk

        }
    } // for i



    //////////////////////////////////////////////////////////////////////////
#elif MF_COMPOSE_METHOD == USE_H_BM_V1 // Method-1: use Homography + BlockLumaMatching version 1
    // count Condition
	int     cntCondition0 = 0;  //                Out of Image
    int     cntCondition1 = 0;  //                Row#1 or Col#1
    int     cntCondition2 = 0;  // MV_result   = MV_H       // MV_result   = MV_H
    int     cntCondition3 = 0;  // MV_result_R = MV_H       // MV_result_R = MV_H   & MV_Result_C = meanMV 
    int     cntCondition4 = 0;  // MV_init_R   = MV_H       // MV_Result_R = meanMV & MV_result_C = MV_H 
    int     cntCondition5 = 0;  //                          // MV_init_R   = MV_H   & MV_init_C   = MV_H 
	int     cntCondition6 = 0;  // MV_result_C = MV_H
    int     cntCondition7 = 0;  // MV_init_C   = MV_H
    int     cntCondition8 = 0;  // 
	radius = 0;
    ////---- use Homography + BlockLumaMatching
    int numValue    = CEIL(CEIL(mRawWid*1.0/LUMA_MATCH_WIN_SIZE)/LUMA_MATCH_WIN_NUM)*LUMA_MATCH_WIN_NUM*2;
    int nLineBlkLen = numValue * mRawFileNum;
	int MD_Th;			// Motion Detect Threshold
	int MD_BaseValue;	// Motion Detect Base Value for MotionDetectTable
	int i0, i1, j0, j1, aveCnt;
    for (int i=0; i < mRawHgt; i += blkSize / (int)(mTestParams[9]))
    {
        // Neighborhood Block Match Points Cache
        curRow        = (i / blkSize) % 2;          // current Row to pTwoLineBlkMPs: 0 or 1
        pTmpBlkMP_pre = pTwoLineBlkMPs[1-curRow];   // Previous Row
        pTmpBlkMP_cur = pTwoLineBlkMPs[curRow];     // Current Row
        memset(pTmpBlkMP_cur, 0, sizeof(RK_S16) * numValue * mRawFileNum ); 

        if (i < (mRawHgt - blkSize + 1))
        {
            for (int j=0; j < mRawWid; j += blkSize / (int)(mTestParams[9]) * LUMA_MATCH_WIN_NUM)
            {
                // current Col = floor(j/blkSize)
                curCol = j / blkSize; // BlkIdx for firstBlk in 32x128

                if (j < (mRawWid - blkSize*LUMA_MATCH_WIN_NUM + 1))
                {
                    // 32x128 Block in BaseFrame -> DSP
                    curWinNum = LUMA_MATCH_WIN_NUM;

#if USE_PIXEL_NOISE_STD_TH == 0 // 0-use Region Noise Std Threshold
                    aveLuma   = 0;
#endif
                    
					
                    // 
                    for (int m=0; m < curWinNum; m++)
                    {
                        // BaseFrame RawBlock -> DSP
                        GetRaw16Block(mBasePicNum, i, j + m * blkSize, blkSize, blkSize, pBlkMatchBaseBlks[m]);

                        // Raw2Luma
                        Scaler_Raw2Luma(pBlkMatchBaseBlks[m], blkSize, blkSize, blkSize/2, blkSize/2, pBlkMatchBaseBlksLuma[m]);

#if USE_PIXEL_NOISE_STD_TH == 0 // 0-use Region Noise Std Threshold
                        // Sum Luma
                        for (int r=0; r < blkSize/2; r++)
                        {
                            for (int c=0; c < blkSize/2; c++)
                            {
                                aveLuma += *(pBlkMatchBaseBlksLuma[m] + r * blkSize/2 + c);
                            }
                        }
#endif

                        // BaseFrame Block
                        memcpy(pBlkMatchDstBlks[m], pBlkMatchBaseBlks[m], sizeof(RK_U16)*blkSize*blkSize);


#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                        // Motion Detect
                        MotionDetectFilter(pBlkMatchBaseBlks[m], blkSize, blkSize, pBlkMatchBaseBlksFilt[m]);
#endif

                    } // for m

#if USE_PIXEL_NOISE_STD_TH == 0 // 0-use Region Noise Std Threshold
                    // Average Luma
                    aveLuma = ROUND_U16(aveLuma / (blkSize/2*blkSize/2*curWinNum*1.0));

                    // Compose Threshold: std = A * sqrt(aveLuma - B)
                    if (aveLuma > NOISE_STD_PARAM_B) // Luma-BlackLevel = 64
                    {
                        //blkStdTh = NOISE_STD_PARAM_A * sqrt(aveLuma - NOISE_STD_PARAM_B);// |RefLuma - Base} < blkStdTh --> wgt=1, else wgt=0
                        blkStdTh = 10000;
                    }
#endif

                    //---- Matching ValidRef Frame#k
                    // Block Weights: 32*32*4*1Byte init=1 -> Base
                    memset(pBlockWeights, 1, sizeof(RK_U8) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE * curWinNum); 
                    for (int k=0; k < mRawFileNum; k++)
                    {
                        if (pValidMark[k] == MARK_VALID_REF) // valid ref frame mark: 1
                        {
                            // Homography[k]
                            pTmpHomography = pHomographyMatrix + 9 * k;     // H: 3x3

                            // Block[0]~Block[m-1]
                            for (int m=0; m < curWinNum; m++)
                            {
                                // Base Point -> Perspective Project: pVecX * pBasePoint = pProjectPoint
                                pBlkCenterPoint[0]  = i + blkSize / 2;				    // BlkCenter-row in Raw
                                pBlkCenterPoint[1]  = j + blkSize / 2 + blkSize * m;	// BlkCenter-col in Raw
                                pBlkCenterPoint[0] /= 2;                                // BlkCenter-row in Raw->Luma
                                pBlkCenterPoint[1] /= 2;                                // BlkCenter-col in Raw->Luma
                                ret = PerspectProject(pTmpHomography, pBlkCenterPoint, pProjectPoint);
                                if (ret)
                                {
                                    printf("Failed to PerspectProject !\n");
                                    return ret;
                                }
                                // CenterPoint -> Left-Top Point
                                pProjectPoint[0] *= 2; // ProjectPoint-row in Luma->Raw
                                pProjectPoint[1] *= 2; // ProjectPoint-col in Luma->Raw
                                pProjectPoint[0] -= (blkSize / 2); // ProjectPoint-row in Luma->Raw
                                pProjectPoint[1] -= (blkSize / 2); // ProjectPoint-col in Luma->Raw
#if MY_DEBUG_PRINTF == 1
                                printf("classMFNR::BlockMatching_MvCompensate()----Rect(#i=%d,#j=%d), Frame#k=%d, Blk#m=%d\n", i, j, k, m);
#endif
                                // MV Constraint
								if (   pProjectPoint[0] < 0 
									|| pProjectPoint[0] > (mRawHgt - blkSize)
									|| pProjectPoint[1] < 0
									|| pProjectPoint[1] > (mRawWid - blkSize))
//                                 if (   pProjectPoint[0] < 0 + radius 
//                                     || pProjectPoint[0] > (mRawHgt - blkSize - radius)
//                                     || pProjectPoint[1] < 0 + radius 
//                                     || pProjectPoint[1] > (mRawWid - blkSize - radius))
                                {
                                    //-- Condition-0
                                    cntCondition0++;    // Out of Image

                                    // MatchPoint in RefBlock <-- H
                                    *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = pProjectPoint[0];
                                    *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = pProjectPoint[1];
                                } // if pProjectPoint
                                else
                                {
                                    // RefFrame RawBlock

                                    //-- Condition-1
                                    cntCondition1++;    // Row#1 or Col#1 or Col#end

                                    // MV_init = MV_H 
                                    rowDDR0 = MAX(pProjectPoint[0] - radius, 0) ; // RefBlock row in DDR
                                    colDDR0 = MAX(pProjectPoint[1] - radius, 0) ; // BaseBlock col in DDR
                                    //colDDR2 = FLOOR(colDDR0 * 10.0 / 160) * 16;		    // col in Pixel
                                    colDDR2 = colDDR0;
                                    rowDDR1 = MIN(pProjectPoint[0] + blkSize - 1 + radius, mRawHgt - 1) ; // RefBlock row in DDR
                                    colDDR1 = MIN(pProjectPoint[1] + blkSize - 1 + radius, mRawWid - 1) ; // RefBlock col in DDR
                                    //colDDR3 = CEIL((colDDR1+1) * 10.0 / 160) * 16 - 1;	// col in Pixel											
                                    colDDR3 = colDDR1;
                                    hgtDDR  = rowDDR1 - rowDDR0 + 1;    // RefBlock height in DDR 
                                    widDDR  = colDDR3 - colDDR2 + 1;    // 20Byte -> 16Pixel
                                    colStart= colDDR0 - colDDR2;        // col start in Ref Block data

                                    // RefFrame RawBlock -> DSP
                                    GetRaw16Block(k, rowDDR0, colDDR2, hgtDDR, widDDR, pBlkMatchRefBlks[m]);

                                    // MatchPoint in RefBlock <-- MV_H + BlockMatching
                                    *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = pProjectPoint[0];
                                    *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = pProjectPoint[1];

#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                    // Motion Detect
                                    MotionDetectFilter(pBlkMatchRefBlks[m], widDDR, hgtDDR, pBlkMatchRefBlksFilt[m]);
#endif

                                    // Ref --> Dst
                                    for (int r=0; r < blkSize; r++)
                                    {
                                        for (int c=0; c < blkSize; c++)
                                        {
                                            // RawValue
                                            baseValue = *(pBlkMatchBaseBlks[m] + r*blkSize + c);
                                            refValue  = *(pBlkMatchRefBlks[m]  + r*widDDR  + c); // 
#if USE_PIXEL_NOISE_STD_TH == 1 // 1-use BayerPixel Noise Std Threshold
                                            blkStdTh = NoiseStdTable[baseValue];
                                            blkStdTh = NoiseStdTable[baseValue] + 12;
#endif
                                            // blkStdTh
#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                            if (mTestParams[4] == 0)
                                            {
                                                MD_Th = MOTION_DETECT_TH;
                                            }
                                            else if (mTestParams[4] == 1)
                                            {
                                                MD_Th = MotionDetectTable[baseValue];
                                            }
                                            else if (mTestParams[4] == 2)
                                            {
                                                MD_Th = MotionDetectTable2[baseValue];
                                            }
                                            else if (mTestParams[4] == 3)
                                            {
                                                MD_Th = MotionDetectTable3[baseValue];
                                            }
                                            else if (mTestParams[4] == 4)
                                            {
                                                MD_Th = MotionDetectTable4[baseValue];
                                            }
                                            else if (mTestParams[4] == 5)
                                            {
                                                MD_Th = MotionDetectTable5[baseValue];
                                            }
                                            else if (mTestParams[4] == 6)
                                            {
                                                MD_Th = MotionDetectTable6[baseValue];
                                            }
                                            else if (mTestParams[4] == 7)
                                            {
                                                i0 = MAX(r - 0, r%2);
                                                i1 = MIN(r + 0, blkSize - 1 - (r+1)%2);
                                                j0 = MAX(c - 0, c%2);
                                                j1 = MIN(c + 0, blkSize - 1 - (c+1)%2);
// 													i0 = MAX(r - 2, r%2);
// 													i1 = MIN(r + 2, blkSize - 1 - (r+1)%2);
// 													j0 = MAX(c - 2, c%2);
// 													j1 = MIN(c + 2, blkSize - 1 - (c+1)%2);
                                                MD_BaseValue = 0; // Motion Detect Base Value for MotionDetectTable
                                                aveCnt       = 0; // Points Count
                                                for (int ii = i0; ii <= i1; ii++)
                                                    //for (int ii = i0; ii <= i1; ii+=2)
                                                {
                                                    for (int jj = j0; jj <= j1; jj++)
                                                        //for (int jj = j0; jj <= j1; jj+=2)
                                                    {
                                                        MD_BaseValue += *(pBlkMatchBaseBlks[m] + ii*blkSize + jj);
                                                        aveCnt++;
                                                    }
                                                }
                                                MD_BaseValue = ROUND_U16(MIN(MD_BaseValue * 1.0 / aveCnt, 1023));
                                                MD_Th = MotionDetectTable7[MD_BaseValue];
                                            }
                                            else if (mTestParams[4] == 8)
                                            {
                                                i0 = MAX(r - 1, 0);
                                                i1 = MIN(r + 1, blkSize - 1);
                                                j0 = MAX(c - 1, 0);
                                                j1 = MIN(c + 1, blkSize - 1);
                                                MD_BaseValue = 0; // Motion Detect Base Value for MotionDetectTable
                                                aveCnt       = 0; // Points Count
                                                for (int ii = i0; ii <= i1; ii++)
                                                {
                                                    for (int jj = j0; jj <= j1; jj++)
                                                    {
                                                        MD_BaseValue += *(pBlkMatchBaseBlks[m] + ii*blkSize + jj);
                                                        aveCnt++;
                                                    }
                                                }
                                                MD_BaseValue = ROUND_U16(MIN(MD_BaseValue * 1.0 / aveCnt, 1023));
                                                MD_Th = MotionDetectTable8[MD_BaseValue];
                                            }

                                            if (ABS_U16(*(pBlkMatchBaseBlksFilt[m] + r*blkSize + c) - *(pBlkMatchRefBlksFilt[m] + r*widDDR + c)) < MD_Th )
#else
                                            if (ABS_U16(baseValue - refValue) < blkStdTh)
#endif
                                            {

// 													// DSP Dst
// 													*(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
// 													//*(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(64,refValue);    // RawValue
// 													*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight

                                                // 0603-13.58
                                                if (mTestParams[0] == 0) // mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
                                                {
                                                    // DSP Dst
                                                    *(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
                                                    //*(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(64,refValue);    // RawValue
                                                    *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
                                                }
                                                else if (mTestParams[0] == 1) // mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
                                                {
                                                    if (*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) == 1)
                                                    {
                                                        *(pBlkMatchDstBlks[m] + r*blkSize + c) = MAX(*(pBlkMatchDstBlks[m] + r*blkSize + c), ROUND_U16(mBlackLevel[r%2 * 2 + c%2] / 4));
                                                    }
                                                    *(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(refValue, ROUND_U16(mBlackLevel[r%2 * 2 + c%2] / 4));    // RawValue
                                                    *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
                                                }

                                            } // if blkStdTh
                                        } // for c
                                    } // for r


                                   
                                } // else pProjectPoint


                            } // for m

                        } // if pValidMark[k]
                        else
                        {


                        } // else pValidMark[k]

                    } // for k


                    //// Normalization
					RK_F32 tmp = 0.0; // 
                    for (int m=0; m < curWinNum; m++)
                    {
                        for (int r=0; r < blkSize; r++)
                        {
                            for (int c=0; c < blkSize; c++)
                            {
                                //*(pBlkMatchDstBlks[m] + r*blkSize + c) /= *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c);
								
								//0601
// 								*(pBlkMatchDstBlks[m] + r*blkSize + c) *= mUseGain;
// 								*(pBlkMatchDstBlks[m] + r*blkSize + c) /= *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c);
// 								*(pBlkMatchDstBlks[m] + r*blkSize + c) -= (mUseGain -1) * 64;

								if (mTestParams[1] == 1)// mTestParams[1]	 1-Use PreGain-PostBlk   2-Use PreBlk-PostGain
								{
									// 0602
									tmp = *(pBlkMatchDstBlks[m] + r*blkSize + c) * mTestParams[2];// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
									tmp = tmp / *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c);
									if (mTestParams[3] == 3) // mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
									{
										//*(pRawDstGain + (i+r)*(mRaw16Stride/2) + j+m*blkSize+c) = ROUND_U16(MIN(tmp, 4095)); // ln-test
										
										//*(pRawDstGain + (i+r)*(mRaw16Stride/2) + j+m*blkSize+c) = ROUND_U16(MIN(tmp, 8191)); // ln-test

										// mTestParams[9]    1-NonOverlap, 2-OverlapStep1/2, 4-OverlapStep1/4, ...
										if (mTestParams[9] == 1)
										{
											*(pRawDstGain + (i+r)*(mRaw16Stride/2) + j+m*blkSize+c) = ROUND_U16(MIN(tmp, 8191)); // ln-test
										}
										else if (RK_U16(mTestParams[9]) % 2 == 0)
										{
											*(pRawDstGain + (i+r)*(mRaw16Stride/2) + j+m*blkSize+c) += ROUND_U16(MIN(tmp, 8191)); // ln-test
										}
									}
									else
									{
										tmp = tmp - (mTestParams[2] -1) * mBlackLevel[r%2 * 2 + c%2] / 4;
										tmp = MIN(tmp, 1023);
										*(pBlkMatchDstBlks[m] + r*blkSize + c) = ROUND_U16(tmp);
									}
								}
								else if (mTestParams[1] == 2)// mTestParams[1]	 1-Use PreGain-PostBlk   2-Use PreBlk-PostGain
								{
									tmp = *(pBlkMatchDstBlks[m] + r*blkSize + c) * 1.0 / *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c);
									tmp = ROUND_U16(tmp);
									tmp = (tmp - mBlackLevel[r%2 * 2 + c%2] / 4) * mTestParams[2] + mBlackLevel[r%2 * 2 + c%2] / 4;// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
									tmp = MIN(tmp, 1023);
									*(pBlkMatchDstBlks[m] + r*blkSize + c) = ROUND_U16(tmp);
								}
								
                            }
                        }

                        // DSP(16bit) to DDR(16bit,4ByteAlign)
                        PullRaw16Block(pBlkMatchDstBlks[m], i, j+m*blkSize, blkSize, blkSize);

                    } // for m

                } // if j
                else
                {
                    // RegionWid < 4*blkSize
                    // ... 32x32 ...BlockMatching
                    // ... 32xN,N<32...Copy MV from PreRowBlk

                }

            } // for j

        } // if i
        else
        {
            // RegionHgt < blkSize
            // ...Copy MV from PreRowBlk

        }

    } // for i


	// mTestParams[9]    1-NonOverlap, 2-OverlapStep1/2, 4-OverlapStep1/4, ...
	if (RK_U16(mTestParams[9]) % 2 == 0)
	{
		float weight = mTestParams[9] * mTestParams[9];
		if (mTestParams[3] == 3) // mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
		{
			// WDR
			for (int i=0; i < mRawWid * mRawHgt; i++)
			{
				*(pRawDstGain + i) = ROUND_U16(*(pRawDstGain + i) / weight);
			}
		}
		else
		{
			for (int i=0; i < mRawWid * mRawHgt; i++)
			{
				*(pRawDst + i) = ROUND_U16(*(pRawDst + i) / weight);
			}
		}
		
	}



    //////////////////////////////////////////////////////////////////////////
#elif MF_COMPOSE_METHOD == USE_H_BM_V2 // Method-2: use Homography + BlockLumaMatching version 2
    // count Condition
	int     cntCondition0 = 0;  //                Out of Image
    int     cntCondition1 = 0;  //                Row#1 or Col#1
    int     cntCondition2 = 0;  // MV_result   = MV_H       // MV_result   = MV_H
    int     cntCondition3 = 0;  // MV_result_R = MV_H       // MV_result_R = MV_H   & MV_Result_C = meanMV 
    int     cntCondition4 = 0;  // MV_init_R   = MV_H       // MV_Result_R = meanMV & MV_result_C = MV_H 
    int     cntCondition5 = 0;  //                          // MV_init_R   = MV_H   & MV_init_C   = MV_H 
	int     cntCondition6 = 0;  // MV_result_C = MV_H
    int     cntCondition7 = 0;  // MV_init_C   = MV_H
    int     cntCondition8 = 0;  // 
	radius = 0;
    ////---- use Homography + BlockLumaMatching
    int numValue    = CEIL(CEIL(mRawWid*1.0/LUMA_MATCH_WIN_SIZE)/LUMA_MATCH_WIN_NUM)*LUMA_MATCH_WIN_NUM*2;
    int nLineBlkLen = numValue * mRawFileNum;
	int MD_Th;			// Motion Detect Threshold
	int MD_BaseValue;	// Motion Detect Base Value for MotionDetectTable
	int i0, i1, j0, j1, aveCnt;
    for (int i=0; i < mRawHgt; i += blkSize / (int)(mTestParams[9]))
    {
        // Neighborhood Block Match Points Cache
        curRow        = (i / blkSize) % 2;          // current Row to pTwoLineBlkMPs: 0 or 1
        pTmpBlkMP_pre = pTwoLineBlkMPs[1-curRow];   // Previous Row
        pTmpBlkMP_cur = pTwoLineBlkMPs[curRow];     // Current Row
        memset(pTmpBlkMP_cur, 0, sizeof(RK_S16) * numValue * mRawFileNum ); 

        if (i < (mRawHgt - blkSize + 1))
        {
            for (int j=0; j < mRawWid; j += blkSize / (int)(mTestParams[9]) * LUMA_MATCH_WIN_NUM)
            {
                // current Col = floor(j/blkSize)
                curCol = j / blkSize; // BlkIdx for firstBlk in 32x128

                if (j < (mRawWid - blkSize*LUMA_MATCH_WIN_NUM + 1))
                {
                    // 32x128 Block in BaseFrame -> DSP
                    curWinNum = LUMA_MATCH_WIN_NUM;

#if USE_PIXEL_NOISE_STD_TH == 0 // 0-use Region Noise Std Threshold
                    aveLuma   = 0;
#endif
                    
					if (i==13*32 && j==13*32)
					{
						blkSize=32;
					}
					
                    // 
                    for (int m=0; m < curWinNum; m++)
                    {
                        // BaseFrame RawBlock -> DSP
                        GetRaw16Block(mBasePicNum, i, j + m * blkSize, blkSize, blkSize, pBlkMatchBaseBlks[m]);

                        // Raw2Luma
                        Scaler_Raw2Luma(pBlkMatchBaseBlks[m], blkSize, blkSize, blkSize/2, blkSize/2, pBlkMatchBaseBlksLuma[m]);

#if USE_PIXEL_NOISE_STD_TH == 0 // 0-use Region Noise Std Threshold
                        // Sum Luma
                        for (int r=0; r < blkSize/2; r++)
                        {
                            for (int c=0; c < blkSize/2; c++)
                            {
                                aveLuma += *(pBlkMatchBaseBlksLuma[m] + r * blkSize/2 + c);
                            }
                        }
#endif

                        // BaseFrame Block
                        memcpy(pBlkMatchDstBlks[m], pBlkMatchBaseBlks[m], sizeof(RK_U16)*blkSize*blkSize);


#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                        // Motion Detect
                        MotionDetectFilter(pBlkMatchBaseBlks[m], blkSize, blkSize, pBlkMatchBaseBlksFilt[m]);
#endif

                    } // for m

#if USE_PIXEL_NOISE_STD_TH == 0 // 0-use Region Noise Std Threshold
                    // Average Luma
                    aveLuma = ROUND_U16(aveLuma / (blkSize/2*blkSize/2*curWinNum*1.0));

                    // Compose Threshold: std = A * sqrt(aveLuma - B)
                    if (aveLuma > NOISE_STD_PARAM_B) // Luma-BlackLevel = 64
                    {
                        //blkStdTh = NOISE_STD_PARAM_A * sqrt(aveLuma - NOISE_STD_PARAM_B);// |RefLuma - Base} < blkStdTh --> wgt=1, else wgt=0
                        blkStdTh = 10000;
                    }
#endif

                    //---- Matching ValidRef Frame#k
                    // Block Weights: 32*32*4*1Byte init=1 -> Base
                    memset(pBlockWeights, 1, sizeof(RK_U8) * LUMA_MATCH_WIN_SIZE * LUMA_MATCH_WIN_SIZE * curWinNum); 
                    for (int k=0; k < mRawFileNum; k++)
                    {
                        if (pValidMark[k] == MARK_VALID_REF) // valid ref frame mark: 1
                        {
                            // Homography[k]
                            pTmpHomography = pHomographyMatrix + 9 * k;     // H: 3x3

                            // Block[0]~Block[m-1]
                            for (int m=0; m < curWinNum; m++)
                            {
                                // Base Point -> Perspective Project: pVecX * pBasePoint = pProjectPoint
                                pBlkCenterPoint[0]  = i + blkSize / 2;				    // BlkCenter-row in Raw
                                pBlkCenterPoint[1]  = j + blkSize / 2 + blkSize * m;	// BlkCenter-col in Raw
                                pBlkCenterPoint[0] /= 2;                                // BlkCenter-row in Raw->Luma
                                pBlkCenterPoint[1] /= 2;                                // BlkCenter-col in Raw->Luma
                                ret = PerspectProject(pTmpHomography, pBlkCenterPoint, pProjectPoint);
                                if (ret)
                                {
                                    printf("Failed to PerspectProject !\n");
                                    return ret;
                                }
                                // CenterPoint -> Left-Top Point
                                pProjectPoint[0] *= 2; // ProjectPoint-row in Luma->Raw
                                pProjectPoint[1] *= 2; // ProjectPoint-col in Luma->Raw
                                pProjectPoint[0] -= (blkSize / 2); // ProjectPoint-row in Luma->Raw
                                pProjectPoint[1] -= (blkSize / 2); // ProjectPoint-col in Luma->Raw
#if MY_DEBUG_PRINTF == 1
                                printf("classMFNR::BlockMatching_MvCompensate()----Rect(#i=%d,#j=%d), Frame#k=%d, Blk#m=%d\n", i, j, k, m);
#endif
                                // MV Constraint
								if (   pProjectPoint[0] < 0 
									|| pProjectPoint[0] > (mRawHgt - blkSize)
									|| pProjectPoint[1] < 0
									|| pProjectPoint[1] > (mRawWid - blkSize))
//                                 if (   pProjectPoint[0] < 0 + radius 
//                                     || pProjectPoint[0] > (mRawHgt - blkSize - radius)
//                                     || pProjectPoint[1] < 0 + radius 
//                                     || pProjectPoint[1] > (mRawWid - blkSize - radius))
                                {
                                    //-- Condition-0
                                    cntCondition0++;    // Out of Image

                                    // MatchPoint in RefBlock <-- H
                                    *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = pProjectPoint[0];
                                    *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = pProjectPoint[1];
                                } // if pProjectPoint
                                else
                                {
                                    // RefFrame RawBlock
                                    if (1)//(i == 0 || j + m * blkSize == 0 || j + m * blkSize == (mRawWid/blkSize-1) * blkSize)
                                    {
                                        //-- Condition-1
                                        cntCondition1++;    // Row#1 or Col#1 or Col#end
                                        
                                        // MV_init = MV_H 
                                        rowDDR0 = MAX(pProjectPoint[0] - radius, 0) ; // RefBlock row in DDR
                                        colDDR0 = MAX(pProjectPoint[1] - radius, 0) ; // BaseBlock col in DDR
                                        //colDDR2 = FLOOR(colDDR0 * 10.0 / 160) * 16;		    // col in Pixel
                                        colDDR2 = colDDR0;
                                        rowDDR1 = MIN(pProjectPoint[0] + blkSize - 1 + radius, mRawHgt - 1) ; // RefBlock row in DDR
                                        colDDR1 = MIN(pProjectPoint[1] + blkSize - 1 + radius, mRawWid - 1) ; // RefBlock col in DDR
                                        //colDDR3 = CEIL((colDDR1+1) * 10.0 / 160) * 16 - 1;	// col in Pixel											
                                        colDDR3 = colDDR1;
                                        hgtDDR  = rowDDR1 - rowDDR0 + 1;    // RefBlock height in DDR 
                                        widDDR  = colDDR3 - colDDR2 + 1;    // 20Byte -> 16Pixel
                                        colStart= colDDR0 - colDDR2;        // col start in Ref Block data

                                        // RefFrame RawBlock -> DSP
                                        GetRaw16Block(k, rowDDR0, colDDR2, hgtDDR, widDDR, pBlkMatchRefBlks[m]);

                                        // Raw2Luma
                                        Scaler_Raw2Luma(pBlkMatchRefBlks[m], widDDR, hgtDDR, widDDR/2, hgtDDR/2, pBlkMatchRefBlksLuma[m]);

                                        // Luma Dense Matching
                                        LumaDenseMatching(pBlkMatchBaseBlksLuma[m], blkSize/2, blkSize/2, 
                                            pBlkMatchRefBlksLuma[m], widDDR/2, hgtDDR/2, colStart/2, 
                                            matchRow, matchCol, matchSad);

                                        // MatchPoint in RefBlock <-- MV_H + BlockMatching
                                        *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = matchRow*2 + rowDDR0;
                                        *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = matchCol*2 + colDDR2;

#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                        // Motion Detect
                                        MotionDetectFilter(pBlkMatchRefBlks[m], widDDR, hgtDDR, pBlkMatchRefBlksFilt[m]);
#endif

                                        // Ref --> Dst
                                        for (int r=0; r < blkSize; r++)
                                        {
                                            for (int c=0; c < blkSize; c++)
                                            {
                                                // RawValue
                                                baseValue = *(pBlkMatchBaseBlks[m] + r*blkSize + c);
                                                refValue  = *(pBlkMatchRefBlks[m]  + (matchRow*2+r)*widDDR + matchCol*2+c); // 
#if USE_PIXEL_NOISE_STD_TH == 1 // 1-use BayerPixel Noise Std Threshold
												blkStdTh = NoiseStdTable[baseValue];
                                                blkStdTh = NoiseStdTable[baseValue] + 12;
#endif
                                                // blkStdTh
#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
												if (mTestParams[4] == 0)
												{
													MD_Th = MOTION_DETECT_TH;
												}
												else if (mTestParams[4] == 1)
												{
													MD_Th = MotionDetectTable[baseValue];
												}
												else if (mTestParams[4] == 2)
												{
													MD_Th = MotionDetectTable2[baseValue];
												}
												else if (mTestParams[4] == 3)
												{
													MD_Th = MotionDetectTable3[baseValue];
												}
												else if (mTestParams[4] == 4)
												{
													MD_Th = MotionDetectTable4[baseValue];
												}
												else if (mTestParams[4] == 5)
												{
													MD_Th = MotionDetectTable5[baseValue];
												}
												else if (mTestParams[4] == 6)
												{
													MD_Th = MotionDetectTable6[baseValue];
												}
												else if (mTestParams[4] == 7)
												{
													i0 = MAX(r - 0, r%2);
													i1 = MIN(r + 0, blkSize - 1 - (r+1)%2);
													j0 = MAX(c - 0, c%2);
													j1 = MIN(c + 0, blkSize - 1 - (c+1)%2);
// 													i0 = MAX(r - 2, r%2);
// 													i1 = MIN(r + 2, blkSize - 1 - (r+1)%2);
// 													j0 = MAX(c - 2, c%2);
// 													j1 = MIN(c + 2, blkSize - 1 - (c+1)%2);
													MD_BaseValue = 0; // Motion Detect Base Value for MotionDetectTable
													aveCnt       = 0; // Points Count
													for (int ii = i0; ii <= i1; ii++)
													//for (int ii = i0; ii <= i1; ii+=2)
													{
														for (int jj = j0; jj <= j1; jj++)
														//for (int jj = j0; jj <= j1; jj+=2)
														{
															MD_BaseValue += *(pBlkMatchBaseBlks[m] + ii*blkSize + jj);
															aveCnt++;
														}
													}
													MD_BaseValue = ROUND_U16(MIN(MD_BaseValue * 1.0 / aveCnt, 1023));
													MD_Th = MotionDetectTable7[MD_BaseValue];
												}
												else if (mTestParams[4] == 8)
												{
													i0 = MAX(r - 1, 0);
													i1 = MIN(r + 1, blkSize - 1);
													j0 = MAX(c - 1, 0);
													j1 = MIN(c + 1, blkSize - 1);
													MD_BaseValue = 0; // Motion Detect Base Value for MotionDetectTable
													aveCnt       = 0; // Points Count
													for (int ii = i0; ii <= i1; ii++)
													{
														for (int jj = j0; jj <= j1; jj++)
														{
															MD_BaseValue += *(pBlkMatchBaseBlks[m] + ii*blkSize + jj);
															aveCnt++;
														}
													}
													MD_BaseValue = ROUND_U16(MIN(MD_BaseValue * 1.0 / aveCnt, 1023));
													MD_Th = MotionDetectTable8[MD_BaseValue];
												}
												
                                                if (ABS_U16(*(pBlkMatchBaseBlksFilt[m] + r*blkSize + c) - *(pBlkMatchRefBlksFilt[m] + (matchRow*2+r)*widDDR + matchCol*2+c)) < MD_Th )
#else
                                                if (ABS_U16(baseValue - refValue) < blkStdTh)
#endif
                                                {
													
// 													// DSP Dst
// 													*(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
// 													//*(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(64,refValue);    // RawValue
// 													*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight

                                                    // 0603-13.58
													if (mTestParams[0] == 0) // mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
													{
														// DSP Dst
														*(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
														//*(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(64,refValue);    // RawValue
														*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
													}
													else if (mTestParams[0] == 1) // mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
													{
														if (*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) == 1)
														{
															*(pBlkMatchDstBlks[m] + r*blkSize + c) = MAX(*(pBlkMatchDstBlks[m] + r*blkSize + c), ROUND_U16(mBlackLevel[r%2 * 2 + c%2] / 4));
														}
														*(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(refValue, ROUND_U16(mBlackLevel[r%2 * 2 + c%2] / 4));    // RawValue
														*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
													}
                                                    
                                                } // if blkStdTh
                                            } // for c
                                        } // for r

                                    } // if i j
                                    else
                                    {
                                        //---- Refer to the Neighborhood Block 
                                        //   BlkA   blkB   BlkC
                                        //   BlkD  blkCur
                                        // Coordinate of Neighborhood Blocks
                                        coorAr = *(pTmpBlkMP_pre + k*numValue + 2*curCol + m*2 + 0 - 2) + blkSize;  // BlockA coordinate row
                                        coorAc = *(pTmpBlkMP_pre + k*numValue + 2*curCol + m*2 + 1 - 2) + blkSize;  // BlockA coordinate col
                                        coorBr = *(pTmpBlkMP_pre + k*numValue + 2*curCol + m*2 + 0 + 0) + blkSize;  // BlockB coordinate row
                                        coorBc = *(pTmpBlkMP_pre + k*numValue + 2*curCol + m*2 + 1 + 0) + 0;        // BlockB coordinate col
                                        coorCr = *(pTmpBlkMP_pre + k*numValue + 2*curCol + m*2 + 0 + 2) + blkSize;  // BlockC coordinate row
                                        coorCc = *(pTmpBlkMP_pre + k*numValue + 2*curCol + m*2 + 1 + 2) - blkSize;  // BlockC coordinate col
                                        coorDr = *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0 - 2) + 0;        // BlockD coordinate row
                                        coorDc = *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1 - 2) + blkSize;  // BlockD coordinate col
                                        // Coordinate Diff of Neighborhood Blocks
                                        diffAr = ABS_U16( coorAr - pProjectPoint[0] );
                                        diffAc = ABS_U16( coorAc - pProjectPoint[1] );
                                        diffBr = ABS_U16( coorBr - pProjectPoint[0] );
                                        diffBc = ABS_U16( coorBc - pProjectPoint[1] );
                                        diffCr = ABS_U16( coorCr - pProjectPoint[0] );
                                        diffCc = ABS_U16( coorCc - pProjectPoint[1] );
                                        diffDr = ABS_U16( coorDr - pProjectPoint[0] );
                                        diffDc = ABS_U16( coorDc - pProjectPoint[1] );

//                                         if (i==672 && j + m * blkSize == 160)
//                                         {
//                                             blkSize = 32;
//                                         }
#if SEARCH_BRANCH_METHOD == OLD_SEARCH_BRANCH   // Method-0: Old Method
                                        //   BlkA   blkB   BlkC
                                        //   BlkD  blkCur
										//
                                        //if (diffAr + diffBr + diffCr + diffDr == 0 && diffAc + diffBc + diffCc + diffDc == 0)
                                        if (diffBr + diffCr + diffDr == 0 && diffBc + diffCc + diffDc == 0)
                                        {
											//-- Condition-2
											cntCondition2++;    // MV_result   = MV_H

                                            // MV_result = MV_H (radius=0)
                                            rowDDR0 = MAX(pProjectPoint[0] - 0, 0) ; // RefBlock row in DDR
                                            colDDR0 = MAX(pProjectPoint[1] - 0, 0) ; // BaseBlock col in DDR
                                            //colDDR2 = FLOOR(colDDR0 * 10.0 / 160) * 16;		    // col in Pixel
                                            colDDR2 = colDDR0;
                                            rowDDR1 = MIN(pProjectPoint[0] + blkSize - 1 + 0, mRawHgt - 1) ; // RefBlock row in DDR
                                            colDDR1 = MIN(pProjectPoint[1] + blkSize - 1 + 0, mRawWid - 1) ; // RefBlock col in DDR
                                            //colDDR3 = CEIL((colDDR1+1) * 10.0 / 160) * 16 - 1;	// col in Pixel											
                                            colDDR3 = colDDR1;
                                            hgtDDR  = rowDDR1 - rowDDR0 + 1;    // RefBlock height in DDR 
                                            widDDR  = colDDR3 - colDDR2 + 1;    // 20Byte -> 16Pixel
                                            colStart= colDDR0 - colDDR2;        // col start in Ref Block data
                                            
                                            // RefFrame RawBlock -> DSP
                                            GetRaw16Block(k, rowDDR0, colDDR2, hgtDDR, widDDR, pBlkMatchRefBlks[m]);

                                            // MatchPoint in RefBlock <-- MV_H + BlockMatching
                                            *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = pProjectPoint[0];
                                            *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = pProjectPoint[1];

#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                            // Motion Detect
                                            MotionDetectFilter(pBlkMatchRefBlks[m], widDDR, hgtDDR, pBlkMatchRefBlksFilt[m]);
#endif

                                            // Ref --> Dst
                                            for (int r=0; r < blkSize; r++)
                                            {
                                                for (int c=0; c < blkSize; c++)
                                                {
                                                    // RawValue
                                                    baseValue = *(pBlkMatchBaseBlks[m] + r*blkSize + c);
                                                    refValue  = *(pBlkMatchRefBlks[m]  + (0*2+r)*widDDR + (pProjectPoint[1]-colDDR2)+c); // MatchingPoint = pProjectPoint + (0, pProjectPoint[1]-colDDR2)

#if USE_PIXEL_NOISE_STD_TH == 1 // 1-use BayerPixel Noise Std Threshold
													blkStdTh = NoiseStdTable[baseValue];
                                                    blkStdTh = NoiseStdTable[baseValue] + 12;
#endif

                                                    // blkStdTh
#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
													if (mTestParams[4] == 0)
													{
														MD_Th = MOTION_DETECT_TH;
													}
													else if (mTestParams[4] == 1)
													{
														MD_Th = MotionDetectTable[baseValue];
													}
													else if (mTestParams[4] == 2)
													{
														MD_Th = MotionDetectTable2[baseValue];
													}
													else if (mTestParams[4] == 3)
													{
														MD_Th = MotionDetectTable3[baseValue];
													}
													else if (mTestParams[4] == 4)
													{
														MD_Th = MotionDetectTable4[baseValue];
													}
													else if (mTestParams[4] == 5)
													{
														MD_Th = MotionDetectTable5[baseValue];
													}
													else if (mTestParams[4] == 6)
													{
														MD_Th = MotionDetectTable6[baseValue];
													}
													else if (mTestParams[4] == 7)
													{
														i0 = MAX(r - 0, r%2);
														i1 = MIN(r + 0, blkSize - 1 - (r+1)%2);
														j0 = MAX(c - 0, c%2);
														j1 = MIN(c + 0, blkSize - 1 - (c+1)%2);
// 														i0 = MAX(r - 2, r%2);
// 														i1 = MIN(r + 2, blkSize - 1 - (r+1)%2);
// 														j0 = MAX(c - 2, c%2);
// 														j1 = MIN(c + 2, blkSize - 1 - (c+1)%2);
														MD_BaseValue = 0; // Motion Detect Base Value for MotionDetectTable
														aveCnt       = 0; // Points Count
														for (int ii = i0; ii <= i1; ii++)
														//for (int ii = i0; ii <= i1; ii+=2)
														{
															for (int jj = j0; jj <= j1; jj++)
															//for (int jj = j0; jj <= j1; jj+=2)
															{
																MD_BaseValue += *(pBlkMatchBaseBlks[m] + ii*blkSize + jj);
																aveCnt++;
															}
														}
														MD_BaseValue = ROUND_U16(MIN(MD_BaseValue * 1.0 / aveCnt, 1023));
														MD_Th = MotionDetectTable7[MD_BaseValue];
													}
													else if (mTestParams[4] == 8)
													{
														i0 = MAX(r - 1, 0);
														i1 = MIN(r + 1, blkSize - 1);
														j0 = MAX(c - 1, 0);
														j1 = MIN(c + 1, blkSize - 1);
														MD_BaseValue = 0; // Motion Detect Base Value for MotionDetectTable
														aveCnt       = 0; // Points Count
														for (int ii = i0; ii <= i1; ii++)
														{
															for (int jj = j0; jj <= j1; jj++)
															{
																MD_BaseValue += *(pBlkMatchBaseBlks[m] + ii*blkSize + jj);
																aveCnt++;
															}
														}
														MD_BaseValue = ROUND_U16(MIN(MD_BaseValue * 1.0 / aveCnt, 1023));
														MD_Th = MotionDetectTable8[MD_BaseValue];
													}
													
													if (ABS_U16(*(pBlkMatchBaseBlksFilt[m] + r*blkSize + c) - *(pBlkMatchRefBlksFilt[m] + (matchRow*2+r)*widDDR + matchCol*2+c)) < MD_Th )
#else
                                                    if (ABS_U16(baseValue - refValue) < blkStdTh)
#endif
                                                    {
//                                                         // DSP Dst
//                                                         *(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
// 														//*(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(64,refValue);    // RawValue
//                                                         *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight

														// 0603-13.58
														if (mTestParams[0] == 0) // mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
														{
															// DSP Dst
															*(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
															//*(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(64,refValue);    // RawValue
															*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
														}
														else if (mTestParams[0] == 1) // mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
														{
															if (*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) == 1)
															{
																*(pBlkMatchDstBlks[m] + r*blkSize + c) = MAX(*(pBlkMatchDstBlks[m] + r*blkSize + c), ROUND_U16(mBlackLevel[r%2 * 2 + c%2] / 4));
															}
															*(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(refValue, ROUND_U16(mBlackLevel[r%2 * 2 + c%2] / 4));    // RawValue
															*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
														}


                                                    } // if blkStdTh
                                                } // for c
                                            } // for r

                                        } // Condition-2
										else // Condition-3~8
										{
											// Row Search Radius...
											//if (diffAr + diffBr + diffCr + diffDr == 0)
                                            if (diffBr + diffCr + diffDr == 0)
											{
												//-- Condition-3
                                                cntCondition3++;    // MV_result_R = MV_H

												// MV_result_R = MV_H 
												rowDDR0 = MAX(pProjectPoint[0] - 0, 0) ; // RefBlock row in DDR
												rowDDR1 = MIN(pProjectPoint[0] + blkSize - 1 + 0, mRawHgt - 1) ; // RefBlock row in DDR
												hgtDDR  = rowDDR1 - rowDDR0 + 1;    // RefBlock height in DDR 
											}
                                            //else if (diffAr + diffBr + diffCr + diffDr <= MV_DIFF_THRESHOLD)
                                            //else if (diffBr + diffCr + diffDr <= MV_DIFF_THRESHOLD)
                                            else  
                                            {
                                                //-- Condition-4
                                                cntCondition4++;    // MV_init_R   = MV_H

                                                // MV_init_R = MV_H 
                                                rowDDR0 = MAX(pProjectPoint[0] - radius, 0) ; // RefBlock row in DDR
                                                rowDDR1 = MIN(pProjectPoint[0] + blkSize - 1 + radius, mRawHgt - 1) ; // RefBlock row in DDR
                                                hgtDDR  = rowDDR1 - rowDDR0 + 1;    // RefBlock height in DDR 
                                            }

											// Col Search Radius...
                                            //if (diffAc + diffBc + diffCc + diffDc == 0)
                                            if (diffBc + diffCc + diffDc == 0)
                                            {
                                                //-- Condition-6
                                                cntCondition6++;    // MV_result_C = MV_H

                                                // MV_result_C = MV_H 
                                                colDDR0 = MAX(pProjectPoint[1] - 0, 0) ; // BaseBlock col in DDR
                                                //colDDR2 = FLOOR(colDDR0 * 10.0 / 160) * 16;		    // col in Pixel
                                                colDDR2 = colDDR0;
                                                colDDR1 = MIN(pProjectPoint[1] + blkSize - 1 + 0, mRawWid - 1) ; // RefBlock col in DDR
                                                //colDDR3 = CEIL((colDDR1+1) * 10.0 / 160) * 16 - 1;	// col in Pixel											
                                                colDDR3 = colDDR1;
                                                widDDR  = colDDR3 - colDDR2 + 1;    // 20Byte -> 16Pixel
                                                colStart= colDDR0 - colDDR2;       // col start in Ref Block data
                                            }
											//else if (diffAc + diffBc + diffCc + diffDc <= MV_DIFF_THRESHOLD)
                                            //else if (diffBc + diffCc + diffDc <= MV_DIFF_THRESHOLD)
                                            else
											{
												//-- Condition-7
                                                cntCondition7++;    // MV_init_C   = MV_H

												// MV_init_C = MV_H 
												colDDR0 = MAX(pProjectPoint[1] - radius, 0) ; // BaseBlock col in DDR
												//colDDR2 = FLOOR(colDDR0 * 10.0 / 160) * 16;		    // col in Pixel
												colDDR2 = colDDR0;
												colDDR1 = MIN(pProjectPoint[1] + blkSize - 1 + radius, mRawWid - 1) ; // RefBlock col in DDR
												//colDDR3 = CEIL((colDDR1+1) * 10.0 / 160) * 16 - 1;	// col in Pixel											
												colDDR3 = colDDR1;
												widDDR  = colDDR3 - colDDR2 + 1;    // 20Byte -> 16Pixel
												colStart= colDDR0 - colDDR2;       // col start in Ref Block data
											}

											// RefFrame RawBlock -> DSP
                                            GetRaw16Block(k, rowDDR0, colDDR2, hgtDDR, widDDR, pBlkMatchRefBlks[m]);

                                            // Raw2Luma
                                            Scaler_Raw2Luma(pBlkMatchRefBlks[m], widDDR, hgtDDR, widDDR/2, hgtDDR/2, pBlkMatchRefBlksLuma[m]);

                                            // Luma Dense Matching
                                            LumaDenseMatching(pBlkMatchBaseBlksLuma[m], blkSize/2, blkSize/2, 
                                                pBlkMatchRefBlksLuma[m], widDDR/2, hgtDDR/2, colStart/2, 
                                                matchRow, matchCol, matchSad);

                                            // MatchPoint in RefBlock <-- MV_H + BlockMatching
                                            *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = matchRow*2 + rowDDR0;
                                            *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = matchCol*2 + colDDR2;

#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                            // Motion Detect
                                            MotionDetectFilter(pBlkMatchRefBlks[m], widDDR, hgtDDR, pBlkMatchRefBlksFilt[m]);
#endif

                                            // Ref --> Dst
                                            for (int r=0; r < blkSize; r++)
                                            {
                                                for (int c=0; c < blkSize; c++)
                                                {
                                                    // RawValue
                                                    baseValue = *(pBlkMatchBaseBlks[m] + r*blkSize + c);
                                                    refValue  = *(pBlkMatchRefBlks[m]  + (matchRow*2+r)*widDDR + matchCol*2+c); // 

#if USE_PIXEL_NOISE_STD_TH == 1 // 1-use BayerPixel Noise Std Threshold
													blkStdTh = NoiseStdTable[baseValue];
                                                    blkStdTh = NoiseStdTable[baseValue] + 12;
#endif

                                                    // blkStdTh
#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                                if (mTestParams[4] == 0)
												{
													MD_Th = MOTION_DETECT_TH;
												}
												else if (mTestParams[4] == 1)
												{
													MD_Th = MotionDetectTable[baseValue];
												}
												else if (mTestParams[4] == 2)
												{
													MD_Th = MotionDetectTable2[baseValue];
												}
												else if (mTestParams[4] == 3)
												{
													MD_Th = MotionDetectTable3[baseValue];
												}
												else if (mTestParams[4] == 4)
												{
													MD_Th = MotionDetectTable4[baseValue];
												}
												else if (mTestParams[4] == 5)
												{
													MD_Th = MotionDetectTable5[baseValue];
												}
												else if (mTestParams[4] == 6)
												{
													MD_Th = MotionDetectTable6[baseValue];
												}
												else if (mTestParams[4] == 7)
												{
													i0 = MAX(r - 0, r%2);
													i1 = MIN(r + 0, blkSize - 1 - (r+1)%2);
													j0 = MAX(c - 0, c%2);
													j1 = MIN(c + 0, blkSize - 1 - (c+1)%2);
// 													i0 = MAX(r - 2, r%2);
// 													i1 = MIN(r + 2, blkSize - 1 - (r+1)%2);
// 													j0 = MAX(c - 2, c%2);
// 													j1 = MIN(c + 2, blkSize - 1 - (c+1)%2);
													MD_BaseValue = 0; // Motion Detect Base Value for MotionDetectTable
													aveCnt       = 0; // Points Count
													for (int ii = i0; ii <= i1; ii++)
													//for (int ii = i0; ii <= i1; ii+=2)
													{
														for (int jj = j0; jj <= j1; jj++)
														//for (int jj = j0; jj <= j1; jj+=2)
														{
															MD_BaseValue += *(pBlkMatchBaseBlks[m] + ii*blkSize + jj);
															aveCnt++;
														}
													}
													MD_BaseValue = ROUND_U16(MIN(MD_BaseValue * 1.0 / aveCnt, 1023));
													MD_Th = MotionDetectTable7[MD_BaseValue];
												}
												else if (mTestParams[4] == 8)
												{
													i0 = MAX(r - 1, 0);
													i1 = MIN(r + 1, blkSize - 1);
													j0 = MAX(c - 1, 0);
													j1 = MIN(c + 1, blkSize - 1);
													MD_BaseValue = 0; // Motion Detect Base Value for MotionDetectTable
													aveCnt       = 0; // Points Count
													for (int ii = i0; ii <= i1; ii++)
													{
														for (int jj = j0; jj <= j1; jj++)
														{
															MD_BaseValue += *(pBlkMatchBaseBlks[m] + ii*blkSize + jj);
															aveCnt++;
														}
													}
													MD_BaseValue = ROUND_U16(MIN(MD_BaseValue * 1.0 / aveCnt, 1023));
													MD_Th = MotionDetectTable8[MD_BaseValue];
												}

												if (ABS_U16(*(pBlkMatchBaseBlksFilt[m] + r*blkSize + c) - *(pBlkMatchRefBlksFilt[m] + (matchRow*2+r)*widDDR + matchCol*2+c)) < MD_Th )
#else
                                                    if (ABS_U16(baseValue - refValue) < blkStdTh)
#endif
                                                    {
//                                                         // DSP Dst
//                                                         *(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
// 														//*(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(64,refValue);    // RawValue
//                                                         *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight

														// 0603-13.58
														if (mTestParams[0] == 0) // mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
														{
															// DSP Dst
															*(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
															//*(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(64,refValue);    // RawValue
															*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
														}
														else if (mTestParams[0] == 1) // mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
														{
															if (*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) == 1)
															{
																*(pBlkMatchDstBlks[m] + r*blkSize + c) = MAX(*(pBlkMatchDstBlks[m] + r*blkSize + c), ROUND_U16(mBlackLevel[r%2 * 2 + c%2] / 4));
															}
															*(pBlkMatchDstBlks[m] + r*blkSize + c)               += MAX(refValue, ROUND_U16(mBlackLevel[r%2 * 2 + c%2] / 4));    // RawValue
															*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
														}

// 														// 0601
// 														if (*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) == 1)
// 														{
// 															*(pBlkMatchDstBlks[m] + r*blkSize + c) *= 16;
// 														}
// 														*(pBlkMatchDstBlks[m] + r*blkSize + c)               += (refValue*16);    // RawValue
// 														*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
														// 0601
// 														if (*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) == 1)
// 														{
// 															*(pBlkMatchDstBlks[m] + r*blkSize + c) = *(pBlkMatchDstBlks[m] + r*blkSize + c)*16;
// 														}
// 														*(pBlkMatchDstBlks[m] + r*blkSize + c)               += (refValue*16);    // RawValue
// 														*(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight


                                                    } // if blkStdTh
                                                } // for c
                                            } // for r
                                            
                                        }

#elif SEARCH_BRANCH_METHOD == MODIFY_SEARCH_BRANCH  // Method-1: Modify Method
                                        //   BlkA   blkB   BlkC
                                        //   BlkD  blkCur
                                        //
                                        if (diffCr + diffDr == 0 && diffCc + diffDc == 0)
                                        {
                                            //-- Condition-2
                                            cntCondition2++;    // MV_result   = MV_H

                                            // MV_result = MV_H (radius=0)
                                            rowDDR0 = MAX(pProjectPoint[0] - 0, 0) ; // RefBlock row in DDR
                                            colDDR0 = MAX(pProjectPoint[1] - 0, 0) ; // BaseBlock col in DDR
                                            //colDDR2 = FLOOR(colDDR0 * 10.0 / 160) * 16;		    // col in Pixel
                                            colDDR2 = colDDR0;
                                            rowDDR1 = MIN(pProjectPoint[0] + blkSize - 1 + 0, mRawHgt - 1) ; // RefBlock row in DDR
                                            colDDR1 = MIN(pProjectPoint[1] + blkSize - 1 + 0, mRawWid - 1) ; // RefBlock col in DDR
                                            //colDDR3 = CEIL((colDDR1+1) * 10.0 / 160) * 16 - 1;	// col in Pixel											
                                            colDDR3 = colDDR1;
                                            hgtDDR  = rowDDR1 - rowDDR0 + 1;    // RefBlock height in DDR 
                                            widDDR  = colDDR3 - colDDR2 + 1;    // 20Byte -> 16Pixel
                                            colStart= colDDR0 - colDDR2;        // col start in Ref Block data

                                            // RefFrame RawBlock -> DSP
                                            //printf("c2: k=%d, rowDDR0=%d, colDDR2=%d, hgtDDR=%d, widDDR=%d\n",k, rowDDR0, colDDR2, hgtDDR, widDDR);
                                            GetRaw16Block(k, rowDDR0, colDDR2, hgtDDR, widDDR, pBlkMatchRefBlks[m]);

                                            // MatchPoint in RefBlock <-- MV_H + BlockMatching
                                            *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = pProjectPoint[0];
                                            *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = pProjectPoint[1];

#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                            // Motion Detect
                                            MotionDetectFilter(pBlkMatchRefBlks[m], widDDR, hgtDDR, pBlkMatchRefBlksFilt[m]);
#endif

                                            // Ref --> Dst
                                            for (int r=0; r < blkSize; r++)
                                            {
                                                for (int c=0; c < blkSize; c++)
                                                {
                                                    // RawValue
                                                    baseValue = *(pBlkMatchBaseBlks[m] + r*blkSize + c);
                                                    //refValue  = *(pClassMem->pBlkMatchRefBlks[m]  + (0*2+r)*widDDR + (pProjectPoint[1]-colDDR2)*2+c); // MatchingPoint = pProjectPoint + (0, pProjectPoint[1]-colDDR2)
                                                    refValue  = *(pBlkMatchRefBlks[m]  + (0*2+r)*widDDR + (pProjectPoint[1]-colDDR2)+c); // MatchingPoint = pProjectPoint + (0, pProjectPoint[1]-colDDR2)

#if USE_PIXEL_NOISE_STD_TH == 1 // 1-use BayerPixel Noise Std Threshold
                                                    blkStdTh = NoiseStdTable[baseValue];
                                                    blkStdTh = NoiseStdTable[baseValue] + 12;
#endif

                                                    // blkStdTh
#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                                    if (ABS_U16(*(pBlkMatchBaseBlksFilt[m] + r*blkSize + c) - *(pBlkMatchRefBlksFilt[m] + (0*2+r)*widDDR + (pProjectPoint[1]-colDDR2)+c)) < MOTION_DETECT_TH )
#else
                                                    if (ABS_U16(baseValue - refValue) < blkStdTh)
#endif
                                                    {
                                                        // DSP Dst
                                                        *(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
                                                        *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
                                                    } // if blkStdTh
                                                } // for c
                                            } // for r

                                        } // Condition-2
                                        else // Condition-3~8
                                        {
                                            if (diffCr + diffDr == 0)
                                            {
                                                //-- Condition-3
                                                cntCondition3++;

                                                // MV_result_R = MV_H 
                                                rowDDR0 = MAX(pProjectPoint[0] - 0, 0) ; // RefBlock row in DDR
                                                rowDDR1 = MIN(pProjectPoint[0] + blkSize - 1 + 0, mRawHgt - 1) ; // RefBlock row in DDR
                                                hgtDDR  = rowDDR1 - rowDDR0 + 1;    // RefBlock height in DDR 
                                                
                                                // MV_Result_C = meanMV 
                                                //meanC = (coorAc + coorBc + coorCc + coorDc) >> 2;   // 4-Rects
                                                meanC = (coorCc + coorDc) >> 1;                     // 2-Rects
                                                //meanC = (meanC >> 1) << 1;                          // Guarantee Even
                                                meanC = ((meanC+1) >> 1) << 1;                      // Guarantee Even
                                                //
                                                colDDR0 = MAX(meanC - 0, 0) ; // BaseBlock col in DDR
                                                //colDDR2 = FLOOR(colDDR0 * 10.0 / 160) * 16;		    // col in Pixel
                                                colDDR2 = colDDR0;
                                                colDDR1 = MIN(meanC + blkSize - 1 + 0, mRawWid - 1) ;   // RefBlock col in DDR
                                                //colDDR3 = CEIL((colDDR1+1) * 10.0 / 160) * 16 - 1;	// col in Pixel
                                                colDDR3 = colDDR1;
                                                widDDR  = colDDR3 - colDDR2 + 1;    // 20Byte -> 16Pixel
                                                colStart= colDDR0 - colDDR2;       // col start in Ref Block data

                                                // RefFrame RawBlock -> DSP
                                                GetRaw16Block(k, rowDDR0, colDDR2, hgtDDR, widDDR, pBlkMatchRefBlks[m]);

                                                // MatchPoint in RefBlock <-- MV_H + BlockMatching
                                                *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = pProjectPoint[0];
                                                *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = meanC;
                                                
                                                // 
                                                if (widDDR > LUMA_MATCH_WIN_SIZE)
                                                {
                                                // Raw2Luma
                                                Scaler_Raw2Luma(pBlkMatchRefBlks[m], widDDR, hgtDDR, widDDR/2, hgtDDR/2, pBlkMatchRefBlksLuma[m]);
                                                // Luma Dense Matching
                                                LumaDenseMatching(pBlkMatchBaseBlksLuma[m], blkSize/2, blkSize/2, 
                                                    pBlkMatchRefBlksLuma[m], widDDR/2, hgtDDR/2, colStart/2, 
                                                    matchRow, matchCol, matchSad);
                                                // MatchPoint in RefBlock <-- MV_H + BlockMatching
                                                *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = matchRow*2 + rowDDR0;
                                                *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = matchCol*2 + colDDR2;
                                                }

#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                                // Motion Detect
                                                MotionDetectFilter(pBlkMatchRefBlks[m], widDDR, hgtDDR, pBlkMatchRefBlksFilt[m]);
#endif

                                                // Ref --> Dst
                                                for (int r=0; r < blkSize; r++)
                                                {
                                                    for (int c=0; c < blkSize; c++)
                                                    {
                                                        // RawValue
                                                        baseValue = *(pBlkMatchBaseBlks[m] + r*blkSize + c);
                                                        //refValue  = *(pClassMem->pBlkMatchRefBlks[m]  + (0*2+r)*widDDR + (pProjectPoint[1]-colDDR2)*2+c); // MatchingPoint = pProjectPoint + (0, pProjectPoint[1]-colDDR2)
                                                        refValue  = *(pBlkMatchRefBlks[m]  + (0*2+r)*widDDR + (pProjectPoint[1]-colDDR2)+c); // MatchingPoint = pProjectPoint + (0, pProjectPoint[1]-colDDR2)

#if USE_PIXEL_NOISE_STD_TH == 1 // 1-use BayerPixel Noise Std Threshold
                                                        blkStdTh = NoiseStdTable[baseValue];
                                                        blkStdTh = NoiseStdTable[baseValue] + 12;
#endif

                                                        // blkStdTh
#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                                        if (ABS_U16(*(pBlkMatchBaseBlksFilt[m] + r*blkSize + c) - *(pBlkMatchRefBlksFilt[m] + (0*2+r)*widDDR + (pProjectPoint[1]-colDDR2)+c)) < MOTION_DETECT_TH )
#else
                                                        if (ABS_U16(baseValue - refValue) < blkStdTh)
#endif
                                                        {
                                                            // DSP Dst
                                                            *(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
                                                            *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
                                                        } // if blkStdTh
                                                    } // for c
                                                } // for r

                                            }
                                            else if (diffCc + diffDc == 0)
                                            {
                                                //-- Condition-4
                                                cntCondition4++;

                                                // MV_Result_R = meanMV 
                                                //meanR = (coorAr + coorBr + coorCr + coorDr) >> 2;   // 4-Rects
                                                meanR = (coorCr + coorDr) >> 1;                     // 2-Rects
                                                //meanR = (meanR >> 1) << 1;                          // Guarantee Even
                                                meanR = ((meanR+1) >> 1) << 1;                      // Guarantee Even
                                                //
                                                rowDDR0 = MAX(meanR - 0, 0) ; // RefBlock row in DDR
                                                rowDDR1 = MIN(meanR + blkSize - 1 + 0, mRawHgt - 1) ; // RefBlock row in DDR										
                                                hgtDDR  = rowDDR1 - rowDDR0 + 1;    // RefBlock height in DDR 

                                                // MV_result_C = MV_H 
                                                colDDR0 = MAX(pProjectPoint[1] - 0, 0) ; // BaseBlock col in DDR
                                                //colDDR2 = FLOOR(colDDR0 * 10.0 / 160) * 16;		    // col in Pixel
                                                colDDR2 = colDDR0;
                                                colDDR1 = MIN(pProjectPoint[1] + blkSize - 1 + 0, mRawWid - 1) ; // RefBlock col in DDR
                                                //colDDR3 = CEIL((colDDR1+1) * 10.0 / 160) * 16 - 1;	// col in Pixel											
                                                colDDR3 = colDDR1;
                                                widDDR  = colDDR3 - colDDR2 + 1;    // 20Byte -> 16Pixel
                                                colStart= colDDR0 - colDDR2;       // col start in Ref Block data

                                                // RefFrame RawBlock -> DSP
                                                //printf("c4: k=%d, rowDDR0=%d, colDDR2=%d, hgtDDR=%d, widDDR=%d\n",k, rowDDR0, colDDR2, hgtDDR, widDDR);
                                                GetRaw16Block(k, rowDDR0, colDDR2, hgtDDR, widDDR, pBlkMatchRefBlks[m]);

                                                // MatchPoint in RefBlock <-- MV_H + BlockMatching
                                                *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = meanR;
                                                *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = pProjectPoint[1];
                                                
                                                //
                                                if (hgtDDR > LUMA_MATCH_WIN_SIZE)
                                                {
                                                // Raw2Luma
                                                Scaler_Raw2Luma(pBlkMatchRefBlks[m], widDDR, hgtDDR, widDDR/2, hgtDDR/2, pBlkMatchRefBlksLuma[m]);
                                                // Luma Dense Matching
                                                LumaDenseMatching(pBlkMatchBaseBlksLuma[m], blkSize/2, blkSize/2, 
                                                    pBlkMatchRefBlksLuma[m], widDDR/2, hgtDDR/2, colStart/2, 
                                                    matchRow, matchCol, matchSad);
                                                // MatchPoint in RefBlock <-- MV_H + BlockMatching
                                                *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = matchRow*2 + rowDDR0;
                                                *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = matchCol*2 + colDDR2;
                                                }

#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                                // Motion Detect
                                                MotionDetectFilter(pBlkMatchRefBlks[m], widDDR, hgtDDR, pBlkMatchRefBlksFilt[m]);
#endif

                                                // Ref --> Dst
                                                for (int r=0; r < blkSize; r++)
                                                {
                                                    for (int c=0; c < blkSize; c++)
                                                    {
                                                        // RawValue
                                                        baseValue = *(pBlkMatchBaseBlks[m] + r*blkSize + c);
                                                        //refValue  = *(pClassMem->pBlkMatchRefBlks[m]  + (0*2+r)*widDDR + (pProjectPoint[1]-colDDR2)*2+c); // MatchingPoint = pProjectPoint + (0, pProjectPoint[1]-colDDR2)
                                                        refValue  = *(pBlkMatchRefBlks[m]  + (0*2+r)*widDDR + (pProjectPoint[1]-colDDR2)+c); // MatchingPoint = pProjectPoint + (0, pProjectPoint[1]-colDDR2)

#if USE_PIXEL_NOISE_STD_TH == 1 // 1-use BayerPixel Noise Std Threshold
                                                        blkStdTh = NoiseStdTable[baseValue];
                                                        blkStdTh = NoiseStdTable[baseValue] + 12;
#endif

                                                        // blkStdTh
#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                                        if (ABS_U16(*(pBlkMatchBaseBlksFilt[m] + r*blkSize + c) - *(pBlkMatchRefBlksFilt[m] + (0*2+r)*widDDR + (pProjectPoint[1]-colDDR2)+c)) < MOTION_DETECT_TH )
#else
                                                        if (ABS_U16(baseValue - refValue) < blkStdTh)
#endif
                                                        {
                                                            // DSP Dst
                                                            *(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
                                                            *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
                                                        } // if blkStdTh
                                                    } // for c
                                                } // for r

                                            }
                                            else
                                            {
                                                //-- Condition-5
                                                cntCondition5++;

                                                // MV_init_R = MV_H 
                                                rowDDR0 = MAX(pProjectPoint[0] - radius, 0) ; // RefBlock row in DDR
                                                rowDDR1 = MIN(pProjectPoint[0] + blkSize - 1 + radius, mRawHgt - 1) ; // RefBlock row in DDR
                                                hgtDDR  = rowDDR1 - rowDDR0 + 1;    // RefBlock height in DDR 

                                                // MV_init_C = MV_H 
                                                colDDR0 = MAX(pProjectPoint[1] - radius, 0) ; // BaseBlock col in DDR
                                                //colDDR2 = FLOOR(colDDR0 * 10.0 / 160) * 16;		    // col in Pixel
                                                colDDR2 = colDDR0;
                                                colDDR1 = MIN(pProjectPoint[1] + blkSize - 1 + radius, mRawWid - 1) ; // RefBlock col in DDR
                                                //colDDR3 = CEIL((colDDR1+1) * 10.0 / 160) * 16 - 1;	// col in Pixel											
                                                colDDR3 = colDDR1;
                                                widDDR  = colDDR3 - colDDR2 + 1;    // 20Byte -> 16Pixel
                                                colStart= colDDR0 - colDDR2;       // col start in Ref Block data

                                                // RefFrame RawBlock -> DSP
                                                //printf("c5: k=%d, rowDDR0=%d, colDDR2=%d, hgtDDR=%d, widDDR=%d\n",k, rowDDR0, colDDR2, hgtDDR, widDDR);
                                                GetRaw16Block(k, rowDDR0, colDDR2, hgtDDR, widDDR, pBlkMatchRefBlks[m]);

                                                // Raw2Luma
                                                Scaler_Raw2Luma(pBlkMatchRefBlks[m], widDDR, hgtDDR, widDDR/2, hgtDDR/2, pBlkMatchRefBlksLuma[m]);

                                                // Luma Dense Matching
                                                LumaDenseMatching(pBlkMatchBaseBlksLuma[m], blkSize/2, blkSize/2, 
                                                    pBlkMatchRefBlksLuma[m], widDDR/2, hgtDDR/2, colStart/2, 
                                                    matchRow, matchCol, matchSad);

                                                // MatchPoint in RefBlock <-- MV_H + BlockMatching
                                                *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 0) = matchRow*2 + rowDDR0;
                                                *(pTmpBlkMP_cur + k*numValue + 2*curCol + m*2 + 1) = matchCol*2 + colDDR2;

#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                                // Motion Detect
                                                MotionDetectFilter(pBlkMatchRefBlks[m], widDDR, hgtDDR, pBlkMatchRefBlksFilt[m]);
#endif

                                                // Ref --> Dst
                                                for (int r=0; r < blkSize; r++)
                                                {
                                                    for (int c=0; c < blkSize; c++)
                                                    {
                                                        // RawValue
                                                        baseValue = *(pBlkMatchBaseBlks[m] + r*blkSize + c);
                                                        refValue  = *(pBlkMatchRefBlks[m]  + (matchRow*2+r)*widDDR + matchCol*2+c); // 

#if USE_PIXEL_NOISE_STD_TH == 1 // 1-use BayerPixel Noise Std Threshold
                                                        blkStdTh = NoiseStdTable[baseValue];
                                                        blkStdTh = NoiseStdTable[baseValue] + 12;
#endif

                                                        // blkStdTh
#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
                                                        if (ABS_U16(*(pBlkMatchBaseBlksFilt[m] + r*blkSize + c) - *(pBlkMatchRefBlksFilt[m] + (matchRow*2+r)*widDDR + matchCol*2+c)) < MOTION_DETECT_TH )
#else
                                                        if (ABS_U16(baseValue - refValue) < blkStdTh)
#endif
                                                        {
                                                            // DSP Dst
                                                            *(pBlkMatchDstBlks[m] + r*blkSize + c)               += refValue;    // RawValue
                                                            *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c) += 1;           // DstWeight
                                                        } // if blkStdTh
                                                    } // for c
                                                } // for r

                                            }
                                        }
#else
#endif

										
                                    } // else if i j

                                } // else pProjectPoint


                            } // for m

                        } // if pValidMark[k]
                        else
                        {


                        } // else pValidMark[k]

                    } // for k


                    //// Normalization
					RK_F32 tmp = 0.0; // 
                    for (int m=0; m < curWinNum; m++)
                    {
                        for (int r=0; r < blkSize; r++)
                        {
                            for (int c=0; c < blkSize; c++)
                            {
                                //*(pBlkMatchDstBlks[m] + r*blkSize + c) /= *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c);
								
								//0601
// 								*(pBlkMatchDstBlks[m] + r*blkSize + c) *= mUseGain;
// 								*(pBlkMatchDstBlks[m] + r*blkSize + c) /= *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c);
// 								*(pBlkMatchDstBlks[m] + r*blkSize + c) -= (mUseGain -1) * 64;

								if (mTestParams[1] == 1)// mTestParams[1]	 1-Use PreGain-PostBlk   2-Use PreBlk-PostGain
								{
									// 0602
									tmp = *(pBlkMatchDstBlks[m] + r*blkSize + c) * mTestParams[2];// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
									tmp = tmp / *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c);
									if (mTestParams[3] == 3) // mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
									{
										//*(pRawDstGain + (i+r)*(mRaw16Stride/2) + j+m*blkSize+c) = ROUND_U16(MIN(tmp, 4095)); // ln-test
										
										//*(pRawDstGain + (i+r)*(mRaw16Stride/2) + j+m*blkSize+c) = ROUND_U16(MIN(tmp, 8191)); // ln-test

										// mTestParams[9]    1-NonOverlap, 2-OverlapStep1/2, 4-OverlapStep1/4, ...
										if (mTestParams[9] == 1)
										{
											*(pRawDstGain + (i+r)*(mRaw16Stride/2) + j+m*blkSize+c) = ROUND_U16(MIN(tmp, 8191)); // ln-test
										}
										else if (RK_U16(mTestParams[9]) % 2 == 0)
										{
											*(pRawDstGain + (i+r)*(mRaw16Stride/2) + j+m*blkSize+c) += ROUND_U16(MIN(tmp, 8191)); // ln-test
										}
									}
									else
									{
										tmp = tmp - (mTestParams[2] -1) * mBlackLevel[r%2 * 2 + c%2] / 4;
										tmp = MIN(tmp, 1023);
										*(pBlkMatchDstBlks[m] + r*blkSize + c) = ROUND_U16(tmp);
									}
								}
								else if (mTestParams[1] == 2)// mTestParams[1]	 1-Use PreGain-PostBlk   2-Use PreBlk-PostGain
								{
									tmp = *(pBlkMatchDstBlks[m] + r*blkSize + c) * 1.0 / *(pBlockWeights + m*blkSize*blkSize + r*blkSize + c);
									tmp = ROUND_U16(tmp);
									tmp = (tmp - mBlackLevel[r%2 * 2 + c%2] / 4) * mTestParams[2] + mBlackLevel[r%2 * 2 + c%2] / 4;// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
									tmp = MIN(tmp, 1023);
									*(pBlkMatchDstBlks[m] + r*blkSize + c) = ROUND_U16(tmp);
								}
								
                            }
                        }

                        // DSP(16bit) to DDR(16bit,4ByteAlign)
                        PullRaw16Block(pBlkMatchDstBlks[m], i, j+m*blkSize, blkSize, blkSize);

                    } // for m

                } // if j
                else
                {
                    // RegionWid < 4*blkSize
                    // ... 32x32 ...BlockMatching
                    // ... 32xN,N<32...Copy MV from PreRowBlk

                }

            } // for j

        } // if i
        else
        {
            // RegionHgt < blkSize
            // ...Copy MV from PreRowBlk

        }

    } // for i


	// mTestParams[9]    1-NonOverlap, 2-OverlapStep1/2, 4-OverlapStep1/4, ...
	if (RK_U16(mTestParams[9]) % 2 == 0)
	{
		float weight = mTestParams[9] * mTestParams[9];
		if (mTestParams[3] == 3) // mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
		{
			// WDR
			for (int i=0; i < mRawWid * mRawHgt; i++)
			{
				*(pRawDstGain + i) = ROUND_U16(*(pRawDstGain + i) / weight);
			}
		}
		else
		{
			for (int i=0; i < mRawWid * mRawHgt; i++)
			{
				*(pRawDst + i) = ROUND_U16(*(pRawDst + i) / weight);
			}
		}
		
	}
	
	
	

    //////////////////////////////////////////////////////////////////////////
    //-- Other Multi-Frame Composition Method

#else
#endif // #if MF_COMPOSE_METHOD == ?



    //
    return ret;

} // classMFNR::BlockMatching_MvCompensate()


/************************************************************************/
// Func: classMFNR::SpatialDenoise()
// Desc: SpatialDenoise
//   In: pRawDst		- Raw Dst data pointer
//       pRawDstCpy     - Raw Dst copy data pointer
//       pRawDstWeight	- Raw Dst Gain pointer
//  Out: pRawDst		- Raw Dst data pointer
// 
// Date: Revised by yousf 20160706
// 
/*************************************************************************/
int classMFNR::SpatialDenoise()
{
	//
	int     ret = 0; // return value


	int rawRow, rawCol;
	memcpy(pRawDstCpy, pRawDst, sizeof(RK_U16) * mRawWid * mRawHgt);


	for (rawRow = 2;rawRow < mRawHgt - 2; ++rawRow) 
	{	
		for (rawCol = 2;rawCol < mRawWid - 2; ++rawCol) 
		{
			//
// 			if ( *(pRawDstWeight + rawRow * mRawWid + rawCol) < 192 )
// 			{
// 				continue;
// 			}
			
			int temp = 0;
			for (int i = -2;i <= 2; i += 2) 
			{
				for (int j = -2;j <= 2; j += 2) 
				{
					temp = temp + *(pRawDstCpy + (rawRow + i) * mRawWid + rawCol + j);
				}
			}
			temp = ROUND_U16(temp / 9.0);
			//RK_F32 thre = MotionDetectTable7[temp] / sqrt(mRawFileNum*1.0) * *(pRawDstWeight + rawRow * mRawWid + rawCol) / 128;	

			RK_F32 thre = MotionDetectTable7[temp] / sqrt(mRawFileNum*1.0);
			RK_U32 gain = *(pRawDstWeight + rawRow * mRawWid + rawCol);


			int sum = 0;
			int weight = 0;
			for (int i = -2;i <= 2; i += 2) 
			{
				for (int j = -2;j <= 2; j += 2) 
				{
					//if (FABS(*(pRawDstCpy + rawRow * mRawWid + rawCol) - *(pRawDstCpy + (rawRow + i) * mRawWid + rawCol + j)) <= 0.6 * thre) 
					if (FABS(*(pRawDstCpy + rawRow * mRawWid + rawCol) - *(pRawDstCpy + (rawRow + i) * mRawWid + rawCol + j)) <= (gain / 128.0 / mIspGain) * 3.6 * thre) 
					{
						// Method-1
						sum += *(pRawDstCpy + (rawRow + i) * mRawWid + rawCol + j);
						weight += 1;

						/*/ Method-2
						if (abs(i)==2 && abs(j)==2)
						{
							sum += *(pRawDstCpy + (rawRow + i) * mRawWid + rawCol + j);
							weight += 1;
						}
						else if (i==0 && j==0)
						{
							sum += *(pRawDstCpy + (rawRow + i) * mRawWid + rawCol + j) * 4;
							weight += 4;
						}
						else
						{
							sum += *(pRawDstCpy + (rawRow + i) * mRawWid + rawCol + j) * 2;
							weight += 2;
						}//*/

					}
				}
			}
			*(pRawDst + rawRow * mRawWid + rawCol) = ROUND_U16(sum * 1.0 / weight);
		}
	}
	//free(pRawDstCpy);

	//
	return ret;
} // classMFNR::SpatialDenoise()


/************************************************************************/
// Func: classMFNR::EdgeDenoise()
// Desc: SpatialDenoise
//   In: pRawDst		- Raw Dst data pointer
//       pRawDstCpy     - Raw Dst copy data pointer
//       pRawDstWeight	- Raw Dst Gain pointer
//  Out: pRawDst		- Raw Dst data pointer
// 
// Date: Revised by yousf 20160720
// 
/*************************************************************************/
int classMFNR::EdgeDenoise()
{
	//
	int     ret = 0; // return value
	int win = 1;	//	denoise radius
	/*
	double sigmaR = 2000;
	double sigmaD;
	*/

	int rawRow, rawCol;
	memcpy(pRawDstCpy, pRawDst, sizeof(RK_U16) * mRawWid * mRawHgt);

	RK_U16 *edge = (RK_U16 *)malloc(sizeof(RK_U16) * mRawWid * mRawHgt);
	memset(edge, 0, sizeof(RK_U16) * mRawWid * mRawHgt);

	//int mask = 4;
	/*
	for (rawRow = 6;rawRow < mRawHgt - 6; ++rawRow)
	{
		for (rawCol = 6;rawCol < mRawWid - 6; ++rawCol)
		{
			int d1, d2, d3, d4, d5, d6, d7, d8;
			double mdt = MotionDetectTable7[ROUND_U16((*(pRawDst + rawRow * mRawWid + rawCol) - 64.0) / *(pRawDstWeight + rawRow * mRawWid + rawCol) * 128 + 64)];
			//mdt = MAX(0.648*sqrt(MAX((*(pRawDst + rawRow * mRawWid + rawCol) - 64.0) / *(pRawDstWeight + rawRow * mRawWid + rawCol) * 128, 0) * 8),4);
			double th = (mdt - 0) / sqrt(mRawFileNum) * *(pRawDstWeight + rawRow * mRawWid + rawCol) / 128 * 8;
			//th = th * 8 * ((*(pRawDst + rawRow * mRawWid + rawCol) - 64.0) / 64 + 1);
			//th = th * ((*(pRawDst + rawRow * mRawWid + rawCol) - 64.0) / 4 + 4);

			switch (mask)
			{
			case 1:
				d1 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 6) * mRawWid + rawCol));
				d2 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 4) * mRawWid + rawCol + 4));
				d3 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + rawRow * mRawWid + rawCol + 6));
				d4 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 4) * mRawWid + rawCol + 4));
				d5 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 6) * mRawWid + rawCol));
				d6 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 4) * mRawWid + rawCol - 4));
				d7 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + rawRow * mRawWid + rawCol - 6));
				d8 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 4) * mRawWid + rawCol - 4));
				break;
			case 2:
				d1 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 4) * mRawWid + rawCol + 2));
				d2 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 2) * mRawWid + rawCol + 4));
				d3 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 2) * mRawWid + rawCol + 4));
				d4 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 4) * mRawWid + rawCol + 2));
				d5 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 4) * mRawWid + rawCol - 2));
				d6 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 2) * mRawWid + rawCol - 4));
				d7 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 2) * mRawWid + rawCol - 4));
				d8 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 4) * mRawWid + rawCol - 2));
				break;
			case 3:
				d1 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 4) * mRawWid + rawCol));
				d2 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 2) * mRawWid + rawCol + 2));
				d3 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + rawRow * mRawWid + rawCol + 4));
				d4 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 2) * mRawWid + rawCol + 2));
				d5 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 4) * mRawWid + rawCol));
				d6 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 2) * mRawWid + rawCol - 2));
				d7 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + rawRow * mRawWid + rawCol - 4));
				d8 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 2) * mRawWid + rawCol - 2));
				break;
			case 4:
				d1 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 2) * mRawWid + rawCol));
				d2 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 2) * mRawWid + rawCol + 2));
				d3 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + rawRow * mRawWid + rawCol + 2));
				d4 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 2) * mRawWid + rawCol + 2));
				d5 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 2) * mRawWid + rawCol));
				d6 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow + 2) * mRawWid + rawCol - 2));
				d7 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + rawRow * mRawWid + rawCol - 2));
				d8 = abs(*(pRawDst + rawRow * mRawWid + rawCol) - *(pRawDst + (rawRow - 2) * mRawWid + rawCol - 2));
				break;
			default:
				break;
			}
			int tm = MAX(d1, d2);
			tm = MAX(tm, d3);
			tm = MAX(tm, d4);
			tm = MAX(tm, d5);
			tm = MAX(tm, d6);
			tm = MAX(tm, d7);
			int dm = MAX(tm, d8);
			int c1 = (dm > th / 2);
			int c2 = (dm > th / 4);
			int c3 = (dm > th / 8);
			int c4 = (dm > th / 16);
			*(edge + rawRow * mRawWid + rawCol) = c1 + c2 + c3 + c4;
		}
	}
	*/
	/*
	for (int k = 4;k >= 2;--k)
	{
		for (rawRow = 4;rawRow < mRawHgt - 4; ++rawRow)
		{
			for (rawCol = 4;rawCol < mRawWid - 4; ++rawCol)
			{
				if (*(edge + rawRow * mRawWid + rawCol) == k)
				{
					for (int i = -2;i <= 2;i += 2)
					{
						for (int j = -2;j <= 2;j += 2)
						{
							*(edge + (rawRow + i) * mRawWid + rawCol + j) = MAX(*(edge + (rawRow + i) * mRawWid + rawCol + j), k - 1);
						}
					}
				}
			}
		}
	}
	*/
	for (rawRow = 5;rawRow < mRawHgt - 5; ++rawRow)
	{
		for (rawCol = 5;rawCol < mRawWid - 5; ++rawCol)
		{
			double sum = 0;
			double weight = 0;
			for (int i = -win * 2;i <= win * 2;i += 2)
			{
				for (int j = -win * 2;j <= win * 2;j += 2)
				{
					//double g = exp(-(i * i + j * j) / (2 * sigmaR * sigmaR));
					double g = 1;
					double mdt = MotionDetectTable7[ROUND_U16((*(pRawDst + rawRow * mRawWid + rawCol) - 64.0) * 1.0 / *(pRawDstWeight + rawRow * mRawWid + rawCol) * 128 + 64)];
					//mdt = 0.648*sqrt(MAX((*(pRawDst + rawRow * mRawWid + rawCol) - 64.0) / *(pRawDstWeight + rawRow * mRawWid + rawCol) * 128, 0) * 8);
					//double m = (mdt - 0) / sqrt(mRawFileNum) * *(pRawDstWeight + rawRow * mRawWid + rawCol) / 128 / 16;
					//m = m * pow(*(pRawDst + rawRow * mRawWid + rawCol), 1.0) / 128;

					/*
					switch (*(edge + rawRow * mRawWid + rawCol)) {
					//switch (0) {
					case 0:
						sigmaD = m * 4;
						break;
					case 1:
						sigmaD = m * 2;
						break;
					case 2:
						sigmaD = m * 1;
						break;
					case 3:
						sigmaD = m * 0.5;
						break;
					case 4:
						sigmaD = m * 0.25;
						break;
					default:
						break;
					}
					*/

					double temp = ABS_U16(*(pRawDstCpy + rawRow * mRawWid + rawCol) * 1.0 / *(pRawDstWeight + rawRow * mRawWid + rawCol) * 128 - *(pRawDstCpy + (rawRow + i) * mRawWid + rawCol + j) * 1.0 / *(pRawDstWeight + (rawRow + i) * mRawWid + rawCol + j) * 128);
					//double h = exp(-temp * temp / (2 * sigmaD * sigmaD));
					double h;
					if(temp <= mdt / 8)
						h = 0.125;
					else if(temp <= mdt / 4)
						h = 0.0625;
					else if(temp <= mdt / 2)
						h = 0.03125;
					else
						h = 0;
					if (*(pRawDstCpy + rawRow * mRawWid + rawCol) <= 80)
						h = 0;
					else
						h = h / 128 * *(pRawDstCpy + rawRow * mRawWid + rawCol);
					if (i == 0 && j == 0)
						h = 1;
					sum += g * h * *(pRawDstCpy + (rawRow + i) * mRawWid + rawCol + j);
					weight += g * h;
				}
			}
			*(pRawDst + rawRow * mRawWid + rawCol) = ROUND_U16(sum / weight);
		}
	}
	return ret;
}


/************************************************************************/
// Func: classMFNR::AutoWhiteBalance()
// Desc: Auto White Balance
//   In: pRawDst		- Raw Dst data pointer
//  Out: pRawDst		- Raw Dst data pointer
// 
// Date: Revised by yousf 20160530
// 
/*************************************************************************/
int classMFNR::AutoWhiteBalance()
{
    //
    int     ret = 0; // return value
    //
#if USE_AWB == 1 // 1-use Auto White Balance, 0-not use
    //
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::AutoWhiteBalance()\n");
#endif

    //
    int         RawPixelStride  = mRaw16Stride/2;               // Raw Pixel Stride
    RK_U16*     pTmpRaw         = pRawDst;                      // Temp Raw Pointer
    for (int i=0; i < mRawHgt; i++)
    {
        for (int j=0; j < mRawWid; j++)
        {
            //printf("i=%d,j=%d,b=%d\n", i, j, i%2 * 2 + j%2);
            *pTmpRaw = RK_U16((*pTmpRaw - AWB_BLACK_LEVEL) * mAwbGains[i%2 * 2 + j%2]/4 + AWB_BLACK_LEVEL);
            pTmpRaw++;
        }
    }

#endif

    //
    return ret;

} // classMFNR::AutoWhiteBalance()


/************************************************************************/
// Func: classMFNR::DetailEnhancer()
// Desc: Detail Enhancer
//   In: pRawDst		- Raw Dst data pointer
//  Out: pRawDst		- Raw Dst data pointer
// 
// Date: Revised by yousf 20160530
// 
/*************************************************************************/
int classMFNR::DetailEnhancer()
{
    //
    int     ret = 0; // return value
    //
#if USE_DETAIL_ENHANCER == 1 // 1-use DetailEnhancer
    //
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::DetailEnhancer()\n");
#endif
    //

    // Method-1
    int         i0, i1, j0, j1;
    RK_U16*     pTmpDst = pFiltData;
    int         sumFilt;
    for (int i=0; i < hgt; i++)
    {
        for (int j=0; j < wid; j++)
        {
            //if (i>1 && i<hgt-2 && j>1 && j<wid-2)
            {
                //
                //                 i0 = MAX(i - 2, 0);
                //                 i1 = MIN(i + 2, hgt - 1);
                //                 j0 = MAX(j - 2, 0);
                //                 j1 = MIN(j + 2, wid - 1);
                //
                i0 = MAX(i - 2, i%2);
                i1 = MIN(i + 2, hgt - 1 - (i+1)%2);
                j0 = MAX(j - 2, j%2);
                j1 = MIN(j + 2, wid - 1 - (j+1)%2);
                //                printf("i-2=%d, i=%d, i+2=%d, j-2=%d, j=%d, j+2=%d\n", i0, i, i1, j0, j, j1);
                //
                sumFilt = *(pRawData + i0 * wid + j0) * 1
                    + *(pRawData + i0 * wid + j ) * 2
                    + *(pRawData + i0 * wid + j1) * 1
                    + *(pRawData + i  * wid + j0) * 2
                    + *(pRawData + i  * wid + j ) * 4
                    + *(pRawData + i  * wid + j1) * 2
                    + *(pRawData + i1 * wid + j0) * 1
                    + *(pRawData + i1 * wid + j ) * 2
                    + *(pRawData + i1 * wid + j1) * 1;
                //
                *pTmpDst = (RK_U16)(sumFilt >> 4); // 2^4=16
            }
            //             else
            //             {
            //                 *pTmpDst = *(pRawData + i  * wid + j );
            //             }

            pTmpDst++;
        }
    }


#endif

    //
    return ret;

} // classMFNR::DetailEnhancer()


/************************************************************************/
// Func: classMFNR::LowLightEnhancer()
// Desc: Low Light Enhancer
//   In: pRawDst		- Raw Srcs data pointers
//  Out: pRawDst		- Raw Srcs data pointers
// 
// Date: Revised by yousf 20160603
// 
/*************************************************************************/
int classMFNR::LowLightEnhancer()
{
    //
    int     ret = 0; // return value
    //
#if USE_LOW_LIGHT_ENHANCER == 1 // 1-use LowLightEnhancer
    //
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::LowLightEnhancer()\n");
#endif
    //
    RK_U16*     pTmpDstLine0 = pRawDst;
    RK_U16*     pTmpDstLine1 = pRawDst + mRaw16Stride/2;
    RK_U16      SrcB00, SrcB01, SrcB10, SrcB11;
    RK_U16      SrcMax;
    RK_F32      Gain;

    //
    for (int i=0; i < mRawHgt/2; i++)
    {
        for (int j=0; j < mRawWid/2; j++)
        {
// #if MY_DEBUG_PRINTF == 1
//             printf("LowLightEnhancer()----Point(#i=%d,#j=%d)\n", i, j);
// #endif
            // Src Bayer 2x2
            SrcB00 = MAX(MIN(*(pTmpDstLine0 + 0), 0x3FF) - BLACK_LEVEL, 0);
            SrcB01 = MAX(MIN(*(pTmpDstLine0 + 1), 0x3FF) - BLACK_LEVEL, 0);
            SrcB10 = MAX(MIN(*(pTmpDstLine1 + 0), 0x3FF) - BLACK_LEVEL, 0);
            SrcB11 = MAX(MIN(*(pTmpDstLine1 + 1), 0x3FF) - BLACK_LEVEL, 0);

            // Src Bayer Max
            SrcMax = 0;
            SrcMax = MAX(SrcMax, SrcB00);
            SrcMax = MAX(SrcMax, SrcB01);
            SrcMax = MAX(SrcMax, SrcB10);
            SrcMax = MAX(SrcMax, SrcB11);

            // Gain
            //Gain = LowLightTable[SrcMax] * 1.0 / SrcMax;    // LowLightTable
			if (mTestParams[3] == 1) // mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
			{
				Gain = LowLightGainTable[SrcMax];               // LowLightGainTable
			}
			else if(mTestParams[3] == 2) // mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
			{
				Gain = LowLightGainTable2[FLOOR(mTestParams[2] / 2)][SrcMax]; // mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
			}
			else
			{
				Gain = 1.0; // 
			}
            
			

            // Dst Bayer 2x2
            *(pTmpDstLine0 + 0) = ROUND_U16(SrcB00 * Gain) + BLACK_LEVEL;
            *(pTmpDstLine0 + 1) = ROUND_U16(SrcB01 * Gain) + BLACK_LEVEL;
            *(pTmpDstLine1 + 0) = ROUND_U16(SrcB10 * Gain) + BLACK_LEVEL;
            *(pTmpDstLine1 + 1) = ROUND_U16(SrcB11 * Gain) + BLACK_LEVEL;



            // Next Col Bayer 2x2
            pTmpDstLine0 += 2;
            pTmpDstLine1 += 2;

        } // for i

        // Next 2-Line
        pTmpDstLine0 += mRaw16Stride/2;
        pTmpDstLine1 += mRaw16Stride/2;

    } // for i
    
#endif

    //
    return ret;

} // classMFNR::LowLightEnhancer()


/************************************************************************/
// Func: classMFNR::MFNR_Execute()
// Desc: Draw Test Params
//   In: mTestParams	- Test Params
//       numTP   		- num of Test Params
//  Out: pRawDst        - Raw Dst data pointer
// 
// Date: Revised by yousf 20160711
// 
/*************************************************************************/
int classMFNR::DrawTestParams(int numTP)
{
	//
	int     ret = 0; // return value

	int numTestParams = numTP;
	/////---- mTestParams Mark
	// mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
	// mTestParams[1]	 1-Use PreGain-PostBlk   2-Use PreBlk-PostGain
	// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
	// mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
	// mTestParams[4]    0-FixedMotionDetectThreshold, n-MotionDetectTable[n], n=1,2,...,8
	// mTestParams[5]    0-OldWdrParamPol, 1-NewWdrParamMax
	// mTestParams[6]    0-NotUseRegister, 1-UseRegister
	// mTestParams[7]    0-NotUseOppoBlk, 1-UseOppoBlk
	// mTestParams[8]    n-nFrameCompose, n = 1,2,3,...
	// mTestParams[9]    1-NonOverlap, 2-OverlapStep1/2, 4-OverlapStep1/4, ...
	int MarkWid = 32;
	int MarkHgt = 40;
	int tMax;
	if (mTestParams[3] == 3)
	{
		mTestParams[2] = mIspGain;
	}
	for (int t=0; t <= numTestParams; t++)
	{
		for (int i=500; i<500+MarkHgt; i++)
		{
			memset(pRawDst + (i+MarkHgt*t)*mRawWid + 495, 0x2, sizeof(RK_U16)*5);
		}
		for (int i=500; i<532; i++)
		{
			if (t==1 || t==2 || t==8 || t==9)
			{
				tMax  = mTestParams[t] - 1; // 1,2,3,...
			}
			else
			{
				tMax  = mTestParams[t];		//0,1,2,...
			}

			for (int k=0; k <= tMax; k++)
			{
				if (k%2 == 0)
				{
					memset(pRawDst + (i+MarkHgt*t)*mRawWid + 500 + k*MarkWid, 0x2, sizeof(RK_U16)*MarkWid);
				}
				else
				{
					memset(pRawDst + (i+MarkHgt*t)*mRawWid + 500 + k*MarkWid, 0x1, sizeof(RK_U16)*MarkWid);
				}
			}
		}
	}


	//
	return ret;

} // classMFNR::DrawTestParams()


/************************************************************************/
// Func: classMFNR::MFNR_Execute()
// Desc: MFNR Execute
//   In: pThumbSrcs		- Thumb Srcs data pointers
//       pRawSrcs		- Raw Srcs data pointers
//  Out: pOutData       - result data pointer
// 
// Date: Revised by yousf 20160624
// 
/*************************************************************************/
int classMFNR::MFNR_Execute(void* pOutData)
{
    //
    int     ret = 0; // return value
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::MFNR_Execute()\n");
#endif
    // Output pointer
    pRawDst = (RK_U16*)pOutData;
	//memset(pRawDst, 0, sizeof(RK_U16) * mRawWid * mRawHgt);

	int			numTestParams = 10;		// num of mTestParams: 0,..,numTestParams
	

	//////////////////////////////////////////////////////////////////////////
	////==== 1 Frame
	if (mTestParams[8] <= 1) // mTestParams[8]    n-nFrameCompose, n = 1,2,3,...
	{
		RK_U16*		pTmp = pRawDst;	// temp pointer to Frame#0
		RK_F32		tmp  = 0;
		for (int r=0; r < mRawHgt; r++)
		{
			for (int c=0; c < mRawWid; c++)	
			{
				tmp   = *pTmp * mIspGain;
				tmp   = tmp - (mIspGain - 1) * mBlackLevel[r%2 * 2 + c%2] / 4;
				tmp   = MIN(tmp, 1023);
				*pTmp = ROUND_U16(tmp);
				pTmp++;
			}
		}


		/////---- mTestParams Mark
		// mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
		// mTestParams[1]	 1-Use PreGain-PostBlk   2-Use PreBlk-PostGain
		// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
		// mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
		// mTestParams[4]    0-FixedMotionDetectThreshold, n-MotionDetectTable[n], n=1,2,...,8
		// mTestParams[5]    0-OldWdrParamPol, 1-NewWdrParamMax
		// mTestParams[6]    0-NotUseRegister, 1-UseRegister
		// mTestParams[7]    0-NotUseOppoBlk, 1-UseOppoBlk
		// mTestParams[8]    n-nFrameCompose, n = 1,2,3,...
		// mTestParams[9]    1-NonOverlap, 2-OverlapStep1/2, 4-OverlapStep1/4, ...
		// mTestParams[10]   0-NotUseSpatialDenoise, 1-UseSpatialDenoise, 2-UseEdgeDenoise
		DrawTestParams(numTestParams);	// Draw Test Params


	} // 1 Frame


	//////////////////////////////////////////////////////////////////////////
	////==== NotUseRegister
	if (mTestParams[6] == 0) // mTestParams[6]    0-NotUseRegister, 1-UseRegister
	{
		RK_F32 tmp = 0;
		
		if (mTestParams[3] == 3)
		{
			// WDR
			for (int i=0; i < mRawHgt; i++)
			{
				for (int j=0; j < mRawWid; j++)
				{
					tmp = 0;
					for (int k=0; k < mRawFileNum; k++)
					{
						tmp += *(pRawSrcs[k] + i * mRawWid + j);
					}
					tmp = tmp * mTestParams[2] / mRawFileNum; // mTestParams[2] = 8
					tmp = MIN(tmp, 8191); // 10bit * 8
					*(pRawDstGain + i * mRawWid + j) = ROUND_U16(tmp);

				}
			}

			//bayer_wdr(pRawDstGain, pRawDstGainWDR, mRawWid, mRawHgt, mIspGain, mTestParams[5]);// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
			bayer_wdr(pRawDstGain, pRawDstGainWDR, mRawWid, mRawHgt, mIspGain, pRawDstWeight, mTestParams[5]);// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
			
			// 	char rawfilename[1024]; // raw data filename
			// 	sprintf(rawfilename, "D:/adb_tools/0603_v220new_OPPORAW/0112326-%d_%d_pRawDstGain_16.raw", mRawWid, mRawHgt);
			// 	WriteRaw16Data((RK_U16*)pRawDstGain, mRawWid, mRawHgt, rawfilename);

			// 	sprintf(rawfilename, "D:/adb_tools/0603_v220new_OPPORAW/0112326-%d_%d_pRawDstGainWDR_16.raw", mRawWid, mRawHgt);
			// 	WriteRaw16Data((RK_U16*)pRawDstGainWDR, mRawWid, mRawHgt, rawfilename);

			memcpy(pRawDst, pRawDstGainWDR, sizeof(RK_S16) * mRawWid * mRawHgt);

		}
		else
		{
			// Linear
			for (int i=0; i < mRawHgt; i++)
			{
				for (int j=0; j < mRawWid; j++)
				{
					tmp = 0;
					for (int k=0; k < mRawFileNum; k++)
					{
						tmp += *(pRawSrcs[k] + i * mRawWid + j);
						//printf("i=%d,j=%d,k=%d,src=%d, sum=%.0f\n",i,j,k, *(pRawSrcs[k] + i * mRawWid + j), tmp);
					}
					tmp = tmp / mRawFileNum * mIspGain;
					tmp = tmp - (mIspGain -1) * mBlackLevel[i%2 * 2 + j%2] / 4; // black=64or
					tmp = MIN(tmp, 1023); // 10bit
					*(pRawDst + i * mRawWid + j) = ROUND_U16(tmp);

				}
			}
		}
		

		//// WDR + Denoise
		//if (mTestParams[3] == 3 && mTestParams[10] == 1)
		if (mTestParams[10] == 1)
		{
			// mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
			// mTestParams[10]   0-NotUseSpatialDenoise, 1-UseSpatialDenoise, 2-UseEdgeDenoise
			SpatialDenoise();
		}
		//else if (mTestParams[3] == 3 && mTestParams[10] == 2)
		else if (mTestParams[10] == 2)
		{
			// mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
			// mTestParams[10]   0-NotUseSpatialDenoise, 1-UseSpatialDenoise, 2-UseEdgeDenoise
			EdgeDenoise();
		}


		/////---- mTestParams Mark
		// mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
		// mTestParams[1]	 1-Use PreGain-PostBlk   2-Use PreBlk-PostGain
		// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
		// mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
		// mTestParams[4]    0-FixedMotionDetectThreshold, n-MotionDetectTable[n], n=1,2,...,8
		// mTestParams[5]    0-OldWdrParamPol, 1-NewWdrParamMax
		// mTestParams[6]    0-NotUseRegister, 1-UseRegister
		// mTestParams[7]    0-NotUseOppoBlk, 1-UseOppoBlk
		// mTestParams[8]    n-nFrameCompose, n = 1,2,3,...
		// mTestParams[9]    1-NonOverlap, 2-OverlapStep1/2, 4-OverlapStep1/4, ...
		// mTestParams[10]   0-NotUseSpatialDenoise, 1-UseSpatialDenoise, 2-UseEdgeDenoise
		DrawTestParams(numTestParams);	// Draw Test Params

		//
		return ret;
	}
	
    //////////////////////////////////////////////////////////////////////////
    ////---- Determine Base Frame
    DetermineBaseFrame();
    // Num of Valid RefFrame = 0
	//mBasePicNum = 0;
    if (mCntValidRefFrm == 0)
    {
        memcpy(pRawDst, pRawSrcs[mBasePicNum], sizeof(RK_U8) * mRaw16DataSize);
        return 0;
    }

    ////---- Thumb Coarse Matching 
    BlockCoarseMatching();

    ////---- Luma Fine Matching
    BlockFineMatching();

    ////---- ComputeHomography: pHomographyMatrix
    ComputeHomography(); 

    ////---- BlockMatching & Multi-Frame MV Compensate
    BlockMatching_MvCompensate();

	if (mTestParams[3] == 3) // mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
	{
//		bayer_wdr(pRawDstGain, pRawDstGainWDR, mRawWid, mRawHgt, mTestParams[2], mTestParams[5]);// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
		//bayer_wdr(pRawDstGain, pRawDstGainWDR, mRawWid, mRawHgt, mIspGain, mTestParams[5]);// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)

		bayer_wdr(pRawDstGain, pRawDstGainWDR,      mRawWid, mRawHgt, mIspGain, pRawDstWeight, mTestParams[5]);// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)

		ceva_bayer_wdr(pRawDstGain, pRawDstGainWDR_CEVA, mRawWid, mRawHgt, mIspGain, pRawDstWeight, mTestParams[5]);// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)

		if(check_wdr_result(pRawDstGainWDR,pRawDstGainWDR_CEVA, mRawWid , mRawHgt))
			fprintf(stderr,"WDR check failed.\n");


// 		char rawfilename[1024]; // raw data filename
// 		sprintf(rawfilename, "pRawDstWeight.raw");
// 		WriteRaw16Data((RK_U16*)pRawDstWeight, mRawWid*2, mRawHgt, rawfilename);

		// 	char rawfilename[1024]; // raw data filename
		// 	sprintf(rawfilename, "D:/adb_tools/0603_v220new_OPPORAW/0112326-%d_%d_pRawDstGain_16.raw", mRawWid, mRawHgt);
		// 	WriteRaw16Data((RK_U16*)pRawDstGain, mRawWid, mRawHgt, rawfilename);
		// 	sprintf(rawfilename, "D:/adb_tools/0603_v220new_OPPORAW/0112326-%d_%d_pRawDstGainWDR_16.raw", mRawWid, mRawHgt);
		// 	WriteRaw16Data((RK_U16*)pRawDstGainWDR, mRawWid, mRawHgt, rawfilename);
		memcpy(pRawDst, pRawDstGainWDR, sizeof(RK_S16) * mRawWid * mRawHgt);
	}
	

	//// WDR + Denoise
	//if (mTestParams[3] == 3 && mTestParams[10] == 1)
	if (mTestParams[10] == 1)
	{
		// mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
		// mTestParams[10]   0-NotUseSpatialDenoise, 1-UseSpatialDenoise, 2-UseEdgeDenoise
		SpatialDenoise();
	}
	//else if (mTestParams[3] == 3 && mTestParams[10] == 2)
	else if (mTestParams[10] == 2)
	{
		// mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
		// mTestParams[10]   0-NotUseSpatialDenoise, 1-UseSpatialDenoise, 2-UseEdgeDenoise
		EdgeDenoise();
	}
	
	
    //// Auto White Balance
//    AutoWhiteBalance();

    ////---- Detail Enhancer
//    DetailEnhancer();

    ////---- Low Light Enhancer
	if (mTestParams[3] == 1) // mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
	{
		LowLightEnhancer();
	}

	
	/////---- mTestParams Mark
	// mTestParams[0]	 0-Not use MAX(64,refValue), 1-Use MAX(64,refValue)    
	// mTestParams[1]	 1-Use PreGain-PostBlk   2-Use PreBlk-PostGain
	// mTestParams[2]    n-Gain x n, n=1,2,... (n>=1, float)
	// mTestParams[3]    0-LinearGain, 1-OldNonLinearGain, 2-NewNonLinearGain, 3-LnNonLinearGain_WDR
	// mTestParams[4]    0-FixedMotionDetectThreshold, n-MotionDetectTable[n], n=1,2,...,8
	// mTestParams[5]    0-OldWdrParamPol, 1-NewWdrParamMax
	// mTestParams[6]    0-NotUseRegister, 1-UseRegister
	// mTestParams[7]    0-NotUseOppoBlk, 1-UseOppoBlk
	// mTestParams[8]    n-nFrameCompose, n = 1,2,3,...
	// mTestParams[9]    1-NonOverlap, 2-OverlapStep1/2, 4-OverlapStep1/4, ...
	// mTestParams[10]   0-NotUseSpatialDenoise, 1-UseSpatialDenoise, 2-UseEdgeDenoise
	DrawTestParams(numTestParams);	// Draw Test Params


    //
    return ret;

} // classMFNR::MFNR_Execute()


/************************************************************************/
// Func: classMFNR::MFNR_Close()
// Desc: MFNR Close
//   In: 
//  Out: 
// 
// Date: Revised by yousf 20160622
// 
/*************************************************************************/
int classMFNR::MFNR_Close(void)
{
    //
    int     ret = 0; // return value
#if MY_DEBUG_PRINTF == 1
    printf("classMFNR::MFNR_Close()\n");
#endif
    //// Determine Base Frame
    // Sharpness of All Frame -> baseFrame
    if (pSharpOfAllFrm != NULL)
    {
        free(pSharpOfAllFrm);
        pSharpOfAllFrm = NULL;
    }
    // Sharpness of All 32x32 Segment in Frames
    for (int k=0; k < RK_MAX_FILE_NUM; k++)   
    {
        if (pSharpOfAllSeg[k] != NULL)
        {
            free(pSharpOfAllSeg[k]);
            pSharpOfAllSeg[k] = NULL;
        }
    }
    // MaxSharpness in each 32x32 Segment in Frames
    for (int k=0; k < RK_MAX_FILE_NUM; k++)   
    {
        if (pMaxSharpFrmSeg[k] != NULL)
        {
            free(pMaxSharpFrmSeg[k]);
            pMaxSharpFrmSeg[k] = NULL;
        }
    }
    // Thumb Data Chunk
    if (pThumbDataChunk != NULL)
    {
        free(pThumbDataChunk);
        pThumbDataChunk = NULL;
    }
    // Frame Mark: 0-Base 1-ValidRef 2-InvalidRef
    if (pValidMark != NULL)
    {
        free(pValidMark);
        pValidMark = NULL;
    }
    // MaxSharpness in each 32x32 Segment in BaseFrame
    if (pMaxSharpBaseSeg != NULL)
    {
        free(pMaxSharpBaseSeg);
        pMaxSharpBaseSeg = NULL;
    }

    //// Block Coarse Matching
    // MatchResult: { [RegMarkRow, RegMarkCol], [matchRow, matchCol, SAD]*RawFileNum } * cntFeature
    if (pMatchPoints != NULL)
    {
        free(pMatchPoints);
        pMatchPoints = NULL;
    }
    // 16x16Block in 32x32 Segment in BaseFrame
    if (pThumbBaseBlk != NULL)
    {
        free(pThumbBaseBlk);
        pThumbBaseBlk = NULL;
    }
    // (16+2*radius)x(16+2*radius')Block in RefFrame
    if (pThumbRefBlk != NULL)
    {
        free(pThumbRefBlk);
        pThumbRefBlk = NULL;
    }

    //// Block Fine Matching
    // 64x64Block in 256x256 Segment in BaseFrame
    if (pRawBaseBlk != NULL)
    {
        free(pRawBaseBlk);
        pRawBaseBlk = NULL;
    }
    // Luma of 64x64Block in 256x256 Segment in BaseFrame
    if (pRawBaseBlkLuma != NULL)
    {
        free(pRawBaseBlkLuma);
        pRawBaseBlkLuma = NULL;
    }
    // (64+2*radius)x(64+2*radius')Block in RefFrame
    if (pRawRefBlk != NULL)
    {
        free(pRawRefBlk);
        pRawRefBlk = NULL;
    }
    // Luma of (64+2*radius)x(64+2*radius')Block in RefFrame
    if (pRawRefBlkLuma != NULL)
    {
        free(pRawRefBlkLuma);
        pRawRefBlkLuma = NULL;
    }

    //// Compute Homography
#if USE_MV_HIST_FILTRATE == 1
    // Marks of Match Feature in BaseFrame & RefFrame#k
    if (pMarkMatchFeature != NULL)
    {
        free(pMarkMatchFeature);
        pMarkMatchFeature = NULL;
    }
    // RowMV Hist
    if (pRowMvHist != NULL)
    {
        free(pRowMvHist);
        pRowMvHist = NULL;
    }
    // ColMV Hist
    if (pColMvHist != NULL)
    {
        free(pColMvHist);
        pColMvHist = NULL;
    }
#endif

    // Agents in 4x4 Region [RegMark4x4, Sharp/SAD, 2*RawFileNum]*16
    if (pAgentsIn4x4Region != NULL)
    {
        free(pAgentsIn4x4Region);
        pAgentsIn4x4Region = NULL;
    }
    // 4 points in 4 Regions: [x0,y0,x1,y1] * 4Points * 2Byte
    if (pRegion4Points != NULL)
    {
        free(pRegion4Points);
        pRegion4Points = NULL;
    }
    // Homography: [9*RawFileNum] * 4Byte
    if (pHomographyMatrix != NULL)
    {
        free(pHomographyMatrix);
        pHomographyMatrix = NULL;
    }
    // Coefficient Matrix A for A*X = B: 8*8*4Byte
    if (pMatrixA != NULL)
    {
        free(pMatrixA);
        pMatrixA = NULL;
    }
    // Coefficient Vector B for A*X = B: 8*1*4Byte
    if (pVectorB != NULL)
    {
        free(pVectorB);
        pVectorB = NULL;
    }
    // Coefficient Vector X for A*X = B: 3*3*4Byte
    if (pVectorX != NULL)
    {
        free(pVectorX);
        pVectorX = NULL;
    }
    // Perspective Project Point: 2*4Byte
    if (pProjectPoint != NULL)
    {
        free(pProjectPoint);
        pProjectPoint = NULL;
    }

    //// BlockMatching & Multi-Frame MV Compensate
    // BlockMatching Base Blocks: 32*32*2Byte * 4
    for (int k=0; k < LUMA_MATCH_WIN_NUM; k++)   
    {
        if (pBlkMatchBaseBlks[k] != NULL)
        {
            free(pBlkMatchBaseBlks[k]);
            pBlkMatchBaseBlks[k] = NULL;
        }
    }
    // Luma of BlockMatching Base Blocks: 16*16*2Byte * 4
    for (int k=0; k < LUMA_MATCH_WIN_NUM; k++)   
    {
        if (pBlkMatchBaseBlksLuma[k] != NULL)
        {
            free(pBlkMatchBaseBlksLuma[k]);
            pBlkMatchBaseBlksLuma[k] = NULL;
        }
    }
    // BlockMatching Ref Block: (32+2*radius)*(32+2*radius')*2Byte * 4
    for (int k=0; k < LUMA_MATCH_WIN_NUM; k++)   
    {
        if (pBlkMatchRefBlks[k] != NULL)
        {
            free(pBlkMatchRefBlks[k]);
            pBlkMatchRefBlks[k] = NULL;
        }
    }
    // Luma of BlockMatching Ref Block: (32+2*radius)/2*(32+2*radius')/2*2Byte * 4
    for (int k=0; k < LUMA_MATCH_WIN_NUM; k++)   
    {
        if (pBlkMatchRefBlksLuma[k] != NULL)
        {
            free(pBlkMatchRefBlksLuma[k]);
            pBlkMatchRefBlksLuma[k] = NULL;
        }
    }
    // BlockMatching Dst Block: 32*32*2Byte * 4
    for (int k=0; k < LUMA_MATCH_WIN_NUM; k++)   
    {
        if (pBlkMatchDstBlks[k] != NULL)
        {
            free(pBlkMatchDstBlks[k]);
            pBlkMatchDstBlks[k] = NULL;
        }
    }
    // Block Center Point: 2*2Byte
    if (pBlkCenterPoint != NULL)
    {
        free(pBlkCenterPoint);
        pBlkCenterPoint = NULL;
    }
    // Even & Odd Block Match Points Cache:  ceil(ceil(RawWid/32)/4)*4 * 2 * 6 * 2Byte * 2
    for (int k=0; k < 2; k++)   
    {
        if (pTwoLineBlkMPs[k] != NULL)
        {
            free(pTwoLineBlkMPs[k]);
            pTwoLineBlkMPs[k] = NULL;
        }
    }
    // Match Result Rects of All RefFrame: 2 * 6 * 2Bte
    if (pMatchResultRects != NULL)
    {
        free(pMatchResultRects);
        pMatchResultRects = NULL;
    }
    // Block Weights: 32*32*4*1Byte
    if (pBlockWeights != NULL)
    {
        free(pBlockWeights);
        pBlockWeights = NULL;
    }
#if USE_MOTION_DETECT == 1 // 1-use Motion Detect, 0-not use
    // Filtered Base Raw data
    for (int k=0; k < LUMA_MATCH_WIN_NUM; k++)   
    {
        if (pBlkMatchBaseBlksFilt[k] != NULL)
        {
            free(pBlkMatchBaseBlksFilt[k]);
            pBlkMatchBaseBlksFilt[k] = NULL;
        }
    }
    // Filtered Ref Raw data
    for (int k=0; k < LUMA_MATCH_WIN_NUM; k++)   
    {
        if (pBlkMatchRefBlksFilt[k] != NULL)
        {
            free(pBlkMatchRefBlksFilt[k]);
            pBlkMatchRefBlksFilt[k] = NULL;
        }
    }
#endif

	// WDR
	if (pRawDstGain != NULL)
	{
		free(pRawDstGain);
		pRawDstGain = NULL;
	}
	if (pRawDstGainWDR != NULL)
	{
		free(pRawDstGainWDR);
		pRawDstGainWDR = NULL;
	}
	if (pRawDstGainWDR_CEVA != NULL)
	{
		free(pRawDstGainWDR_CEVA);
		pRawDstGainWDR_CEVA = NULL;
	}

	// Spatial Denoise
	if (pRawDstWeight != NULL)
	{
		free(pRawDstWeight);
		pRawDstWeight = NULL;
	}
	if (pRawDstCpy != NULL)
	{
		free(pRawDstCpy);
		pRawDstCpy = NULL;
	}


    //
    return ret;

} // classMFNR::MFNR_Close()



//////////////////////////////////////////////////////////////////////////




